<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.bwrong.cn</id>
    <title>BWrong的小站</title>
    <updated>2023-12-15T06:26:26.838Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.bwrong.cn"/>
    <link rel="self" href="https://www.bwrong.cn/atom.xml"/>
    <subtitle>天青色等烟雨，而我在等你</subtitle>
    <logo>https://www.bwrong.cn/images/avatar.png</logo>
    <icon>https://www.bwrong.cn/favicon.ico</icon>
    <rights>All rights reserved 2023, BWrong的小站</rights>
    <entry>
        <title type="html"><![CDATA[利用微信第三方平台发布零码小程序]]></title>
        <id>https://www.bwrong.cn/post/Goa6oYxl_/</id>
        <link href="https://www.bwrong.cn/post/Goa6oYxl_/">
        </link>
        <updated>2023-12-15T06:12:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="难点">难点</h2>
<ul>
<li>将设计好的应用生成原生小程序代码：因为编辑时和运行时环境差异性，导致不能使用同一套代码，需要针对不同平台有不同的实现（实现方案二）。</li>
<li>将设计好的应用发布到商家自己的小程序中，需要对接微信第三方平台能力，主要是因为对这套发布流程不熟悉。</li>
</ul>
<h2 id="实现方案">实现方案：</h2>
<hr>
<h3 id="一-webapph5小程序复用h5版本">一、WebApp/H5小程序：复用H5版本</h3>
<p>在H5版本上，通过小程序<a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html">Webview</a>开放能力组件实现H5页面动态渲染，通过传入H5地址方式，实现不同程序内容展示。</p>
<p><strong>特点：</strong></p>
<ul>
<li>实现简单，因为和编辑时使用的是同一环境，****可直接复用，不需要做单独适配。</li>
<li>能力有限，因为使用Webview进行渲染，所以应用所能使用的能力取决于Webview组件提供的开发能力，目前可以使用的能力可查看<a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html#%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3-2">Webview组件文档</a></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://pictures-1303450388.cos.ap-chengdu.myqcloud.com/1681960549630-bc7e7caa-c9e0-4e01-8a37-d1ca2cbe3336.jpeg" alt="" loading="lazy"></figure>
<h3 id="二-原生小程序方案生成小程序原生组件">二、原生小程序方案：生成小程序原生组件</h3>
<p>在web端进行应用设计完成后，将内容保存为和平台无关的通用语言数据，常用的为JSON Schema，不同平台需要实现各自的解析适配器，将内容解析为平台特有的代码，这里即为解析为微信小程序。</p>
<p><strong>特点：</strong></p>
<ul>
<li>实现复杂，两个平台差异性太大，需要实现多套解析器和组件。不过可以通过使用多端开发框架（<a href="https://uniapp.dcloud.net.cn/">uniapp</a>、<a href="https://taro.jd.com/">taro</a>）来降低差异性。</li>
<li>能力受限小，因为是生成原生组件，基本上可以使用所有原生组件能力。</li>
</ul>
<pre><code class="language-json">{
  &quot;label&quot;: &quot;新增组件&quot;,
  &quot;icon&quot;: &quot;icon-zujian&quot;,
  &quot;fields&quot;: {
    &quot;color_gi&quot;: {
      &quot;label&quot;: &quot;颜色选择器&quot;,
      &quot;type&quot;: &quot;color&quot;,
      &quot;value&quot;: &quot;&quot;
    },
    &quot;string_Ao&quot;: {
      &quot;label&quot;: &quot;输入框&quot;,
      &quot;type&quot;: &quot;string&quot;,
      &quot;value&quot;: &quot;&quot;,
      &quot;options&quot;: {
        &quot;placeholder&quot;: &quot;请输入&quot;
      }
    },
    &quot;upload_6t&quot;: {
      &quot;label&quot;: &quot;图片上传&quot;,
      &quot;type&quot;: &quot;upload&quot;,
      &quot;value&quot;: &quot;&quot;
    }
  }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/159460/1681990517560-e4737370-b90d-44d7-967c-c2a97eaf28f3.jpeg" alt="" loading="lazy"></figure>
<p><strong>参考实现方案：</strong></p>
<ul>
<li><a href="https://github.com/silence717/taro-designer">https://github.com/silence717/taro-designer</a></li>
<li><a href="https://github.com/ShaoGongBra/taro-design">https://github.com/ShaoGongBra/taro-design</a></li>
<li><a href="https://ext.dcloud.net.cn/plugin?id=6740">https://ext.dcloud.net.cn/plugin?id=6740</a></li>
<li><a href="https://pageplug.cn/">https://pageplug.cn/</a></li>
<li><a href="https://github.com/staringos/mtbird">https://github.com/staringos/mtbird</a></li>
</ul>
<h2 id="如何使用第三方平台代开发">如何使用第三方平台代开发</h2>
<p>第三方平台（简称第三方平台），由微信团队面向所有通过<a href="https://kf.qq.com/faq/170824URbmau170824r2uY7j.html">开发者资质认证</a>的第三方开发者提供提供的官方平台。在得到公众号或小程序管理员授权后，基于该平台，第三方服务商可以通过调用官方接口能力，为商家提供公众号代运营、小程序代注册、代开发等服务以及提供公众号和小程序相关的行业方案、活动营销、插件能力等全方位服务。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1682068941157-38b4cd76-d6aa-4eda-ba30-51a0dea43a8f.png" alt="" loading="lazy"><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1682069054303-f88e6aa1-3793-4cb1-95f1-6ef6cd04384a.png" alt="" loading="lazy"></p>
<h3 id="满足条件">满足条件</h3>
<figure data-type="image" tabindex="3"><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1682391253106-b4dc9cdf-a06f-47c3-afed-9cf54f2ddeab.png" alt="" loading="lazy"></figure>
<ul>
<li>提供行业解决方案，如针对电商行业的解决方案，或针对旅游行业的解决方案等；</li>
<li>行业：（横向）提供更加专业的运营能力，精细化运营用户公众号或小程序；</li>
<li>功能：（纵向）对公众平台功能的优化，如专门优化图文消息视觉样式和排版的工具，或专门定制的 CRM 用户管理功能，或功能强大的小程序插件等。</li>
</ul>
<h3 id="流程">流程</h3>
<figure data-type="image" tabindex="4"><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1681980164393-0fae9953-54d7-4808-a8f4-13e46c652cf9.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1682391612230-1750c702-0d9e-407e-88a8-2c13ea64c746.png" alt="" loading="lazy"></figure>
<h4 id="一-如何成为服务商">一、如何成为服务商</h4>
<p>1、第三方平台帐号的审核无需缴费，但开放平台帐号的认证（即开发者资质认证）需要交300块钱认证费。一个已完成开发者资质认证的开放平台帐号，可创建5个平台型服务商第三方平台帐号。</p>
<p>2、任何合法合规的、为小程序提供开发服务及有意愿的开发者都可以成为小程序服务商，微信不会区别对待，也无官方授权的概念。</p>
<figure data-type="image" tabindex="6"><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1681980517223-496c322a-ec16-473a-aee5-c0065909bbec.png" alt="" loading="lazy"></figure>
<p><a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/operation/thirdparty/prepare.html"><strong>准备材料：</strong></a></p>
<ul>
<li>官方网站：服务商应当有对外可用的官网，且该官网提供的服务描述与申请的第三方平台帐号名称、简介、图标均有所关联</li>
<li>平台图标：图标必须为当前服务商所有，不可使用其他企业的图标作为第三方平台帐号图标，108 x 108像素，大小不超过300KB，且格式为PNG的图片</li>
<li>域名和ssl证书</li>
</ul>
<h4 id="二-搭建三方后端服务自建模式和云服务">二、搭建三方后端服务：自建模式和云服务</h4>
<figure data-type="image" tabindex="7"><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1681984771382-05565715-fded-4766-883c-af3bb2dd0bcc.png" alt="" loading="lazy"></figure>
<ul>
<li>服务商类型</li>
</ul>
<p><strong>平台型第三方平台帐号</strong></p>
<ul>
<li>这是官方推荐选择的类型，该类型的服务商可基于第三方平台接口能力，在获取商家扫码授权后，为商家提供代开发、代运营公众号和小程序服务。</li>
<li>想要为商家实现批量化服务，例如批量运营公众号、批量代开发小程序等，则需要选择该类型的帐号。</li>
</ul>
<p><strong>定制化型第三方平台帐号</strong></p>
<ul>
<li>当你不需要以服务商身份使用第三方平台接口能力，只需生成票据用于标记商家小程序是由该服务商开发的，那么可以选择创建该类型的帐号。</li>
<li>该类型的帐号仅有一个APPID用以作为服务商帐号id，没有secret，无法生成token，不可调用官方任何接口能力。该类型的服务商通常不基于第三方平台能力为商家提供服务。</li>
</ul>
<p>搭建好三方服务后需要和业务系统服务进行联调对接，然后进行<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/operation/thirdparty/publish.html">全网发布</a>。</p>
<h4 id="三-授权">三、授权</h4>
<p>商家需要将其公众号或者小程序<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Authorization_Process_Technical_Description.html">授权</a>给第三方平台，服务商才可以代商家进行相关操作。</p>
<figure data-type="image" tabindex="8"><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1681980296972-49144b20-919e-4d26-bc1d-03817965cd19.png" alt="" loading="lazy"></figure>
<h4 id="四-代商家调用接口">四、代商家调用接口</h4>
<p>小程序的api，服务商都可以调用，只是服务商调用的时候要使用<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/ThirdParty/token/api_authorizer_token.html">authorizer_access_token</a>，而不是access_token。</p>
<p>服务商能否代商家成功调用某个公众号或者小程序的api，取决于该公众号或者小程序管理员是否将对应的权限集授权给当前第三方平台帐号。</p>
<h4 id="五-代开发小程序">五、代开发小程序</h4>
<figure data-type="image" tabindex="9"><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1681988187650-15d3e030-e517-4a41-9a7c-fc5073146d1c.png" alt="" loading="lazy"></figure>
<h5 id="代码上传">代码上传</h5>
<ul>
<li>通过开发者工具</li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/ci.html">CI代码上传</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/article/doc/0006aec26a89507900dc70f5e5b013?pass_ticket=PFmw0zP6yfVqUJz8iYlCaPgYBj0s6dm%2BoKU5cKthScDFPSrvwo9Z2cS1G9qCIrRyts29yPal4xRGPCSoPxxoeA%3D%3D">使用小程序CI自动上传代码</a></li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1681988652552-ed1314fb-a721-432a-b4e1-9146be97d1ea.png" alt="" loading="lazy"></figure>
<h3 id="相关文档">相关文档</h3>
<ul>
<li><a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/getting_started/terminology_introduce.html">官方文档</a></li>
<li><a href="https://developers.weixin.qq.com/doc/oplatform/openApi/OpenApiDoc/">API文档</a></li>
<li><a href="https://juejin.cn/post/6871397648792813575">微信开放平台之第三方平台开发，一整套流程</a></li>
</ul>
<h3 id="相关规则">相关规则</h3>
<ul>
<li><a href="https://developers.weixin.qq.com/doc/oplatform/service_market/provider_guideline/audit/mini_program_develop_audit.html">小程序代开发服务上架要求</a></li>
<li><a href="https://developers.weixin.qq.com/doc/oplatform/service_market/provider_guideline/operation/mini_program_develop_operation.html">小程序代开发运营规则</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Http请求中Content-Type]]></title>
        <id>https://www.bwrong.cn/post/yTzozCDtS/</id>
        <link href="https://www.bwrong.cn/post/yTzozCDtS/">
        </link>
        <updated>2022-10-10T02:38:40.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><strong>Content-Type</strong></li>
</ol>
<p>MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。</p>
<pre><code>1. 类型格式：type/subtype(;parameter)? type 
2. 主类型，任意的字符串，如text，如果是*号代表所有；  
3. subtype 子类型，任意的字符串，如html，如果是*号代表所有；  
4. parameter 可选，一些参数，如Accept请求头的q参数， Content-Type的 charset参数。  
</code></pre>
<p>例如： <code>Content-Type: text/html;charset:utf-8;</code></p>
<p>常见的媒体格式类型如下：</p>
<ul>
<li>text/html ： HTML格式</li>
<li>text/plain ：纯文本格式</li>
<li>text/xml ： XML格式</li>
<li>image/gif ：gif图片格式</li>
<li>image/jpeg ：jpg图片格式</li>
<li>image/png：png图片格式</li>
</ul>
<p>以application开头的媒体格式类型：</p>
<ul>
<li>application/xhtml+xml ：XHTML格式</li>
<li>application/xml   ： XML数据格式</li>
<li>application/atom+xml ：Atom XML聚合格式</li>
<li>application/json  ： JSON数据格式</li>
<li>application/pdf    ：pdf格式</li>
<li>application/msword ： Word文档格式</li>
<li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li>
<li>application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li>
</ul>
<p>另外一种常见的媒体格式是上传文件之时使用的：</p>
<ul>
<li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li>
</ul>
<p>以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。</p>
<ol start="2">
<li><strong>Spring MVC中关于关于Content-Type类型信息的使用</strong></li>
</ol>
<p>首先我们来看看RequestMapping中的Class定义：</p>
<pre><code class="language-java">@Target({ElementType.METHOD, ElementType.TYPE}) 
@Retention(RetentionPolicy.RUNTIME) 
@Documented 
@Mapping 
public @interface RequestMapping { 
	String[] value() default {};
	RequestMethod[] method() default {}; 
	String[] params() default {}; 
	String[] headers() default {};
	String[] consumes() default {};
	String[] produces() default {}; 
} 
</code></pre>
<p>value: 指定请求的实际地址， 比如 /action/info之类。<br>
method： 指定请求的method类型， GET、POST、PUT、DELETE等<br>
consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;<br>
produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回<br>
params： 指定request中必须包含某些参数值是，才让该方法处理<br>
headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求</p>
<p>其中，consumes， produces使用content-typ信息进行过滤信息；headers中可以使用content-type进行过滤和判断。</p>
<ol start="3">
<li><strong>使用示例</strong></li>
</ol>
<p>3.1 headers</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET, headers=&quot;Referer=http://www.ifeng.com/&quot;)  
public void testHeaders(@PathVariable String ownerId, @PathVariable String petId) {    
	// implementation omitted  
}  
</code></pre>
<p>这里的Headers里面可以匹配所有Header里面可以出现的信息，不局限在Referer信息。</p>
<p>示例2</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/response/ContentType&quot;, headers = &quot;Accept=application/json&quot;)    
public void response2(HttpServletResponse response) throws IOException {    
    //表示响应的内容区数据的媒体类型为json格式，且编码为utf-8(客户端应该以utf-8解码)    
    response.setContentType(&quot;application/json;charset=utf-8&quot;);    
    //写出响应体内容    
    String jsonData = &quot;{\&quot;username\&quot;:\&quot;zhang\&quot;, \&quot;password\&quot;:\&quot;123\&quot;}&quot;;    
    response.getWriter().write(jsonData);    
}    
</code></pre>
<p>服务器根据请求头“Accept=application/json”生产json数据。</p>
<p>当你有如下Accept头，将遵守如下规则进行应用：<br>
①Accept：<code>text/html,application/xml,application/json</code><br>
将按照如下顺序进行produces的匹配 ①text/html ②application/xml ③application/json<br>
②Accept：<code>application/xml;q=0.5,application/json;q=0.9,text/html</code><br>
将按照如下顺序进行produces的匹配 ①text/html ②application/json ③application/xml<br>
参数为媒体类型的质量因子，越大则优先权越高(从0到1)<br>
③Accept：<em><code>/*,text/*,text/html</code><br>
将按照如下顺序进行produces的匹配 ①text/html ②text/</em> ③*/*</p>
<p>即匹配规则为：最明确的优先匹配。</p>
<h2 id="requests部分">Requests部分</h2>
<table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>指定客户端能够接收的内容类型</td>
<td>Accept: text/plain, text/html</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可以接受的字符编码集。</td>
<td>Accept-Charset: iso-8859-5</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>
<td>Accept-Encoding: compress, gzip</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可接受的语言</td>
<td>Accept-Language: en,zh</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>可以请求网页实体的一个或者多个子范围字段</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Authorization</td>
<td>HTTP授权的授权证书</td>
<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>指定请求和响应遵循的缓存机制</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>
<td>Connection: close</td>
</tr>
<tr>
<td>Cookie</td>
<td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>
<td>Cookie: $Version=1; Skin=new;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求的内容长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求的与实体对应的MIME信息</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
</tr>
<tr>
<td>Date</td>
<td>请求发送的日期和时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>Expect</td>
<td>请求的特定的服务器行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>From</td>
<td>发出请求的用户的Email</td>
<td>From: user@email.com</td>
</tr>
<tr>
<td>Host</td>
<td>指定请求的服务器的域名和端口号</td>
<td>Host: www.zcmhi.com</td>
</tr>
<tr>
<td>If-Match</td>
<td>只有请求内容与实体相匹配才有效</td>
<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>
<td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>
<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>只在实体在指定时间之后未被修改才请求成功</td>
<td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制信息通过代理和网关传送的时间</td>
<td>Max-Forwards: 10</td>
</tr>
<tr>
<td>Pragma</td>
<td>用来包含实现特定的指令</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>连接到代理的授权证书</td>
<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Range</td>
<td>只请求实体的一部分，指定范围</td>
<td>Range: bytes=500-999</td>
</tr>
<tr>
<td>Referer</td>
<td>先前网页的地址，当前请求网页紧随其后,即来路</td>
<td>Referer: http://www.zcmhi.com/archives/71.html</td>
</tr>
<tr>
<td>TE</td>
<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>
<td>TE: trailers,deflate;q=0.5</td>
</tr>
<tr>
<td>Upgrade</td>
<td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
</tr>
<tr>
<td>User-Agent</td>
<td>User-Agent的内容包含发出请求的用户信息</td>
<td>User-Agent: Mozilla/5.0 (Linux; X11)</td>
</tr>
<tr>
<td>Via</td>
<td>通知中间网关或代理服务器地址，通信协议</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>关于消息实体的警告信息</td>
<td>Warn: 199 Miscellaneous warning</td>
</tr>
</tbody>
</table>
<h2 id="responses-部分">Responses 部分</h2>
<table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Age</td>
<td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
<td>Age: 12</td>
</tr>
<tr>
<td>Allow</td>
<td>对某网络资源的有效的请求行为，不允许则返回405</td>
<td>Allow: GET, HEAD</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>web服务器支持的返回内容压缩编码类型。</td>
<td>Content-Encoding: gzip</td>
</tr>
<tr>
<td>Content-Language</td>
<td>响应体的语言</td>
<td>Content-Language: en,zh</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应体的长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Location</td>
<td>请求资源可替代的备用的另一地址</td>
<td>Content-Location: /index.htm</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>返回资源的MD5校验值</td>
<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td>Content-Range</td>
<td>在整个返回体中本部分的字节位置</td>
<td>Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td>Content-Type</td>
<td>返回内容的MIME类型</td>
<td>Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td>Date</td>
<td>原始服务器消息发出的时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值</td>
<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>Expires</td>
<td>响应过期的日期和时间</td>
<td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
<td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
<tr>
<td>Location</td>
<td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>
<td>Location: http://www.zcmhi.com/archives/94.html</td>
</tr>
<tr>
<td>Pragma</td>
<td>包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>它指出认证方案和可应用到代理的该URL上的参数</td>
<td>Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td>refresh</td>
<td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td>Refresh: 5; url=http://www.zcmhi.com/archives/94.html</td>
</tr>
<tr>
<td>Retry-After</td>
<td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>
<td>Retry-After: 120</td>
</tr>
<tr>
<td>Server</td>
<td>web服务器软件名称</td>
<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置Http Cookie</td>
<td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>
</tr>
<tr>
<td>Trailer</td>
<td>指出头域在分块传输编码的尾部存在</td>
<td>Trailer: Max-Forwards</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>文件传输编码</td>
<td>Transfer-Encoding:chunked</td>
</tr>
<tr>
<td>Vary</td>
<td>告诉下游代理是使用缓存响应还是从原始服务器请求</td>
<td>Vary: *</td>
</tr>
<tr>
<td>Via</td>
<td>告知代理客户端响应是通过哪里发送的</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>警告实体可能存在的问题</td>
<td>Warning: 199 Miscellaneous warning</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>表明客户端请求实体应该使用的授权方案</td>
<td>WWW-Authenticate: Basic</td>
</tr>
</tbody>
</table>
<p>3.2 params的示例</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/test/{userId}&quot;, method = RequestMethod.GET, params=&quot;myParam=myValue&quot;)    
public void findUser(@PathVariable String userId) {        
  // implementation omitted    
} 
</code></pre>
<p>仅处理请求中包含了名为“myParam”，值为“myValue”的请求，起到了一个过滤的作用。</p>
<p>3.3 consumes/produces</p>
<pre><code class="language-java">@Controller    
@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST, consumes=&quot;application/json&quot;, produces=&quot;application/json&quot;)    
@ResponseBody  
public List&lt;User&gt; addUser(@RequestBody User userl) {        
    // implementation omitted    
    return List&lt;User&gt; users;  
} 
</code></pre>
<p>方法仅处理request Content-Type为“application/json”类型的请求. produces标识==&gt;处理request请求中Accept头中包含了&quot;application/json&quot;的请求，同时暗示了返回的内容类型为application/json;</p>
<ol start="4">
<li><strong>总结</strong></li>
</ol>
<p>在本文中，首先介绍了Content-Type主要支持的格式内容，然后基于@RequestMapping标注的内容介绍了主要的使用方法，其中,headers, consumes,produces,都是使用Content-Type中使用的各种媒体格式内容，可以基于这个格式内容来进行访问的控制和过滤。</p>
<p>参考资料：</p>
<ol>
<li>HTTP中支持的Content-Type: http://tool.oschina.net/commons</li>
<li>Media Type介绍。 http://www.iteye.com/topic/1127120</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP状态码详解]]></title>
        <id>https://www.bwrong.cn/post/_JBfHtjNy/</id>
        <link href="https://www.bwrong.cn/post/_JBfHtjNy/">
        </link>
        <updated>2022-10-10T02:35:54.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td>
</tr>
<tr>
<td>101</td>
<td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td>
</tr>
<tr>
<td>102</td>
<td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td>
</tr>
<tr>
<td>200</td>
<td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td>
</tr>
<tr>
<td>201</td>
<td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。</td>
</tr>
<tr>
<td>202</td>
<td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>
</tr>
<tr>
<td>203</td>
<td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td>
</tr>
<tr>
<td>204</td>
<td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>
</tr>
<tr>
<td>205</td>
<td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td>
</tr>
<tr>
<td>206</td>
<td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td>
</tr>
<tr>
<td>207</td>
<td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>
</tr>
<tr>
<td>300</td>
<td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td>
</tr>
<tr>
<td>301</td>
<td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td>
</tr>
<tr>
<td>302</td>
<td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td>
</tr>
<tr>
<td>303</td>
<td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td>
</tr>
<tr>
<td>304</td>
<td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td>
</tr>
<tr>
<td>305</td>
<td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td>
</tr>
<tr>
<td>306</td>
<td>在最新版的规范中，306状态码已经不再被使用。</td>
</tr>
<tr>
<td>307</td>
<td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td>
</tr>
<tr>
<td>400</td>
<td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。</td>
</tr>
<tr>
<td>401</td>
<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>
</tr>
<tr>
<td>402</td>
<td>该状态码是为了将来可能的需求而预留的。</td>
</tr>
<tr>
<td>403</td>
<td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>
</tr>
<tr>
<td>404</td>
<td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td>
</tr>
<tr>
<td>405</td>
<td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>
</tr>
<tr>
<td>406</td>
<td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>
</tr>
<tr>
<td>407</td>
<td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td>
</tr>
<tr>
<td>408</td>
<td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>
</tr>
<tr>
<td>409</td>
<td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>
</tr>
<tr>
<td>410</td>
<td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone'，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>
</tr>
<tr>
<td>411</td>
<td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>
</tr>
<tr>
<td>412</td>
<td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>
</tr>
<tr>
<td>413</td>
<td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>
</tr>
<tr>
<td>414</td>
<td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>
</tr>
<tr>
<td>415</td>
<td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>
</tr>
<tr>
<td>416</td>
<td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>
</tr>
<tr>
<td>417</td>
<td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>
</tr>
<tr>
<td>421</td>
<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td>422</td>
<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td>422</td>
<td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>424</td>
<td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>425</td>
<td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td>
</tr>
<tr>
<td>426</td>
<td>客户端应当切换到TLS/1.0。（RFC 2817）</td>
</tr>
<tr>
<td>449</td>
<td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>
</tr>
<tr>
<td>500</td>
<td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td>
</tr>
<tr>
<td>501</td>
<td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td>
</tr>
<tr>
<td>502</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td>
</tr>
<tr>
<td>503</td>
<td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td>
</tr>
<tr>
<td>504</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td>
</tr>
<tr>
<td>505</td>
<td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td>
</tr>
<tr>
<td>506</td>
<td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td>
</tr>
<tr>
<td>507</td>
<td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td>
</tr>
<tr>
<td>509</td>
<td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td>
</tr>
<tr>
<td>510</td>
<td>获取资源所需要的策略并没有没满足。（RFC 2774）</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】webgl技术风云录之BabylonJS]]></title>
        <id>https://www.bwrong.cn/post/Qek0Azf5d/</id>
        <link href="https://www.bwrong.cn/post/Qek0Azf5d/">
        </link>
        <updated>2022-05-28T05:21:04.000Z</updated>
        <content type="html"><![CDATA[<p>微软除了在BabylonJS上面布局，同时还投资blender，对未来3D技术布局非常明显。BabylonJS是世界上最强大、最惊艳、最易用的Web3D渲染引擎，并且我们坚持让它完全开源和免费，无论对任何人都如此。Babylon.js 4.1版本的体积小了3倍，速度提升了12%，并且进行了无数的性能优化，在它诞生的那一刻就定位于高性能3D引擎，即使功能越来越强大也会继续贯彻这个理念不动摇。新的Node Material Editor编辑器、真正跨平台的babylon原生应用部署体验、层叠阴影、导航寻路、更强的WebXR虚拟现实及增强现实支持、更完美的glTF格式支持等新功能，让Babylon.js 4.1成为了你不可或缺的web应用开发利器。</p>
<p>Babylonjs不光有微软强大的资金支持，同时它代码功能结构很多参考blender技术体系，如果你同时看了blender代码跟Babylonjs代码，你会发现很多地方都有共同点。</p>
<p>官网：</p>
<p><a href="%E2%80%8Bwww.babylonjs.com/">Babylon.js: Powerful, Beautiful, Simple, Open - Web-Based 3D At Its Best</a></p>
<p>它主要特性有以下几个方面：</p>
<p>1、强大的编辑器，这是threejs跟playcanvas无法比拟的。</p>
<figure data-type="image" tabindex="1"><img src="https://pic3.zhimg.com/v2-a0d46325eecfb57ab21e6fdf02f13872_r.jpg" alt="" loading="lazy"></figure>
<p>编辑器中，对粒子、碰撞、脚本、GUI、精灵图等等各方面功能集成得非常完善，作为一个多年使用微软IDE从事开发的码农，个人一直认为微软的东西很人性化。</p>
<p>2、强大的节点编辑器。在blender里面节点编辑器无处不在，它也是通过connect不同节点的input跟output来实现节点之间的数据联通，这样就把复杂的材质系统变成可视化了。</p>
<p>Node Material Editor是一个强大而易用的材质编辑器，它以可视化的拖拽节点的方式来模拟shader编程，从而为每个从业者解锁了GPU的强大威力。从前，shaders (GPU 编程)着色器编程对于普通程序员门槛很高，因为它过于偏向底层，虽然功能强大，但是晦涩难懂，而Babylon带来的Node Material Editor可以实现与shader同样的效果，但是界面化操作，把难度降到了最低。我们相信，每个人都能使用这个编辑器来创建令人惊叹的视觉效果。</p>
<p><img src="https://pic3.zhimg.com/80/v2-090d22ae6e18cac1fc1d18999ce5ea82_1440w.jpg" alt="" loading="lazy"><br>
材质节点</p>
<p><img src="https://pic2.zhimg.com/80/v2-e68990b0dee4ffd3b9bf0fe017d6828d_1440w.jpg" alt="" loading="lazy"><br>
Babylonjs材质节点</p>
<p>3、NATIVE 跨平台原生应用部署。程序员们写代码都有一个梦想：一次编写实现，多平台共享运行。 所以我们重磅推出了Babylon Native，它可以用原有的Babylon.js代码在任意平台构建一个原生应用，充分释放本机设备的性能优势。 已经支持DirectX on Windows、 Metal on iOS/MacOS、 OpenGL on Android，即将推出Vulkan支持。</p>
<p>Babylonjs的原生打包部署是通过react native技术体系来实现的，这样就可以实现一份代码原生部署，同时保证原生性能。</p>
<p>4、支持先进的WEBXR技术。毫无疑问，在web使用AR/VR技术非常有前景，Babylon最新4.1版本在WebXR上做了进一步的优化和改进：带来了一个简单易用的体检帮助器，针对更高级用户的专用会话管理器，用babylon的相机功能来承载WebXR技术，全面支持任何接受WebXR会话的设备，完整的WebXR输入源支持，关于实验性AR功能、通信、场景交互、物理效果的整套API支持等。</p>
<p><img src="https://pic4.zhimg.com/80/v2-113fe316a7f0ac47282d629cae4c3963_1440w.jpg" alt="" loading="lazy"><br>
webxr支持<br>
总结：</p>
<p>1、如果你要交付内部项目、而且可以是客户端、有U3D开发人员，那么用U3D去交付实现最好，通过安装exe客户端，灯光效果交互、vr支持都是非常完美，而且U3D的开发者论坛、文档、百度教程都非常丰富。</p>
<p>2、如果你项目必须是webgl的，需要浏览器打开，webgl技术风云录中提到的那些平台都无法满足你的需求，建议你用Babylonjs，这是最好的平台，最好的框架。</p>
<p><a href="%E2%80%8Bwww.zhihu.com/column/c_1327931812140441600">webGL技术风云录专栏</a></p>
<p>3、如果您是webgl开发者，你目前毫无头绪，请使用threejs，它是万金油</p>
<p>4、如果您是webgl方面创业公司，正在进行技术选型，请您选择BabylonJS，你要研发自己的模型展示交付平台或者是要研发自己的场景漫游系统，通过BabylonJS引擎、以及他的inspect和编辑器，你可以快速拿出自己的产品，而且产品质量还不低。最后你要做的是业务逻辑开发以及界面美化定制。</p>
<p>目前市面上很多模型展示交付平台，其实它内核部分都没少技术含量，大量是包装过度，如果您用BabylonJS可以快速组装搬运集成，别人一个团队10多个人几年时间，你可以在短短几个开发人员几个月之内追赶上，还可以超越。</p>
<p>下面这家公司使用的就是BabylonJS制作的云展，案例效果不错。</p>
<p><a href="%E2%80%8Bwww.cool360.com/">虚拟博物馆(cool360.com)-官网</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/341360474">查看原文</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】webgl技术风云录之盈利模式]]></title>
        <id>https://www.bwrong.cn/post/gVqLNr-2_/</id>
        <link href="https://www.bwrong.cn/post/gVqLNr-2_/">
        </link>
        <updated>2022-05-28T05:19:13.000Z</updated>
        <content type="html"><![CDATA[<p>作为从事webgl开发的工程师，不得不思考行业的趋势以及同行企业的盈利模式。如果从事游戏开发，不属于此范畴，作者不对游戏行业不够熟悉。目前接触到的webgl很多都是从事展示，更多卖的不是技术本身而是设计，其实就是模型、靠的是三维设计师的能力、赚得是三维设计师的血汗。</p>
<p>当然有些公司依然是靠webgl技术本身赚钱，而不是通过销售设计数据，目前无外乎如下几方面：</p>
<h2 id="1-传统设计展览公司">1、传统设计展览公司</h2>
<p>其实很多设计展厅公司都已经上市，他们有固定客户资源、三维设计师对行业专业程度非常高，所以他们通过线下展厅设计施工、加上U3D开发的一些数字互动功能，就可以快速交付项目。对他们来说，webgl意义不大，U3D已经足够，而且是非常好的技术方案，性能好、效果好、VR支持高，因为都是本地部署不要求跨终端浏览器访问。这些公司盈利点也是靠设计、施工、材料来实现利润增长。</p>
<h2 id="2-720云">2、720云</h2>
<p>720云其实满足了很多设计师全景图的快速交付，720云本身不参与数据制作，纯靠技术平台以及全景拍摄硬件来盈利。他能盈利是因为平台本身确实解决了用户痛点，而航拍、户外大场景全景拍摄、全景效果图交付这些需要一个全景展示平台来展示作品，720云经过这些年的沉淀推广，把这一个环节做得非常完善简便，所以它有存在的价值。</p>
<h2 id="3-酷家乐">3、酷家乐</h2>
<p>酷家乐鼎鼎大名、80亿美金估值，短短几年时间不得不佩服，通过研究它前端代码结构、试用其产品、它的渲染速度、渲染效果都是令人非常满意。它重新定义了室内装修，让繁琐复杂、交付周期长的效果图制作大大缩短，同时降低设计师技术要求，通过模型库、户型图、渲染平台让整个流程一气呵成。webgl技术在它平台算重要的一环，其背后的渲染平台、以及后台架构更加重要，一整套技术成就了这个设计界的霸主。</p>
<h2 id="4-style3d">4、style3d</h2>
<p>如果你看见style3d的渲染视频，你会对他柔体建模以及展示佩服不已。三维中刚体最简单、柔体、流体、毛发是非常复杂的几大块，而style3d通过多年垂直领域的沉淀积累、技术打磨，让他成为了服装设计界的明星。它盈利天经地义。</p>
<h2 id="5-宝珑">5、宝珑</h2>
<p>宝珑珠宝设计，早期用的是flash，而且可以直接decomp其代码，在flash技术体系内，通过shader进行珠宝设计以及展示技术很厉害了。现在他们迎合技术发展趋势，因为flash在很多平台浏览器上支持都慢慢停止，所以他们珠宝设计、展示、定制都迁移到webgl上面，通过threejs进行深度定制来实现。珠宝设计领域，可以去试试他们产品，我有两个珠宝行业朋友，用得就是他们的技术。</p>
<h2 id="6-matterport-众趣-贝壳">6、matterport &amp; 众趣 &amp;贝壳</h2>
<p>贝壳看房，世界杯轰炸一轮，连我退休的爸妈都知道贝壳看房，而这项技术的引领者应该就是matterport。其实在09年就有人做网上看房，那时候是基于flex，通过全景图或者简单的户型模型来实现，效果太差。matterport把整个体验重新定义，通过硬件线下采集照片以及深度数据，云端进行ai合成户型模型，然后展示端把全景图当纹理贴到户型模型上，让整个体验更加饱满、制作更加简单，而且是照片级1:1还原线下场景。这在看房领域真是福音，因为看房通过纯全景图krpano那种模式效果还是太差，不够身临其境，而matterport这在技术方案彻底解决了这一问题。</p>
<h2 id="7-淘宝">7、淘宝</h2>
<p>阿里在短视频跟直播方面应该没有跟上脚步、直播带货也是后期才追赶，但是三维他肯定不会错过。通过投资躺平设计家、研发ace-tiny、以及今年的几场云展、场景购，已经开始布局整个三维行业，三维对未来购物肯定是非常有意义的，很多商品需要三维才能更加完美展示细节，有些商品通过场景可以提升用户购物欲望。</p>
<p>总之：</p>
<p>可以发现不论什么技术，它必须跟场景结合，必须跟行业结合，必须落地业务逻辑，真正解决特点场景下的某些问题它才有意义。以前大数据，多少投资人血本无归，几千万或者上亿最后只剩下一个没什么人用的看板。如今webgl一样会有很多投资人血本无归，因为光技术本身很难赚钱，除非优化某个行业数据生产方式或者深耕某个行业、跟行业内老玩家联姻，深耕技术沉淀团队方能杀出一条血路。</p>
<p>今年疫情，导致无数个云展公司成立，通过百度推广以及阿里域名查询，就可以发现一大堆公司开始从事这一行业，很多是皮包公司，接单就转包。有些是通过720云直接交付全景图，象征性加入云展厅，因为成本最低。还有很多是传统设计公司，转型卖设计。其实在云展这个行业，卖得不是技术而是设计数据本身。</p>
<p>蝉三维，立足于免费、提供快速模型交付，高效率精简团队可以通过部分软件功能定制、平台定制养活自己，更重要的是技术的不断积累、行业解决方案日益沉淀，最后真正解决特定用户群体切身问题，盈利模式就可以非常清晰。</p>
<p><a href="https://zhuanlan.zhihu.com/p/341414739">查看原文</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【玩转微前端】qiankun扩展]]></title>
        <id>https://www.bwrong.cn/post/kBhnkEIQF/</id>
        <link href="https://www.bwrong.cn/post/kBhnkEIQF/">
        </link>
        <updated>2022-04-07T13:46:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="详细流程">详细流程</h2>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331175532.awebp" alt="image.png" loading="lazy"></figure>
<p>简易流程：</p>
<ol>
<li>qiankun 会用 原生fetch方法，请求微应用的 entry 获取微应用资源，然后通过 response.text 把获取内容转为字符串。</li>
<li>将 HTML 字符串传入 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkuitos%2Fimport-html-entry%2Fblob%2F76df4b3737d54112f6bf2dfabcd01709079468e4%2Fsrc%2Fprocess-tpl.js%23L58">processTpl</a> 函数，进行 HTML 模板解析，通过正则匹配 HTML 中对应的 javaScript（内联、外联）、css（内联、外联）、代码注释、entry、ignore 收集并替换，去除 <code>html/head/body</code> 等标签，其他资源保持原样</li>
<li>将收集的 <code>styles</code> 外链URL对象通过 fetch 获取 css，并将 css 内容以 <code>&lt;style&gt;</code> 的方式替换到原来 link标签的位置</li>
<li>收集 script 外链对象，对于异步执行的 JavaScript 资源会打上 <code>async</code> 标识 ，会使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkuitos%2Fimport-html-entry%2Fblob%2F76df4b3737d54112f6bf2dfabcd01709079468e4%2Fsrc%2Findex.js%23L104">requestIdleCallback</a> 方法延迟执行。</li>
<li>接下来会创建一个匿名自执行函数包裹住获取到的 js 字符串，最后通过 eval 去创建一个执行上下文执行 js 代码，通过传入 proxy 改变 window 指向，完成 JavaScript 沙箱隔离。<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkuitos%2Fimport-html-entry%2Fblob%2F76df4b3737d54112f6bf2dfabcd01709079468e4%2Fsrc%2Findex.js%23L45">源码位置</a>。</li>
<li>由于 qiankun 是自执行函数执行微应用的 JavaScript，因此在加载后的微应用中是看不到 JavaScript 资源引用的，只有一个资源被执行替换的标识。</li>
<li>当一切准备就绪的时候，执行微应用的 JavaScript 代码，渲染出微应用</li>
</ol>
<h2 id="极限应用场景">极限应用场景</h2>
<ul>
<li>
<p>与路由绑定的方式渲染微应用</p>
<p>接入这类平台的微应用，通常只需要提供自己的 entry html 地址，并为其分配一个路由规则即可，会根据当前路由自动切换微应用加载。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331164434.jpg" alt="v2-c345f8bf9c8855176037f6b48e315caf_1440w" loading="lazy"></figure>
</li>
<li>
<p>以组件的方式使用微应用</p>
<p><video controls height='100%' width='100%' src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331164434.mp4"></video></p>
<p>开发者可以在脱离路由的限制下，以更自由的方式去渲染我们的微应用。</p>
<ul>
<li>嵌套渲染场景</li>
</ul>
<p><video controls height='100%' width='100%' src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331164435.mp4"></video></p>
</li>
<li>
<p>多应用同时渲染：同一时刻可展示多个子应用，子应用更像是一个业务组件而不是应用。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331164435.jpg" alt="v2-cc82a2a5a6fbe5c141af9dd5b42622ee_1440w" loading="lazy"></figure>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【玩转微前端】需要关注的问题]]></title>
        <id>https://www.bwrong.cn/post/clIOqn6ce/</id>
        <link href="https://www.bwrong.cn/post/clIOqn6ce/">
        </link>
        <updated>2022-04-07T13:46:01.000Z</updated>
        <content type="html"><![CDATA[<p>虽然qiankun已经提供了微前端的一些基本能力，但是在使用过程中还是有很多问题需要关注。</p>
<h2 id="项目架构规划">项目架构规划</h2>
<ul>
<li>Monorepo：多应用管理可以使用<a href="https://lerna.js.org/">lerna</a>或者<a href="https://pnpm.io/zh/">pnpm</a>。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406225207.png" alt="image-20220406225206585" loading="lazy"></figure>
<ul>
<li>
<p>Git subtree或者多仓库：在子应用较多的情况可采用此方式，缺点是每次子应用变更后，聚合库还得同步一次变更。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220407165035.jpg" alt="18091274-44952db2fd681a3d" loading="lazy"></figure>
</li>
</ul>
<h2 id="应用拆分粒度">应用拆分粒度</h2>
<p>微应用的拆与合思考：拆的是系统复杂度，合的是系统复用度。</p>
<p>拆分的时候可以从平台差异、页面结构、产品业务方面考虑。并不是越细越好，业务关联紧密的功能单元应该做成一个微应用，反之关联不紧密的可以考虑拆分成多个微应用。</p>
<h2 id="样式隔离">样式隔离</h2>
<p>使用qiankun默认的沙箱，仅能确保单实例场景子应用之间的样式隔离，但是无法确保主应用跟子应用、或者多实例场景的子应用样式隔离。目前还没有完美的解决方案，如果遇到样式污染问题，可以考虑如下方案：</p>
<ul>
<li>命名规范+命名空间，可以尝试开启experimentalStyleIsolation（实验阶段）。</li>
<li>ShadowDom：可以开启strictStyleIsolation严格模式，启用ShadowDom，但是这并不是一个可以无脑使用的方案，可能还会有一些其他问题，如子应用的弹窗挂载到body上时样式丢失。</li>
<li>CSS In JS</li>
<li>CSSModule</li>
</ul>
<h2 id="数据通信">数据通信</h2>
<p>应用间尽量避免通信，减少耦合性，如果两个应用间有频繁的通信需求，说明这两个微应用本身就是服务于同一个业务场景，合并成一个微应用可能会更合适。</p>
<p><strong>微前端通信方式：</strong></p>
<ul>
<li><strong>基于 URL</strong>：使用简单、通用性强，但能力较弱，不适用复杂的业务场景。</li>
<li><strong>基于 Props</strong>：最核心的通信能力，能够满足一些简单的场景。适用于主子应用共享组件、公共方法调用等。</li>
<li><strong>GlobalState</strong>：基于发布订阅模式实现，能够满足比较复杂的场景。</li>
<li><strong>本地Storage</strong>：仅适合静态通信场景，且 JSON.stringify()可能会造成数据丢失。</li>
</ul>
<h2 id="权限处理">权限处理</h2>
<p>主应用负责身份验证，拿到授权信息后下发到各微应用中，各应用再根据拿到的授权信息过滤各自路由信息。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331175530.awebp" alt="img" loading="lazy"></figure>
<h2 id="资源共享">资源共享</h2>
<h3 id="统一管理维护">统一管理维护</h3>
<p>将公共资源提取到一个地方，避免多个地方维护，但是仍然会多次打包。可以通过如下两种方式：</p>
<ul>
<li>file或link方式</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220407114412.png" alt="image-20220406235834667" loading="lazy"></figure>
<ul>
<li>git仓库或者私服</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406235948.png" alt="image-20220406235948554" loading="lazy"></figure>
<h3 id="依赖提取">依赖提取</h3>
<p>在一个团队中，技术栈相对固定，所以统一技术栈很多基础依赖相对是固定的，但是默认情况下每个应用都会重复打包一次，会造成重复下载，影响运行性能。例如，如果每个微应用都包括自己的 Vue 副本，那么用户就得多次下载 Vue。</p>
<p>在进行如下改造之前，先确认是否有此必要，因为它会增加应用间的耦合性（如技术栈、依赖版本必须一致） ，而这是和微前端思想相悖的，</p>
<ul>
<li>cdn或者将公共依赖抽离成单独的应用或者文件引用。</li>
<li>由主应用下发（props或者window），需要处理子应用单独运行时依赖的来源问题。</li>
</ul>
<h2 id="部署与资源路径问题">部署与资源路径问题</h2>
<h3 id="部署方案">部署方案</h3>
<ul>
<li>主应用和微应用部署到同一个服务器（同一个 IP 和端口）。</li>
</ul>
<pre><code>└── html/                     # 根文件夹
    ├── child/                # 存放所有微应用的文件夹
    |   ├── app1/         
    |   ├── app2/      
    ├── index.html            # 主应用的index.html
    ├── css/                  # 主应用的css文件夹
    ├── js/                   # 主应用的js文件夹
</code></pre>
<pre><code class="language-js">registerMicroApps([
  {
    name: 'app1',
    entry: '/child/app1/', // http://localhost:8080/child/app1/
    container: '#container',
    activeRule: '/child-app1',
  },
  {
    name: 'app2',
    entry: '/child/app2/', // http://localhost:8080/child/app2/
    container: '#container',
    activeRule: '/child-app2',
  }
],
</code></pre>
<ul>
<li>主应用和微应用部署在不同的服务器，使用 Nginx 代理访问。</li>
</ul>
<pre><code class="language-nginx">/app1/ {
  proxy_pass http://www.b.com/app1/;
  proxy_set_header Host $host:$server_port;
}
</code></pre>
<pre><code class="language-js">registerMicroApps([
  {
    name: 'app1',
    entry: '/app1/', // http://localhost:8080/app1/
    container: '#container',
    activeRule: '/child-app1',
  },
],
</code></pre>
<h3 id="资源路径错误">资源路径错误</h3>
<p>在src代码中引用public资源会有问题，资源尽量放到src中，让webpack处理，注入publicPath。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;img src=&quot;../../assets/images/logo.png&quot; alt=&quot;&quot;&gt;
  &lt;div class=&quot;img-test&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;img-test2 test&quot; :style=&quot;`background:url(${require('../../assets/images/logo.png')})`&quot;&gt;&lt;/div&gt;
	&lt;!-- 路径错误 --&gt;
  &lt;img src=&quot;/logo.png&quot; class=&quot;test&quot; alt=&quot;&quot;&gt;
&lt;/template&gt;
&lt;style scoped&gt;
  .img-test{
    background: url('../../assets/images/logo.png') no-repeat;
    background-size: 100% 100%;
    width: 100px;
    height: 100px;
  }
&lt;/style&gt;
</code></pre>
<h2 id="应用之间跳转">应用之间跳转</h2>
<p>在微应用中如果要进行应用间跳转，不能直接使用微应用的router，可以有如下几种方式：</p>
<ul>
<li>将跳转动作上抛给主应用，由主应用进行切换。</li>
<li>将主应用router下发到微应用，微应用使用该router进行跳转动作。</li>
<li>使用原生方法改变url（不建议，会造成页面刷新）。</li>
</ul>
<h2 id="其他问题">其他问题</h2>
<ul>
<li>VueDevtools调试微应用问题，需要手动处理，但是还是会存在失效问题。</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220407171516.png" alt="image-20220407171516398" loading="lazy"></figure>
<ul>
<li>对vite构建的微应用支持还有缺陷，因为Vite暂时还不支持运行时修改资源路径和ESModule导致沙箱失效。</li>
<li>各应用间的风格和交互逻辑应该统一，因为对用户来说我们的应用仍然是一体的，要避免应用间给用户造成撕裂感。</li>
<li>运行差异性处理：如果微应用需要单独运行，需要考虑集成运行和单独运行的差异性，做一些hack兼容处理。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【玩转微前端】聊聊qiankun]]></title>
        <id>https://www.bwrong.cn/post/yGI8PazIX/</id>
        <link href="https://www.bwrong.cn/post/yGI8PazIX/">
        </link>
        <updated>2022-04-07T13:45:01.000Z</updated>
        <content type="html"><![CDATA[<p>关于如何使用qiankun，官方文档比较完善，网上文档也较多，所以这里就不再赘述。接下来我们就来看一下目前文档中缺失的部分<a href="https://qiankun.umijs.org/zh/guide#%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">它是如何工作的</a>。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331175520.awebp" alt="image.png" loading="lazy"></figure>
<h2 id="运行流程">运行流程</h2>
<figure data-type="image" tabindex="2"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714da36c103427a~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="qiankun" loading="lazy"></figure>
<h2 id="核心api">核心API</h2>
<p><code>registerMicroApps</code>和<code>start</code>是qiankun两个核心的API。</p>
<p><code>registerMicroApps</code> 函数的作用是注册子应用，并且在子应用激活时，创建运行沙箱，在不同阶段调用不同的生命周期钩子函数。<code>start</code> 函数负责初始化一些全局设置，然后启动应用。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406165052.awebp" alt="qiankun" loading="lazy"></figure>
<h2 id="沙箱">沙箱</h2>
<p>qiankun的沙箱环境可以分为三类，主要通过运行环境是否支持Proxy和是否是单实例进行区分。</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406165518.awebp" alt="qiankun" loading="lazy"></figure>
<h3 id="legacysandbox">LegacySandbox</h3>
<p>LegacySandbox用于支持Proxy的单实例环境下，沙箱隔离是通过快照模式实现，在激活沙箱时还原子应用状态，卸载时还原主应用状态（子应用挂载前的全局状态）实现的。</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406170227.awebp" alt="qiankun" loading="lazy"></figure>
<ul>
<li>当调用 <code>set</code> 向子应用 <code>proxy/window</code> 对象设置属性时，所有的属性设置和更新都会先记录在 <code>addedPropsMapInSandbox</code> 或 <code>modifiedPropsOriginalValueMapInSandbox</code> 中，然后统一记录到 <code>currentUpdatedPropsValueMap</code> 中。</li>
<li>在激活沙箱时，沙箱会通过 <code>currentUpdatedPropsValueMap</code> 查询到子应用的独立状态池（沙箱可能会激活多次，这里是沙箱曾经激活期间被修改的全局变量），然后还原子应用状态。</li>
<li>在关闭沙箱时，通过 <code>addedPropsMapInSandbox</code> 删除在沙箱运行期间新增的全局变量，通过 <code>modifiedPropsOriginalValueMapInSandbox</code> 还原沙箱运行期间被修改的全局变量，从而还原到子应用挂载前的状态。</li>
</ul>
<p>该方案使用diff算法还原window状态快照，因为使用的是同一个window，所以不能在多实例时使用，而且父子应用之间window对象还是会存在污染。</p>
<h3 id="proxysandbox">ProxySandbox</h3>
<p>ProxySandbox用于支持Proxy的多实例环境下，它利用Proxy实现对微应用全局对象操作的拦截，子应用对全局属性的操作就是对该 <code>proxy</code> 对象属性的操作。</p>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406170830.awebp" alt="qiankun" loading="lazy"></figure>
<ul>
<li>当调用 <code>set</code> 向子应用 <code>proxy/window</code> 对象设置属性时，所有的属性设置和更新都会命中 <code>updateValueMap</code>，存储在 <code>updateValueMap</code> 集合中，从而避免对 <code>window</code> 对象产生影响。</li>
<li>当调用 <code>get</code> 从子应用 <code>proxy/window</code> 对象取值时，会优先从子应用的沙箱状态池 <code>updateValueMap</code> 中取值，如果没有命中才从主应用的 <code>window</code> 对象中取值。</li>
</ul>
<p><code>ProxySandbox</code> 是最完备的沙箱模式，完全隔离了对 <code>window</code> 对象的操作，在浏览器对Proxy兼容性兼容的情况下，算是最优的方案。</p>
<h3 id="snapshotsandbox">SnapshotSandbox</h3>
<p>在浏览器不支持Proxy时，会回退到SnapshotSandbox沙箱，作为兜底方案。</p>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406172205.awebp" alt="qiankun" loading="lazy"></figure>
<ul>
<li>在沙箱激活时，会先给当前 <code>window</code> 对象打一个快照，记录沙箱激活前的状态。打完快照后，函数内部将 <code>window</code> 状态通过 <code>modifyPropsMap</code> 记录还原到上次的沙箱运行环境，也就是还原沙箱激活期间（历史记录）修改过的 <code>window</code> 属性。</li>
<li>在沙箱关闭时，调用 <code>inactive</code> 函数，在沙箱关闭前通过遍历比较每一个属性，将被改变的 <code>window</code> 对象属性值记录在 <code>modifyPropsMap</code> 集合中。在记录了 <code>modifyPropsMap</code> 后，将 <code>window</code> 对象通过快照 <code>windowSnapshot</code> 还原到被沙箱激活前的状态，相当于是将子应用运行期间对 <code>window</code> 造成的污染全部清除。</li>
</ul>
<p>作为兜底方案，相比较 <code>ProxySandbox</code> 而言，在子应用激活期间，<code>SnapshotSandbox</code> 将会对 <code>window</code> 对象造成污染。</p>
<p>以上就是qiankun一些比较关键的东西，接下来就分享一下在使用的过程中需要关注的一些问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【玩转微前端】如何做技术选型]]></title>
        <id>https://www.bwrong.cn/post/O1Y6c55zn/</id>
        <link href="https://www.bwrong.cn/post/O1Y6c55zn/">
        </link>
        <updated>2022-04-07T13:44:07.000Z</updated>
        <content type="html"><![CDATA[<p>当前市面上已出现了很多微前端方案，如何做出正确的选择是一件不容易的事情。</p>
<p>在开始介绍这些方案之前，我们有必要先了解一下微前端架构的核心原则，从而更好的去衡量微前端方案是否成熟。</p>
<h2 id="核心原则">核心原则</h2>
<h3 id="应用独立">应用独立</h3>
<p>这里说的独立包含三个方面：</p>
<ul>
<li>独立开发：每个微应用由不同业务团队开发，实现团队自治。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331172854.png" alt="image-20220331172853831" loading="lazy"></figure>
<ul>
<li>独立部署：微应用可独立部署运行，每个应用可以有自己的交付部署流程，某个微应用出现故障不影响其他应用。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331173032.png" alt="image-20220331173031824" loading="lazy"></figure>
<ul>
<li>独立运行：既可以组合运行，也可以单独运行，运行时环境隔离，提供JavaScript沙箱，CSS 样式隔离，避免应用间运行时污染。</li>
</ul>
<h3 id="消息通信">消息通信</h3>
<p>完善的通信机制，可以降低主应用和微应用、微应用和微应用之间的数据共享难度，是否有完善的通信机制是选型考量的一个关键因素。</p>
<h3 id="技术栈无关">技术栈无关</h3>
<p>主应用不限制子应用接入的技术栈。不限制技术栈有如下好处：</p>
<ul>
<li>每个应用可以结合团队情况选择不同的技术栈，也可以集成一些采用了不同技术栈的老旧项目。</li>
<li>应用技术栈切换升级不影响其他应用，可以实现增量升级。通常我们很难对一个已有的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略。</li>
</ul>
<h3 id="依赖复用">依赖复用</h3>
<p>解决各应用间依赖、公共逻辑需要重复维护的问题。应用间相同的依赖需要重复下载。</p>
<h2 id="方案对比">方案对比</h2>
<p>接下来，我们从四大流派来看一下当下有哪些方案可以选择，并简单做个对比：</p>
<h3 id="传统式">传统式</h3>
<h4 id="1-路由分发服务端">1. 路由分发（服务端）</h4>
<p><strong>描述：</strong> 在HTTP服务器通过反向代理将不同的路由分发到对应的应用上。</p>
<pre><code class="language-nginx">http {
  server {
    listen       80;
    server_name  www.phodal.com;
    location /api/ {
      proxy_pass http://http://172.31.25.15:8000/api;
    }
    location /web/admin {
      proxy_pass http://172.31.25.29/web/admin;
    }
    location /web/notifications {
      proxy_pass http://172.31.25.27/web/notifications;
    }
    location / {
      proxy_pass /;
    }
  }
}
</code></pre>
<p><strong>优点：</strong> 简单、快速、易配置。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>应用是完全分开的，通信和数据资源共享很困难；</li>
<li>切换应用需要刷新页面，体验不好；</li>
<li>完全是基于路由的，无法同时加载多个应用。</li>
</ul>
<h4 id="2-iframe">2. IFrame</h4>
<p><strong>描述：</strong> 将微应用通过iframe载入。</p>
<p>**优点：**接入简单，兼容性好，原生支持沙箱隔离。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>隔离性无法突破，应用间上下文无法共享，比如在子应用弹窗问题（只能基于子应用可视区定位，不能基于整个页面定位）。</li>
<li>应用间通信需要自行实现一套基于postMessage的通信机制。</li>
<li>刷新会导致iframe Url状态丢失，iframe 和主页面共用一个浏览历史，后退前进按钮无法使用。</li>
</ul>
<h3 id="自组织式">自组织式</h3>
<h4 id="3-npm集成">3. Npm集成</h4>
<p><strong>描述：</strong> 将微应用抽离成包的方式，发布到Npm中，再在主应用中将这些微应用作为依赖项，构建时候集成进项目中。</p>
<p><strong>优点：</strong> 开发与接入成本低，容易理解。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>影响主应用编译速度和打包后的体积。</li>
<li>不支持动态更新，npm包更新后，需要重新更新包，主应用需要重新发布部署。</li>
<li>因为业务应用不能发布到公开库，需要自己搭建npm私有库，提高了工程难度。</li>
</ul>
<h4 id="4-js集成">4. JS集成</h4>
<p>**描述：**每个微应用提供一个入口js，会导出一个全局变量，主应用引入该js，安装应用时调用相关函数，挂载渲染微应用。</p>
<p>**优点：**相比Npm集成方案，优化的地方是微应用不用构建到主应用中，而是独立构建的。</p>
<p><strong>缺点：</strong> 规范、通信、沙箱都需要自己实现，依赖开发人员设计能力。</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Feed me!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome to Feed me!&lt;/h1&gt;

    &lt;!-- 这些脚本不会马上渲染应用 --&gt;
    &lt;!-- 而是分别暴露全局变量 --&gt;
    &lt;script src=&quot;https://browse.example.com/bundle.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://order.example.com/bundle.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://profile.example.com/bundle.js&quot;&gt;&lt;/script&gt;

    &lt;div id=&quot;micro-frontend-root&quot;&gt;&lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
      // 这些全局函数是上面脚本暴露的
      const microFrontendsByRoute = {
        '/': window.renderBrowseRestaurants,
        '/order-food': window.renderOrderFood,
        '/user-profile': window.renderUserProfile,
      };
      const renderFunction = microFrontendsByRoute[window.location.pathname];

      // 渲染第一个微应用
      renderFunction('micro-frontend-root');
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="微件式">微件式</h3>
<h4 id="5-web-component">5. Web Component</h4>
<p>**描述：**微应用导出的是一个自定义元素（Web Component），加载微应用时渲染对应的元素即可。</p>
<p>**优点：**浏览器自带能力，接入简单，自带Shadow DOM沙箱。</p>
<p>**缺点：**兼容性不太好，暂时只有较新的浏览器支持，但未来可期。</p>
<h4 id="6-microapp">6. MicroApp</h4>
<p><strong>描述：</strong> [MicroApp](https://cangdu.org/micro-app/是京东零售推出的一款微前端框架，是基于WebComponent实现的一种用于构建微前端应用的极简方案。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220401104503.png" alt="d879637b4bb34253" loading="lazy"></figure>
<p>**优点：**接入成本很低，只需一行代码即可实现微前端，提供了<code>js沙箱</code>、<code>样式隔离</code>、<code>元素隔离</code>、<code>预加载</code>、<code>数据通信</code>、<code>静态资源补全</code>等一系列完善的功能。</p>
<p>**缺点：**依赖于CustomElements和Proxy两个较新的API，兼容性需要考虑。</p>
<h4 id="7-emp">7. EMP</h4>
<p><strong>描述：</strong> <a href="https://emp2.netlify.app/">EMP</a>由欢聚时代（YY）自主研发的单页微前端解决方案，主要基于Webpack5的新特性Module Federation实现。</p>
<p>**优点：**强调去中心化，每个微应用都可以引入其他的微应用，无中心应用（容器/主应用）的概念。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>接入有一定成本，不同技术栈接入有一定难度；</li>
<li>因为使用了Module Federation，所以仅支持webpack5+构建的应用。</li>
</ul>
<h3 id="基座式">基座式</h3>
<h4 id="7-single-spa">7. Single-spa</h4>
<p><strong>描述：</strong><a href="https://zh-hans.single-spa.js.org/">Single-spa</a>在上面的js集成方案，加入了生命周期，算是比较老牌的微前端框架了。</p>
<p>**优点：**支持生命周期和代码延迟加载。</p>
<p>**缺点：沙箱环境需要自行处理，有一定的侵入性。</p>
<h4 id="8-qiankun">8. qiankun</h4>
<p><strong>描述：</strong><a href="https://qiankun.umijs.org/zh/">qiankun</a>由蚂蚁团队基于single-spa构建的微前端解决方案，功能比较完善，已有多个成功应用案例验证，是目前应用最多的微前端框架。</p>
<figure data-type="image" tabindex="4"><img src="https://pic2.zhimg.com/80/v2-d55549366b52cde19c93835cfa2a58c9_1440w.jpg" alt="v2-d55549366b52cde19c93835cfa2a58c9_1440w" loading="lazy"></figure>
<p><strong>优点：</strong></p>
<ul>
<li>接入成本相对较低，框架本身已包含构建微前端系统时所需要的基本能力。</li>
<li>微应用入口支持多种方式。</li>
</ul>
<p>**缺点：**没有提供依赖复用，需要自行解决。</p>
<h4 id="9-icestark">9.  icestark</h4>
<p><strong>描述：</strong> <a href="https://micro-frontends.ice.work/">icestark</a>是阿里飞冰出品的面向大型系统的微前端解决方案。</p>
<p>**优点：**相比qiankun，支持微模块，一种粒度更小的挂件，可以随处挂载。</p>
<p>**缺点：**样式隔离问题目前还只能靠规范来规避，Shadow DOM方案还在实验中。</p>
<h4 id="10-garfish">10. Garfish</h4>
<p><strong>描述：</strong><a href="https://garfish.top/">Garfish</a>是字节跳动出品，包含构建微前端系统时所需要的基本能力。</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406160138.png" alt="image.png" loading="lazy"></figure>
<p>**优点：**api简单，接入成本低，自带依赖共享api，支持插件扩展。</p>
<h2 id="路在何方">路在何方</h2>
<p>可以看到，在上述方案中，比较成熟的方案有MicroApp、EMP、qiankun、Garfish。当下微前端相应的解决方案其实挺多的，但是并不存在银弹，每一个方案都有优缺点，只有结合实际需求进行选择最合适的那个方案就行。</p>
<p>当然除了前面说的几个微前端的核心原则，一般在选型时，我们还注意如下几个纬度：</p>
<table>
<thead>
<tr>
<th>纬度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>稳定性</td>
<td>该方案是否经历了社区的考验，有较多的成熟案例，同时保持较高的活跃性，有完善的文档。</td>
</tr>
<tr>
<td>可拓展性</td>
<td>支持定制化开发，提供较高的可拓展能力，同时成本可以在接受范围内</td>
</tr>
<tr>
<td>可控性</td>
<td>发生问题后，能够在第一时间内进行问题排查，以最快的响应速度来处理问题，修复的方案是否会依赖于外部环境</td>
</tr>
<tr>
<td>低成本</td>
<td>学习成本和项目接入改造成本是一个很重要的考量因素，成本太高会适得其反。</td>
</tr>
</tbody>
</table>
<p>所以，结合上述和项目的一些因素，当时我们最终选择了qiankun。接下来我们就聊一聊qiankun。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【玩转微前端】微前端是什么]]></title>
        <id>https://www.bwrong.cn/post/gddd_X1cY/</id>
        <link href="https://www.bwrong.cn/post/gddd_X1cY/">
        </link>
        <updated>2022-04-07T13:43:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="困局">困局</h2>
<p>在开始前，我们先来看看传统架构方式的一个发展历程：</p>
<figure data-type="image" tabindex="1"><img src="https://swearer23.github.io/micro-frontends/ressources/diagrams/organisational/monolith-frontback-microservices.png" alt="Monolithic Frontends" loading="lazy"></figure>
<p>可以归纳为三个阶段：</p>
<ol>
<li>前后端一体</li>
<li>前后端分离，单体应用</li>
<li>前后端分离，后端微服务化</li>
</ol>
<p>在前后端进行分离后，后端仅负责数据处理工作，前端的职责开始扩张。同时前端技术的发展也促使前端应用的复杂度不断提升。这时，传统的单体架构在大型应用中就稍显乏力了，尤其是中后台项目，时间跨度长，很容易就演变成巨石应用，越来越难以维护。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331161639.png" alt="aba723dd5766a90fca78309da0dc980893221" loading="lazy"></figure>
<p>举例: 一个持续多年的应用，经历几年的业务的更新迭代，当项目发展到一定程度的时候就会遇到以下问题</p>
<ol>
<li>业务模块之间不断的堆叠，交错引用，业务耦合如何治理？</li>
<li>老技术、老代码不敢动，新技术、新架构又想用？</li>
<li>万年技术债？既要跟随业务敏捷迭代，又要保证代码库向好发展，旧的框架类库如何平稳升级？</li>
<li>一个项目多个团队开发，你冲突我，我冲突你，如何解决并行开发的冲突？</li>
<li>代码库持续膨胀，难以维护的项目代码，是屎上雕花？还是从头再来？</li>
</ol>
<p>你们的项目是否有上述这些情况呢？我们该如何解决这些问题呢？</p>
<h2 id="破局">破局</h2>
<p>“微前端”这个词首次出现是在2016年 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.thoughtworks.com%2Fradar%2Ftechniques%2Fmicro-frontends">ThoughtWorks Technology Radar</a> 中，但是直到最近几年才被频频提及，那么它是破局之法吗？</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331093221.png" alt="radar" loading="lazy"></figure>
<p>微前端源自微服务这种服务端的技术范式，微服务的核心关键在于服务的抽象，用于解决服务端高并发、高可用等问题。而微前端和微服务不尽相同，微前端是一种多个团队通过独立发布的方式来共同构建现代化 web 应用的技术手段及方法。微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用后，随之而来的工程膨胀、开发维护困难等问题。</p>
<p>微前端背后的思想是认为：现代复杂的web应用，通常由很多 <strong>相对独立的功能模块组合而成</strong>，而对这些模块负责的可能是 <strong>相互独立的多个团队</strong>。这些独立的团队由于专业分工不同，会负责着 <strong>特定的业务领域</strong>，以及完成 <strong>特定的开发任务</strong>。这样的团队，通常在人员组成方面囊括了从前端开发到服务端开发，从UI实现到数据库设计这样 <strong>端到端</strong> 的 <strong>跨职能人员</strong> 构成。</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331163236.png" alt="End-To-End Teams with Micro Frontends" loading="lazy"></figure>
<p>然而微前端这个概念并不新鲜。它实际上与 <a href="http://scs-architecture.org/">自包含系统</a> 概念一脉相承。在过去，微前端之类的思路，会被称为 <a href="https://dev.otto.de/2014/07/29/scaling-with-microservices-and-vertical-decomposition/">面向垂直划分系统的前端集成</a>。称之为微前端，是因为这个词，对于前端开发人员来说更加易于理解。</p>
<p><strong>定义：微前端并不是指某一具体的技术，而是一种整合了技术、策略和方法的宏观架构方案，是一种将多个可独立交付的小型前端应用聚合为一个整体的架构风格。</strong></p>
<h2 id="使用场景">使用场景</h2>
<p>目前来说，微前端并不是一个无脑使用的架构方案，相比现行的架构方案，还是会带来一些工程复杂度的提升。那么什么场景下可以考虑使用微前端呢？</p>
<h3 id="1-复用别的的项目页面">1. 复用别的的项目页面</h3>
<p>在新项目中需要集成一些其他已开发好的项目时，或者直接复用已有的一些功能模块时，常规的方案就是把代码直接拷贝过来，但是会有一些问题：</p>
<ul>
<li>技术栈不一致，依赖版本不一致，等等问题需要做处理。</li>
<li>更新比较麻烦，别人代码更新，我们需要去做同步。</li>
</ul>
<h3 id="2-巨无霸项目的自由拆分组合">2. 巨无霸项目的自由拆分组合</h3>
<p>一个功能齐全的大型项目，在开发维护时面临到如下问题：</p>
<ul>
<li>代码越来越多，打包越来越慢，部署升级麻烦，一些插件的升级和公共组件的修改需要考虑的更多，很容易牵一发而动全身</li>
<li>项目太大，参与人员越多，代码规范比较难管理，代码冲突也频繁。</li>
<li>产品功能齐全，但是客户往往只需要其中的部分功能。剥离不需要的代码后，需要独立制定版本，独立维护，增加人力成本。</li>
</ul>
<p>当你遇到如上两种情况，那么你可以考虑接入微前端。</p>
<p>想了解微前端更多的信息请查阅<a href="https://swearer23.github.io/micro-frontends/">micro-frontends</a>。</p>
]]></content>
    </entry>
</feed>