<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bwrong的博客]]></title>
  <link href="https://www.bwrong.cn/atom.xml" rel="self"/>
  <link href="https://www.bwrong.cn/"/>
  <updated>2024-10-05T22:59:38+08:00</updated>
  <id>https://www.bwrong.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[WebGL光照渲染立方体]]></title>
    <link href="https://www.bwrong.cn/17280514986441.html"/>
    <updated>2024-10-04T22:18:18+08:00</updated>
    <id>https://www.bwrong.cn/17280514986441.html</id>
    <content type="html"><![CDATA[
<p>光线照在物体上，物体反射光线就会构成一个光场，眼睛看到生活中的物体有立体感就是因为有光的存在。因此在学习物理光学在WebGL编程中如何应用， 你就要先了解基本的光学知识。</p>
<p>生活中你看到一个红色立方体，从宏观的角度来看你会描述他是红色的，或者描述RGB值为(1,0,0)的立方体，这时候你要问自己一个问题， 如果呈现到眼睛中的红色平面图像，如果颜色是均匀的，你是否还有立体的感觉。换句话说就是如果把你看到的立方体图像分割成一个个像素单位， 那么每一个像素的RGB值都是(1,0,0)的话你是否有立方体的空间感，从前面课程的实验可以知道，是没有任何空间感的。 那就说明一个问题实际上在自然界中你看到的物体图像，如果看做一个光场，它就是一个变化的光场，并不是每个像素都是(1,0,0)。 这很好理解，抛开专业的物理光学不谈，其实生活中你会发现，比如太阳光照射到一个物体上，不同的面与光的角度不同，反射的到眼睛中的结果不同， 向阳面亮，背光面暗，不同的面不同的颜色，分界位置就有棱角感，。比如一个白色LED灯，靠近表面放在表面的中心， 你会感到表面反射到眼睛中的效果是越往四周越暗。</p>
<h2><a id="%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>光照模型</h2>
<h3><a id="%E6%BC%AB%E5%8F%8D%E5%B0%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>漫反射</h3>
<p><img src="http://www.yanhuangxueyuan.com/WebGL_course/icon/IncidentAngle.png" alt="WebGL光照模型入射角" /> <img src="http://www.yanhuangxueyuan.com/WebGL_course/icon/diffuseReflection.png" alt="WebGL漫反射" /></p>
<p>没有绝对的真理或迷信，所有的理论都是对生活现象的概括描述，上面提到一个几何体在太阳光下不同的面明暗不同，太阳离地球比较远，太阳光可以视为平行光，几何体不同的面与平行太阳光光线夹角不同， 换句话说就是相同强度的光线照射在表面上角度不同反射光线的强度也就不同，这里就对个现象建立数学模型。</p>
<p>漫反射光的颜色 = 几何体表面基色 x 光线颜色 x 光线入射角余弦值</p>
<p>这个数学模型没有考虑镜面反射描述的就是理想的漫反射体，并不能完整的描述物体表面的光场，既然是数学模型，自然就是可以修正的，比如添加一个系数，更改指数等等，这里不在详述。 比如普通的桌子桌面它的粗糙度是微米um级，相比人的脸它是平的，光的波长是纳米nm级，这时候桌子表面相比光线是凹凸不平的，宏观来看一束光线照射到物体的表面，对于理想的漫反射而言，因为表面无规则随机分布凹凸不平的反射面， 光线的反射是不定向的，换句话说任何角度的反射光都是一样的，这也就是说物体反射到眼睛中的光与人的观察位置无关，物体的漫反射光强度与光线的入射角有关如何解释，这个其实很简单，比如两块纸板面积相同，一个垂直太阳光线放置， 一个不垂直太阳光线也就是入射角不是90度，同样强度的光照条件下，垂直太阳光的纸板的光通量肯定比斜着放的纸板接收的光量大，这时候就有必要给数学模型引入一个入射角的因数。</p>
<p><img src="http://www.yanhuangxueyuan.com/WebGL_course/icon/diffuseReflection1.png" alt="漫反射余弦值" /> <img src="http://www.yanhuangxueyuan.com/WebGL_course/icon/diffuseReflection0.png" alt="WebGL漫反射——0度" /></p>
<p>光的颜色可以使用多种模型来表示，把上面的文字公式使用RGB具体参数来表示形式如下，比如物体表面的颜色是纯红色(1,0,0),入射光是纯白色(1,1,1),光线入射角是60度，余弦值就是0.5，代入下面公式，可以得出结果是(0.5,0,0), 结果仍然是红色，这是符合实际生活的，白色太阳光照在常见的红色物体上，反射的颜色是红色，只是太阳光线照射在物体表面的角度不同，反射的光强度不同。入射光垂直物体表面，也就是入射角是0对应的余弦值是1，光线垂直表面受光量最大， 反射光自然最大，和1对应；入射光线平行物体表面，此时的入射角是90度， 物体表面自然没什么光可以反射，</p>
<p>(R2,G2,B2) = (R1,G1,B1) x (R0,G0,B0) x cosθ</p>
<h3><a id="%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>镜面反射</h3>
<p><img src="http://www.yanhuangxueyuan.com/WebGL_course/icon/AmbientLight.png" alt="WebGL环境光模型" /> <img src="http://www.yanhuangxueyuan.com/WebGL_course/icon/SpecularReflection.png" alt="WebGL镜面反射" /></p>
<p>上面的漫反射数学模型没有考虑镜面反射，描述的就是理想的漫反射体，并不能完整的描述物体表面的光场。漫反射是因为几何体表面粗糙度尺寸相对光波长尺寸而言是凹凸不平的，这种凹凸不平又是随机的，所以说漫反射的光线各个方向是均匀的。 镜面反射也就是说光照在物体上的反射光线具有方向性，具体点说就是光线的反射角等于入射角。生活中的镜子它的表面粗糙度很小，和光的波长是一个数量级，当光线照在上面的时候，反射光线就会表现出方向性。</p>
<p>实际的生活中所有的物体没有绝对的漫反射或者镜面反射，往往都是同时存在，只是表现的倾向性不同，镜子的镜面反射更明显，粗糙的树皮漫反射更明显。光照射到物体上一部分会被吸收，透明的话一部分会被折射， 除去吸收和折射的光剩余的会被反射，反射的时候根据表面的粗糙度不同，镜面反射和漫反射分配的比例不同可以使用两个系数k1、k2去描述。</p>
<p>在室外停放着一辆车，你观察车的时候，你会发现车的外表面会在某个局部出现高光，这很好理解，车的外壳是曲面的，曲面上如果某个区域的的光线反射角刚好是你的视线方向，自然会呈现出局部高亮的现象，其他的部位是漫反射为主。 镜面反射的公式仍然可以写成上面的形式，只是角度不再是光线入射角度而是眼睛视线与反射光线的夹角，n角度余弦值的指数，实际编程的时候你可以自由定义，没有绝对完美的模型，都可以进行修正。</p>
<p>镜面反射光的颜色 = 几何体表面基色 x 光线颜色 x 视线与反射光线的夹角余弦值n</p>
<h3><a id="%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>环境光照</h3>
<p>在暗的环境下，物体比较暗，光亮的环境下，物体比较光亮，描述这个现象可以使用环境光照模型。光线在自然环境中会在不同的物体之间来回反射，单束的光线具有方向性，所有方向的光线随机分布，形成一个没有特殊的光线方向的的环境光照。 多数情况下室内室外环境光颜色通常都是RGB相同的白色到黑色之间的值，(1,1,1)表示最强的环境光照颜色，(0,0,0)相当于处于完全的没有光照的黑色环境中。</p>
<p>环境反射光颜色 = 几何体表面基色 x 环境光颜色</p>
<h3><a id="%E5%A4%8D%E5%90%88%E5%85%89%E7%85%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复合光照</h3>
<p>使用光照渲染模型的时候往往会使用多种光照模型，然后把每个光照模型颜色相乘的结果RGB分别相加，这时候要注意，多种模型的光照颜色相加后RGB的值要保证在区间[0,1]，因为WebGL的RGB颜色模型默认RGB分量的最大值是1，注意分配比例即可。</p>
<p>总反射光线 = 漫反射光线 + 镜面反射光线 + 环境反射光线</p>
<h3><a id="%E6%B3%95%E5%90%91%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>法向量</h3>
<p>有基本的数学知识应该都有法线的概念，垂直与面的直线就是面的法线，对于平面而言面上所有位置的法线方向是相同的，对于曲面而言不同的位置法线的方向是变化的。在三维笛卡尔坐标系中，可以使用向量(x,y,z)来表示法向量，根据几何体表面的法向量和光线的方向， 就可以求解出光线入射角的余弦值，法向量的点积计算满足下面的公式，为了方便计算，着色器语言内置了一个方法dot()用来求解两个向量之间的余弦值,已知向量a1(x1,y1,z1)、a2(x2，y2，z2)执行dot(a1，a2)可以求出两个向量a1、a2的余弦值。</p>
<p><img src="http://www.yanhuangxueyuan.com/WebGL_course/icon/normal1.jpg" alt="WebGL法向量" /></p>
<p><img src="http://www.yanhuangxueyuan.com/WebGL_course/icon/normal2.jpg" alt="WebGL法向量计算" /></p>
<h2><a id="%E7%AB%8B%E6%96%B9%E4%BD%93%E6%B7%BB%E5%8A%A0%E5%B9%B3%E8%A1%8C%E5%85%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>立方体添加平行光</h2>
<p><a href="http://www.yanhuangxueyuan.com/WebGL_course/download/light.rar">源码下载</a></p>
<p>下面的案例是通过给一个单色的立方体添加平行光进行渲染，来体会光照模型在物体渲染中的应用，在学习下面的代码之前确定你有逐顶点和颜色插值计算的概念，了解顶点位置数据、顶点颜色数据，本节课在这两种顶点数据的基础之上在引入一种新的顶点数据。</p>
<p>平行光照射在立方体上，与不同的平面夹角不同，自然反射的颜色RGB值强弱不同，实际绘图的时候你不可能手动计算去定义每一个像素的值，前面课程中讲解颜色插值计算的知识，应该对你有一定的启发，你只需要计算出每一个顶点在光照下的颜色， 然后利用插值计算就可以得到三个顶点之间区域的像素值，这时候顶点法向量数据就派上了用场，每一个顶点都有位置数据、颜色数据、法向量数据，法向量和颜色数据先进行计算得出新的顶点颜色数据，然后渲染管线对顶点进行装配光栅化的过程中，新的顶点颜色数据进行插值计算。 这时候提示一下大家，不要去从宏观思考法向量问题，要从逐顶点、插值计算的角度理解问题，下面的问题可能大家会有一个疑问，为什么立方体的一个顶点会有三个方向，从实际的物体来看，立方体的一个顶点就是一个顶点，但是从绘图的角度来看， 每一次是通过三个顶点绘制一个三角形面，只不过恰好三个三角形面共顶点，会有顶点位置重复而已，但是每一组的三个顶点是一个装配光栅化和插值计算的独立单元，两组的三个顶点位置有重复也不会影响他们各自的渲染得到的像素结果。</p>
<h3><a id="%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>顶点着色器：添加变量</h3>
<pre class="line-numbers"><code class="language-plain_text">16   /**用于光照计算的变量a_normal、u_lightColor、u_lightDirection**/
17   'attribute vec4 a_normal;' +//法向量变量
18   'uniform vec3 u_lightColor;' + //uniform声明平行光颜色变量
19   'uniform vec3 u_lightDirection;' + //平行光方向
20   'varying vec4 v_color;'+//varying声明顶点颜色插值后变量
</code></pre>
<p>查看上面的代码大家可以发现一个新的关键字uniform，着色器语言中声明变量的关键词就是attribute、uniform、varying这三个关键字，在Javascript语言中只有一个var或ES6中的let，这主要是因为着色器语言的特殊性， 不同的关键字顶标着不同的功能，初学者可能比较混乱，不知怎么区分，下面进行简单总结，为了课程讲解渐进性，不做过多总结，紧密结合代码总结。</p>
<p>attribute关键字大家课程中最早讲解，大家可以看到它都是出现在顶点着色器的代码中， 声明的变量往往与顶点数据相关，比如顶点位置坐标、顶点颜色值和本节课的顶点法向量数据，attribute关键字声明的顶点变量而且可以通过方法getAttribLocation()获取顶点数据的索引位置， 然后利用方法vertexAttribPointer()可以把类型数组创建的顶点数据传递给顶点着色器，然后逐顶点处理计算。你可以观察到这些方法中都有Attrib，通过名字就可以大致判断它的作用。</p>
<p>varying关键字在颜色插值计算中往往会使用，在顶点着色器代码第20行中声明了一个变量v_color，每个顶点的颜色与法向量进行乘法运算后，第49行进行赋值计算，等于告诉渲染管线离散的顶点颜色进行插值计算，去填充顶点之间的片元像素值， 为了完整实现这一点，需要在片元着色器代码中同样使用关键字varying再次声明该变量，这样的话插值后的颜色值会地递给片元着色器，通过执行第56行语句gl_FragColor = v_color，把片元对应的颜色值赋值给片元。</p>
<p>uniform关键字和attribute共同的作用是可以接收数据，不同点是接收的数据不同，attribute关键字声明顶点数据，这些数据会逐顶点处理，查看代码第18行第19行可以看出uniform关键字声明的数据不是顶点数据，这些数据往往都会重复利用，每个顶点进行计算的时候都会用到， 每个顶点对应的数据会有坐标、颜色、法向量等，但是光线的颜色和方向对于所有的顶点都是通用的，这些说明uniform关键字主要用于声明哪些会被重复利用的数据，比如光线颜色、光线方向、光线位置、模型变换矩阵。学习后面的课程可以看到uniform关键字也会用到片元着色器中， 这里没有用到就不展开讲解，不过attribute关键字只是用在顶点着色器中，一般用来接收各种类型的顶点信息。</p>
<p>代码第18行第19行都有一个关键字vec3，vec3和float、vec4、mat4一样都表示一种数据类型，vec3数据(a,b,c)可以用来表示三维坐标系中的向量，例如光线的方向、光线的颜色RGB，vec4可以用来表示顶点位置的齐次坐标(x,y,z,w), 包含透明度的RGB颜色模型RGBA(r,g,b,a),顶点的法向量。</p>
<h3><a id="%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%EF%BC%9A%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>顶点着色器：光照计算</h3>
<p>dot()是着色器语言内置的一个函数方法，它的参数是两个向量，执行结果是两个向量的点积，如果光线方向向量和顶点法向量两个向量都是单位向量，求解的结果就是平行光线与物体表面法线夹角的余弦值。 这也是为什么要执行第43行代码的原因，normalize()和dot()一样都是着色器语言内置的函数方法用于数学计算，它的作用就是把向量归一化，具体点说就是如果向量的模长不是1，不改变向量方向，把模长变为1，也就是把向量转化为单位向量， a_normal在第17行代码中定义的是vec4类型，第四个参数默认是1主要是为了凑成齐次坐标用于矩阵计算，表示法向量方向的是前三个参数，所以执行a_normal.xyz就相当于访问法向量的xyz值，返回的结果是一个vec3数据，如果执行vec3.xy相当于返回一个vec2数据， 如果一个顶点的a_normal数据是(1,1,1，1)，那么它的模长就不是1，而是3的平方根，这时候需要把前三个1全部除以3的平方根才可以把非单位向量转化为单位向量。</p>
<p>第45行代码在dot代码的外面嵌套了一个函数max()，dot()的计算结果作为max()的第一个参数，dot的计算结果可能是[-1,1]之间，颜色不存在负值要舍去[-1,0),这时候就是max()方法派上用场的时候，第45行代码中max()函数的第二个参数是0， dot()方法的计算结果会和0进行比较运算，返回一个较大的值，着色器语言内置提供了max()函数，自然也有对应的求较小值的函数min()。余弦值是负值的物理意义就是光线无法照的地方，临界点是余弦值0，入射角是90度，也就是说入射光线平行平面， 平行平面相当于光线没有照射到平面上，平面没有收到光自然无法反射光，你可以尝试改变立方体顶点的旋转矩阵可以看到一些面的颜色是黑色，就是因为没有光线照射，这一点是复合实际生活和物理规律的，不管是提本身是什么颜色，没有外界光源，那就表现为黑色。</p>
<p>第47行代码是套用理想漫反射光照模型的一个公式进行计算，a_color变量是vec4类型包含透明度，计算式中没有计算透明度A，所以使用a_color.rgb语句返回a_color数据的RGB三个分量，也就是返回一个vec3类型数据。</p>
<p>第49行代码是通过把经顶点法线乘过的顶点颜色赋值给varying声明的一个变量实现颜色的插值计算，关于插值计算不在多谈，这里说一下着色器语言数据类型的相关转化、构造、访问相关问题，vec4、vec3等都是和float、int一样是数据类型的标识关键字，float、int在C语言中都是常见的类型， 着色器语言为了实现大规模的顶点运算增加了很多数据类型，vec4()、vec3()这时候的表达相当于一个vec4、vec3数据的构造函数，第49行代码中把一个vec3类型数据和一个vec4类型数据的一个分量a作为构造函数vec4的两个参数，来实现创建一个vec4类型数据。访问多元素数据的分量可使用点符号，从面对象的角度来看， 一个数据家是一个对象，数据的一个元素就是数据的一个分量，比如 a_color.a表示vec4类型数据 a_color的透明度分量a。</p>
<pre class="line-numbers"><code class="language-plain_text">42   // 顶点法向量归一化
43   '  vec3 normal = normalize(a_normal.xyz);' +
44   // 计算平行光方向向量和顶点法向量的点积
45   '  float dot = max(dot(u_lightDirection, normal), 0.0);' +
46   // 计算平行光方向向量和顶点法向量的点积
47   '  vec3 reflectedLight = u_lightColor * a_color.rgb * dot;' +
48   //颜色插值计算
49   '  v_color = vec4(reflectedLight, a_color.a);' 
</code></pre>
<h3><a id="%E8%8E%B7%E5%8F%96%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取着色器变量</h3>
<p>要想给着色器程序中声明的变量传递数据，首先要获取数据的地址，然后通过指针地址传递给变量。要想获取变量地址，不可能像普通CPU变成一样，要考虑GPU的特殊性，首先要通过59行代码调用初始化着色器函数，把着色器程序通过CPU与GPU的通信传递给GPU配置渲染管线， 执行执行初始化着色器函数的同时会返回一个program对象，通过对象program可以获取着色器程序中的变量，getAttribLocation()方法用来获取attribute关键字声明的定点变量地址，getAttribLocation()方法获取uniform关键字声明的统一变量地址。</p>
<pre class="line-numbers"><code class="language-plain_text">60   /**
61    * 从program对象获取相关的变量
62    * attribute变量声明的方法使用getAttribLocation()方法
63    * uniform变量声明的方法使用getAttribLocation()方法
64    **/
65   var aposLocation = gl.getAttribLocation(program,'apos');
66   var a_color = gl.getAttribLocation(program,'a_color');
67   var a_normal = gl.getAttribLocation(program,'a_normal');
68   var u_lightColor = gl.getUniformLocation(program,'u_lightColor');
69   var u_lightDirection = gl.getUniformLocation(program,'u_lightDirection');
</code></pre>
<h3><a id="%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>传递数据</h3>
<p>对于简单的数据，不像顶点有大批量数据，不需要在显存上开辟缓冲区上传数据，可以直接使用uniform3f()方法使用把数据传递给GPU，uniform3f(变量地址,x,y,z)表示传递三个浮点数，接收这个数据的变量是vec3类型,uniform2f(变量地址,x,y)表示传递2个浮点数,接收数据的变量是vec2数据类型， 以此类推还有方法uniform4f()、uniform1f()，命名的特点是数字表示传递的数据有多少分量，f是关键字float的缩写表示浮点数。</p>
<p>u_lightDirection变量在程序中要保证是单位向量，所以第15行的代码的书写方式保证了灯光方向向量的方向是(1,2,-3),(1,2,-3)的模长是15的平方根，所以要除以Math.sqrt(15)，实际的开发中一般不是这样手动计算写出来，而是写一个通用的归一化函数可以随时调用， 这里为了简化教学代码，直接手动计算好在输入数据。</p>
<pre class="line-numbers"><code class="language-plain_text">70   /**
71    * 给平行光传入颜色和方向数据，RGB(1,1,1),单位向量(x,y,z)
72    **/
73   gl.uniform3f(u_lightColor, 1.0, 1.0, 1.0);
74   //保证向量(x,y,z)的长度为1，即单位向量
75   var x = 1/Math.sqrt(15), y = 2/Math.sqrt(15), z = 3/Math.sqrt(15);
76   gl.uniform3f(u_lightDirection,x,y,-z);
</code></pre>
<h3><a id="%E9%A1%B6%E7%82%B9%E6%B3%95%E5%90%91%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>顶点法向量</h3>
<p><img src="http://www.yanhuangxueyuan.com/WebGL_course/icon/normal.png" alt="WebGL顶点法向量" /></p>
<p>对于立方体而言六个平面也就是有六个不同的平面法向量，但是这里要注意思考如何表达一个面的法向量，你不能说直接告诉GPU一个平面的法向量是(x,y,z)，对于立方体而言而言这样比较简单，符合人的思维，但是如果是复杂的曲面这样并不合适，而且顶点着色器是逐顶点处理， 为了表示面的法向量，往往是通过顶点，具体点说是每个顶点对应一个法向量，三个顶点确定一个三角面，三角面的不同位置的法向量相当于通过他的三个顶点的法向量插值得出，或者换个说法就是三个顶点的法向量分别与各自颜色数据进行乘法运算，得到新的顶点颜色， 然后渲染管线利用新的顶点颜色进行插值计算，这就是通过顶点法向量表示面法向量的方法，通过这样的巧妙设计还可以实现法向量的插值计算，只不过插值是通过颜色插值完成的，对于平滑的曲面，过每一个顶点存在一个法平面，也就是有一个法向量，往往在不同三角面中同一位置的顶点法向量是相同的， 对于规则的长方体而言，每个顶点法向量往往在各自平面中有不同的值。</p>
<pre class="line-numbers"><code class="language-plain_text">99   /**
100   *顶点法向量数组normalData
101   **/
102  var normalData = new Float32Array([
103  0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,//z轴正方向——面1
104  1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,//x轴正方向——面2
105  0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,//y轴正方向——面3
106  -1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,//x轴负方向——面4
107  0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,//y轴负方向——面5
108  0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1//z轴负方向——面6
109  ]);
</code></pre>
<h2><a id="%E9%A1%B6%E7%82%B9%E6%B3%95%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>顶点法向量矩阵变换</h2>
<p>不知大家是否注意到上面的顶点法向量数据并不是立方体的外表面的法向量，主要是因为立方体的顶点坐标经过了旋转矩阵变换，不管是顶点的坐标还是顶点的法向量都是相对WebGL坐标系而言， 顶点法向量数据和顶点位置数据并没有关联关系，因此没有随着顶点位置数据的旋转而变化，正是因为这一点，你可以尝试更改着上面案例色器程序中立方体顶点的旋转变换角度， 可以看到有些表面，它的法向量和平行光光线的夹角虽然小于90度，也就是说能被光线照射到，但是它的显示颜色却是黑色，这正是因为顶点坐标虽然经过了旋转变换，但是顶点法向量没有跟着变化， 本节课的内容就是为大家解析如何利用矩阵乘法运算实现顶点法向量的跟随顶点位置同步旋转。</p>
<h3><a id="%E6%97%8B%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>旋转、平移变换</h3>
<p>三维模型的几何变换有平移、缩放、旋转、剪切、镜像等多种，这里就简单分析下旋转变换和平移变换对顶点法向量的影响，几何体平移变换后，几何体表面相对坐标系原点整体偏移，物体的表面相对坐标轴并没有发生旋转， 几何体表面的法平面法线没有变化，也就是说平移矩阵左乘顶点坐标后，顶点的法向量数据不变化不会影响光照计算。几何体旋转变换后，它的表面相对坐标轴发生了旋转，表面的法线自然发生变化， 一个几何体在计算机图形中的描述是一个个顶点，在几何体旋转的过程中，顶点的法向量和顶点的位置坐标是同步旋转变换的，顶点位置变换是通过旋转矩阵乘法运算实现， 也就是说顶点的法向量也乘同样的旋转矩阵就可以保证几何体表面的法线随着几何体旋转而旋转。</p>
<p>在上节课的代码中直接修改顶点着色器代码即可。</p>
<pre class="line-numbers"><code class="language-plain_text">42   // 顶点法向量归一化
43   '  vec3 normal = normalize(a_normal.xyz);' 
</code></pre>
<p>旋转矩阵mx、my连乘后，再乘以顶点法向量a_normal,这时候你可以随意更改旋转角度，通过观察颜色可以知道立方体顶点的法向量对着立方体旋转而旋转。</p>
<pre class="line-numbers"><code class="language-plain_text">42   // 顶点法向量归一化
43   '  vec3 normal = normalize((mx*my*a_normal).xyz);' 
</code></pre>
<h3><a id="%E5%A4%8D%E5%90%88%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复合变换</h3>
<p>如果几何体发生多次旋转，也就意味着几何体的表面法线相对坐标系也发生多次旋转变换，把多个旋转变换矩阵连乘，再乘以顶点法向量构成的列向量即可，这一点和顶点位置坐标旋转变换计算一样。</p>
<p>如果几何体先后进行旋转、平移变换，假设旋转矩阵为A，平移矩阵为B，矩阵AB连乘后得到复合矩阵C，C再乘以顶点位置齐次坐标，就可以得到复合变换后的顶点坐标，对于顶点法向量而言直接右乘旋转矩阵A即可， 不需要关注平移矩阵A，实际的编程中几何体可能发生非常多次平移矩阵、旋转矩阵，没有必要再计算一遍旋转矩阵连乘，可以利用复合矩阵C来求解几何变换后的顶点法向量，但是要矩阵C进行一定变换，才能再乘以顶点法向量。 这很好理解，你可以使用平移矩阵乘以一个顶点法向量，可以看得到顶点法向量的值发生变化，前面说过几何体平移不影响顶点法向量，因为复合矩阵C是包含平移矩阵的成分的，如果使用复合矩阵C直接乘以顶点法向量， 结果是不准确的。这时候线性代数的逆矩阵和转置矩阵知识就派上了用场，你可以把任意一个平移矩阵先利用初等变换的方法求解逆矩阵，再进行转置变换，也就是说求解出一个平移矩阵的逆转置矩阵，把逆转置矩阵与顶点法向量相乘， 你会发现得到的结果，顶点法向量前三个参数的值并没有发生变化，第四个参数发生了变化，不过这无所谓，进行光照计算的时候只会选择前三个参数，第四个参数只是用来辅助计算。这也就说明如果对复合矩阵C进行逆转置变换， 就可以消除平移矩阵对顶点法向量的影响，这时候会带来一个问题，复合矩阵C逆转置变化的过程中，它包含的旋转矩阵相当于也被执行了相同的变换，不过这不影响光照计算，因为旋转矩阵是正交矩阵，它的逆转置矩阵就是它本身， 正交矩阵的乘积仍然是正交矩阵，也就是说多个旋转矩阵相乘后，它的逆转置矩阵仍然是自身。</p>
<h3><a id="%E8%A7%86%E7%BA%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>视线</h3>
<p>课程在<a href="http://www.yanhuangxueyuan.com/WebGL_course/coordinate.html">《WebGL坐标系》</a>中讲解过WebGL图形系统默认的投影方向，或者说人的眼睛观察几何体的方向，或者说照相机拍照的方向。 代码中的灯光方向的向量数据，第三个参数是负数，也就是说从z轴的角度看，平行光照射物体的方向，就是人眼睛看物体的方向，如果把灯光方向的向量数据z参数更改为正数，刷新浏览器看到的是一个漆黑的立方体投影， 这时候相当于黑暗的环境中，人站在物体的背光面，而不是向光面，对于WebGL图形系统，你可以形象的理解为把光源从屏幕前面放到了屏幕的后面，人的观察方向是沿着z轴负方向，从屏幕外向里观察，光线自然被立方体遮挡住了。</p>
<pre class="line-numbers"><code class="language-plain_text">75       var x = 1/Math.sqrt(15), y = 2/Math.sqrt(15), z = 3/Math.sqrt(15);
76       gl.uniform3f(u_lightDirection,x,y,-z);
</code></pre>
<p>灯光方向向量数据第三个参数，也就是z轴方向的数值更改为正数。</p>
<pre class="line-numbers"><code class="language-plain_text">75       var x = 1/Math.sqrt(15), y = 2/Math.sqrt(15), z = 3/Math.sqrt(15);
76       gl.uniform3f(u_lightDirection,x,y,z);
</code></pre>
<h2><a id="%E7%AB%8B%E6%96%B9%E4%BD%93%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%85%89%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>立方体添加点光源</h2>
<p><a href="http://www.yanhuangxueyuan.com/WebGL_course/download/light1.rar">源码下载</a></p>
<p>添加平行光是直接定义光线照射物体的方向，点光源的光线是发散的，无法直接定义它的光线方向，不过只要定义好点光源的位置坐标，然后与某个顶点的位置坐标进行减法运算，计算结果就是光源射到该顶点的方向。 这很好理解，在三维空间中两个点确定一条直线，几何体顶点代表一个点，点光源的位置代表一个点，直线所在的方向就是光线的方向，在三维笛卡尔坐标系中，把两个顶点的xyz三个分量相减就可以得到一个表示直线方向的向量， 把该向量和顶点法向量作为dot()点积函数的参数，可以计算出光线入射角余弦值然后代入漫反射光照模型公式可以得到新的顶点颜色，渲染管线利用新的顶点颜色进行插值计算可以得到立方体表面每一个像素的值。</p>
<h3><a id="%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%85%89%E6%BA%90%E4%BD%8D%E7%BD%AE%E3%80%81%E9%A2%9C%E8%89%B2%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加点光源位置、颜色数据</h3>
<p>点光源的颜色数据是使用WebGL接口uniform3f()方法传入着色器中，点光源的位置数据是使用着色器语言GLSL ES直接定义在顶点着色器程序中，这两种方式实现的结果都是一样的，通过这个对比你可以进一步着色器语言和Javascript语言可以操控的可以实现CPU和GPU通信的WebGL API。</p>
<pre class="line-numbers"><code class="language-plain_text">40   /**设置点光源位置数据**/
41   'vec3 lightPosition = vec3(2,3,4);'
76   /**
77    * 传入点光源颜色数据
78    **/
79   gl.uniform3f(u_lightColor, 1.0, 1.0, 1.0);
</code></pre>
<h3><a id="%E8%AE%A1%E7%AE%97%E5%85%89%E7%BA%BF%E6%96%B9%E5%90%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算光线方向</h3>
<p>点光源的光线是发散的，点光源与每一顶点连线的方向都需要单独计算。第47行代码的功能是计算经过旋转变换后的顶点坐标，这样可以保证光线方向随着立方体旋转动态变化，尤其是制作旋转动画。</p>
<p>第49行代码用来计算光线方向，然后利用内置函数 normalize()归一化向量数据，vec3(vertexPosition)和vertexPosition.xyz的写法是等效的，都是为了提取vec4类型顶点数据前三个分量，返回的数据类型是vec3，比如vec2(vec4)就是提取vec4的前两个分量。</p>
<pre class="line-numbers"><code class="language-plain_text">46   // 计算顶点位置
47   '  vec4 vertexPosition = mx*my*apos;' +
48   // 计算点光源照射顶点的方向并归一化
49   '  vec3 lightDirection = normalize(vec3(vertexPosition) - lightPosition);' 
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用微信第三方平台发布零码小程序]]></title>
    <link href="https://www.bwrong.cn/17280336310867.html"/>
    <updated>2024-10-04T17:20:31+08:00</updated>
    <id>https://www.bwrong.cn/17280336310867.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%9A%BE%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>难点</h2>
<ul>
<li>将设计好的应用生成原生小程序代码：因为编辑时和运行时环境差异性，导致不能使用同一套代码，需要针对不同平台有不同的实现（实现方案二）。</li>
<li>将设计好的应用发布到商家自己的小程序中，需要对接微信第三方平台能力，主要是因为对这套发布流程不熟悉。</li>
</ul>
<h2><a id="%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现方案：</h2>
<hr />
<h3><a id="%E4%B8%80%E3%80%81webapph5%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%9A%E5%A4%8D%E7%94%A8h5%E7%89%88%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、WebApp/H5小程序：复用H5版本</h3>
<p>在H5版本上，通过小程序<a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html">Webview</a>开放能力组件实现H5页面动态渲染，通过传入H5地址方式，实现不同程序内容展示。</p>
<p><strong>特点：</strong></p>
<ul>
<li>实现简单，因为和编辑时使用的是同一环境，****可直接复用，不需要做单独适配。</li>
<li>能力有限，因为使用Webview进行渲染，所以应用所能使用的能力取决于Webview组件提供的开发能力，目前可以使用的能力可查看<a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html#%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3-2">Webview组件文档</a></li>
</ul>
<p><img src="https://pictures-1303450388.cos.ap-chengdu.myqcloud.com/1681960549630-bc7e7caa-c9e0-4e01-8a37-d1ca2cbe3336.jpeg" alt="" /></p>
<h3><a id="%E4%BA%8C%E3%80%81%E5%8E%9F%E7%94%9F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%A1%88%EF%BC%9A%E7%94%9F%E6%88%90%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、原生小程序方案：生成小程序原生组件</h3>
<p>在web端进行应用设计完成后，将内容保存为和平台无关的通用语言数据，常用的为JSON Schema，不同平台需要实现各自的解析适配器，将内容解析为平台特有的代码，这里即为解析为微信小程序。</p>
<p><strong>特点：</strong></p>
<ul>
<li>实现复杂，两个平台差异性太大，需要实现多套解析器和组件。不过可以通过使用多端开发框架（<a href="https://uniapp.dcloud.net.cn/">uniapp</a>、<a href="https://taro.jd.com/">taro</a>）来降低差异性。</li>
<li>能力受限小，因为是生成原生组件，基本上可以使用所有原生组件能力。</li>
</ul>
<pre class="line-numbers"><code class="language-json">{
  &quot;label&quot;: &quot;新增组件&quot;,
  &quot;icon&quot;: &quot;icon-zujian&quot;,
  &quot;fields&quot;: {
    &quot;color_gi&quot;: {
      &quot;label&quot;: &quot;颜色选择器&quot;,
      &quot;type&quot;: &quot;color&quot;,
      &quot;value&quot;: &quot;&quot;
    },
    &quot;string_Ao&quot;: {
      &quot;label&quot;: &quot;输入框&quot;,
      &quot;type&quot;: &quot;string&quot;,
      &quot;value&quot;: &quot;&quot;,
      &quot;options&quot;: {
        &quot;placeholder&quot;: &quot;请输入&quot;
      }
    },
    &quot;upload_6t&quot;: {
      &quot;label&quot;: &quot;图片上传&quot;,
      &quot;type&quot;: &quot;upload&quot;,
      &quot;value&quot;: &quot;&quot;
    }
  }
}
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/159460/1681990517560-e4737370-b90d-44d7-967c-c2a97eaf28f3.jpeg" alt="" /></p>
<p><strong>参考实现方案：</strong></p>
<ul>
<li><a href="https://github.com/silence717/taro-designer">https://github.com/silence717/taro-designer</a></li>
<li><a href="https://github.com/ShaoGongBra/taro-design">https://github.com/ShaoGongBra/taro-design</a></li>
<li><a href="https://ext.dcloud.net.cn/plugin?id=6740">https://ext.dcloud.net.cn/plugin?id=6740</a></li>
<li><a href="https://pageplug.cn/">https://pageplug.cn/</a></li>
<li><a href="https://github.com/staringos/mtbird">https://github.com/staringos/mtbird</a></li>
</ul>
<h2><a id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0%E4%BB%A3%E5%BC%80%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何使用第三方平台代开发</h2>
<p>第三方平台（简称第三方平台），由微信团队面向所有通过<a href="https://kf.qq.com/faq/170824URbmau170824r2uY7j.html">开发者资质认证</a>的第三方开发者提供提供的官方平台。在得到公众号或小程序管理员授权后，基于该平台，第三方服务商可以通过调用官方接口能力，为商家提供公众号代运营、小程序代注册、代开发等服务以及提供公众号和小程序相关的行业方案、活动营销、插件能力等全方位服务。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1682068941157-38b4cd76-d6aa-4eda-ba30-51a0dea43a8f.png" alt="" /><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1682069054303-f88e6aa1-3793-4cb1-95f1-6ef6cd04384a.png" alt="" /></p>
<h3><a id="%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>满足条件</h3>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1682391253106-b4dc9cdf-a06f-47c3-afed-9cf54f2ddeab.png" alt="" /></p>
<ul>
<li>提供行业解决方案，如针对电商行业的解决方案，或针对旅游行业的解决方案等；</li>
<li>行业：（横向）提供更加专业的运营能力，精细化运营用户公众号或小程序；</li>
<li>功能：（纵向）对公众平台功能的优化，如专门优化图文消息视觉样式和排版的工具，或专门定制的 CRM 用户管理功能，或功能强大的小程序插件等。</li>
</ul>
<h3><a id="%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>流程</h3>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1681980164393-0fae9953-54d7-4808-a8f4-13e46c652cf9.png" alt="" /></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1682391612230-1750c702-0d9e-407e-88a8-2c13ea64c746.png" alt="" /></p>
<h4><a id="%E4%B8%80%E3%80%81%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%95%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、如何成为服务商</h4>
<p>1、第三方平台帐号的审核无需缴费，但开放平台帐号的认证（即开发者资质认证）需要交300块钱认证费。一个已完成开发者资质认证的开放平台帐号，可创建5个平台型服务商第三方平台帐号。</p>
<p>2、任何合法合规的、为小程序提供开发服务及有意愿的开发者都可以成为小程序服务商，微信不会区别对待，也无官方授权的概念。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1681980517223-496c322a-ec16-473a-aee5-c0065909bbec.png" alt="" /></p>
<p><a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/operation/thirdparty/prepare.html"><strong>准备材料：</strong></a></p>
<ul>
<li>官方网站：服务商应当有对外可用的官网，且该官网提供的服务描述与申请的第三方平台帐号名称、简介、图标均有所关联</li>
<li>平台图标：图标必须为当前服务商所有，不可使用其他企业的图标作为第三方平台帐号图标，108 x 108像素，大小不超过300KB，且格式为PNG的图片</li>
<li>域名和ssl证书</li>
</ul>
<h4><a id="%E4%BA%8C%E3%80%81%E6%90%AD%E5%BB%BA%E4%B8%89%E6%96%B9%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%EF%BC%9A%E8%87%AA%E5%BB%BA%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BA%91%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、搭建三方后端服务：自建模式和云服务</h4>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1681984771382-05565715-fded-4766-883c-af3bb2dd0bcc.png" alt="" /></p>
<ul>
<li>服务商类型</li>
</ul>
<p><strong>平台型第三方平台帐号</strong></p>
<ul>
<li>这是官方推荐选择的类型，该类型的服务商可基于第三方平台接口能力，在获取商家扫码授权后，为商家提供代开发、代运营公众号和小程序服务。</li>
<li>想要为商家实现批量化服务，例如批量运营公众号、批量代开发小程序等，则需要选择该类型的帐号。</li>
</ul>
<p><strong>定制化型第三方平台帐号</strong></p>
<ul>
<li>当你不需要以服务商身份使用第三方平台接口能力，只需生成票据用于标记商家小程序是由该服务商开发的，那么可以选择创建该类型的帐号。</li>
<li>该类型的帐号仅有一个APPID用以作为服务商帐号id，没有secret，无法生成token，不可调用官方任何接口能力。该类型的服务商通常不基于第三方平台能力为商家提供服务。</li>
</ul>
<p>搭建好三方服务后需要和业务系统服务进行联调对接，然后进行<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/operation/thirdparty/publish.html">全网发布</a>。</p>
<h4><a id="%E4%B8%89%E3%80%81%E6%8E%88%E6%9D%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、授权</h4>
<p>商家需要将其公众号或者小程序<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Authorization_Process_Technical_Description.html">授权</a>给第三方平台，服务商才可以代商家进行相关操作。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1681980296972-49144b20-919e-4d26-bc1d-03817965cd19.png" alt="" /></p>
<h4><a id="%E5%9B%9B%E3%80%81%E4%BB%A3%E5%95%86%E5%AE%B6%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、代商家调用接口</h4>
<p>小程序的api，服务商都可以调用，只是服务商调用的时候要使用<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/ThirdParty/token/api_authorizer_token.html">authorizer_access_token</a>，而不是access_token。</p>
<p>服务商能否代商家成功调用某个公众号或者小程序的api，取决于该公众号或者小程序管理员是否将对应的权限集授权给当前第三方平台帐号。</p>
<h4><a id="%E4%BA%94%E3%80%81%E4%BB%A3%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五、代开发小程序</h4>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1681988187650-15d3e030-e517-4a41-9a7c-fc5073146d1c.png" alt="" /></p>
<h5><a id="%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码上传</h5>
<ul>
<li>通过开发者工具</li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/ci.html">CI代码上传</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/article/doc/0006aec26a89507900dc70f5e5b013?pass_ticket=PFmw0zP6yfVqUJz8iYlCaPgYBj0s6dm%2BoKU5cKthScDFPSrvwo9Z2cS1G9qCIrRyts29yPal4xRGPCSoPxxoeA%3D%3D">使用小程序CI自动上传代码</a></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/159460/1681988652552-ed1314fb-a721-432a-b4e1-9146be97d1ea.png" alt="" /></p>
<h3><a id="%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相关文档</h3>
<ul>
<li><a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/getting_started/terminology_introduce.html">官方文档</a></li>
<li><a href="https://developers.weixin.qq.com/doc/oplatform/openApi/OpenApiDoc/">API文档</a></li>
<li><a href="https://juejin.cn/post/6871397648792813575">微信开放平台之第三方平台开发，一整套流程</a></li>
</ul>
<h3><a id="%E7%9B%B8%E5%85%B3%E8%A7%84%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相关规则</h3>
<ul>
<li><a href="https://developers.weixin.qq.com/doc/oplatform/service_market/provider_guideline/audit/mini_program_develop_audit.html">小程序代开发服务上架要求</a></li>
<li><a href="https://developers.weixin.qq.com/doc/oplatform/service_market/provider_guideline/operation/mini_program_develop_operation.html">小程序代开发运营规则</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Http请求中Content-Type]]></title>
    <link href="https://www.bwrong.cn/17280335710035.html"/>
    <updated>2024-10-04T17:19:30+08:00</updated>
    <id>https://www.bwrong.cn/17280335710035.html</id>
    <content type="html"><![CDATA[
<ol>
<li><strong>Content-Type</strong></li>
</ol>
<p>MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。</p>
<pre class="line-numbers"><code class="language-plain_text">1. 类型格式：type/subtype(;parameter)? type 
2. 主类型，任意的字符串，如text，如果是*号代表所有；  
3. subtype 子类型，任意的字符串，如html，如果是*号代表所有；  
4. parameter 可选，一些参数，如Accept请求头的q参数， Content-Type的 charset参数。  
</code></pre>
<p>例如： <code>Content-Type: text/html;charset:utf-8;</code></p>
<p>常见的媒体格式类型如下：</p>
<ul>
<li>text/html ： HTML格式</li>
<li>text/plain ：纯文本格式</li>
<li>text/xml ： XML格式</li>
<li>image/gif ：gif图片格式</li>
<li>image/jpeg ：jpg图片格式</li>
<li>image/png：png图片格式</li>
</ul>
<p>以application开头的媒体格式类型：</p>
<ul>
<li>application/xhtml+xml ：XHTML格式</li>
<li>application/xml   ： XML数据格式</li>
<li>application/atom+xml ：Atom XML聚合格式</li>
<li>application/json  ： JSON数据格式</li>
<li>application/pdf    ：pdf格式</li>
<li>application/msword ： Word文档格式</li>
<li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li>
<li>application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li>
</ul>
<p>另外一种常见的媒体格式是上传文件之时使用的：</p>
<ul>
<li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li>
</ul>
<p>以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。</p>
<ol start="2">
<li><strong>Spring MVC中关于关于Content-Type类型信息的使用</strong></li>
</ol>
<p>首先我们来看看RequestMapping中的Class定义：</p>
<pre class="line-numbers"><code class="language-java">@Target({ElementType.METHOD, ElementType.TYPE}) 
@Retention(RetentionPolicy.RUNTIME) 
@Documented 
@Mapping 
public @interface RequestMapping { 
	String[] value() default {};
	RequestMethod[] method() default {}; 
	String[] params() default {}; 
	String[] headers() default {};
	String[] consumes() default {};
	String[] produces() default {}; 
} 
</code></pre>
<p>value: 指定请求的实际地址， 比如 /action/info之类。<br />
method： 指定请求的method类型， GET、POST、PUT、DELETE等<br />
consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;<br />
produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回<br />
params： 指定request中必须包含某些参数值是，才让该方法处理<br />
headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求</p>
<p>其中，consumes， produces使用content-typ信息进行过滤信息；headers中可以使用content-type进行过滤和判断。</p>
<ol start="3">
<li><strong>使用示例</strong></li>
</ol>
<p>3.1 headers</p>
<pre class="line-numbers"><code class="language-java">@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET, headers=&quot;Referer=http://www.ifeng.com/&quot;)  
public void testHeaders(@PathVariable String ownerId, @PathVariable String petId) {    
	// implementation omitted  
}  
</code></pre>
<p>这里的Headers里面可以匹配所有Header里面可以出现的信息，不局限在Referer信息。</p>
<p>示例2</p>
<pre class="line-numbers"><code class="language-java">@RequestMapping(value = &quot;/response/ContentType&quot;, headers = &quot;Accept=application/json&quot;)    
public void response2(HttpServletResponse response) throws IOException {    
    //表示响应的内容区数据的媒体类型为json格式，且编码为utf-8(客户端应该以utf-8解码)    
    response.setContentType(&quot;application/json;charset=utf-8&quot;);    
    //写出响应体内容    
    String jsonData = &quot;{\&quot;username\&quot;:\&quot;zhang\&quot;, \&quot;password\&quot;:\&quot;123\&quot;}&quot;;    
    response.getWriter().write(jsonData);    
}    
</code></pre>
<p>服务器根据请求头“Accept=application/json”生产json数据。</p>
<p>当你有如下Accept头，将遵守如下规则进行应用：<br />
①Accept：<code>text/html,application/xml,application/json</code><br />
将按照如下顺序进行produces的匹配 ①text/html ②application/xml ③application/json<br />
②Accept：<code>application/xml;q=0.5,application/json;q=0.9,text/html</code><br />
将按照如下顺序进行produces的匹配 ①text/html ②application/json ③application/xml<br />
参数为媒体类型的质量因子，越大则优先权越高(从0到1)<br />
③Accept：<em><code>/*,text/*,text/html</code><br />
将按照如下顺序进行produces的匹配 ①text/html ②text/</em> ③*/*</p>
<p>即匹配规则为：最明确的优先匹配。</p>
<h2><a id="requests%E9%83%A8%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Requests部分</h2>
<table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>指定客户端能够接收的内容类型</td>
<td>Accept: text/plain, text/html</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可以接受的字符编码集。</td>
<td>Accept-Charset: iso-8859-5</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>
<td>Accept-Encoding: compress, gzip</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可接受的语言</td>
<td>Accept-Language: en,zh</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>可以请求网页实体的一个或者多个子范围字段</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Authorization</td>
<td>HTTP授权的授权证书</td>
<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>指定请求和响应遵循的缓存机制</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>
<td>Connection: close</td>
</tr>
<tr>
<td>Cookie</td>
<td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>
<td>Cookie: $Version=1; Skin=new;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求的内容长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求的与实体对应的MIME信息</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
</tr>
<tr>
<td>Date</td>
<td>请求发送的日期和时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>Expect</td>
<td>请求的特定的服务器行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>From</td>
<td>发出请求的用户的Email</td>
<td>From: <a href="mailto:user@email.com">user@email.com</a></td>
</tr>
<tr>
<td>Host</td>
<td>指定请求的服务器的域名和端口号</td>
<td>Host: <a href="http://www.zcmhi.com">www.zcmhi.com</a></td>
</tr>
<tr>
<td>If-Match</td>
<td>只有请求内容与实体相匹配才有效</td>
<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>
<td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>
<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>只在实体在指定时间之后未被修改才请求成功</td>
<td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制信息通过代理和网关传送的时间</td>
<td>Max-Forwards: 10</td>
</tr>
<tr>
<td>Pragma</td>
<td>用来包含实现特定的指令</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>连接到代理的授权证书</td>
<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Range</td>
<td>只请求实体的一部分，指定范围</td>
<td>Range: bytes=500-999</td>
</tr>
<tr>
<td>Referer</td>
<td>先前网页的地址，当前请求网页紧随其后,即来路</td>
<td>Referer: <a href="http://www.zcmhi.com/archives/71.html">http://www.zcmhi.com/archives/71.html</a></td>
</tr>
<tr>
<td>TE</td>
<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>
<td>TE: trailers,deflate;q=0.5</td>
</tr>
<tr>
<td>Upgrade</td>
<td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
</tr>
<tr>
<td>User-Agent</td>
<td>User-Agent的内容包含发出请求的用户信息</td>
<td>User-Agent: Mozilla/5.0 (Linux; X11)</td>
</tr>
<tr>
<td>Via</td>
<td>通知中间网关或代理服务器地址，通信协议</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>关于消息实体的警告信息</td>
<td>Warn: 199 Miscellaneous warning</td>
</tr>
</tbody>
</table>
<h2><a id="responses%E9%83%A8%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Responses 部分</h2>
<table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Age</td>
<td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
<td>Age: 12</td>
</tr>
<tr>
<td>Allow</td>
<td>对某网络资源的有效的请求行为，不允许则返回405</td>
<td>Allow: GET, HEAD</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>web服务器支持的返回内容压缩编码类型。</td>
<td>Content-Encoding: gzip</td>
</tr>
<tr>
<td>Content-Language</td>
<td>响应体的语言</td>
<td>Content-Language: en,zh</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应体的长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Location</td>
<td>请求资源可替代的备用的另一地址</td>
<td>Content-Location: /index.htm</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>返回资源的MD5校验值</td>
<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td>Content-Range</td>
<td>在整个返回体中本部分的字节位置</td>
<td>Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td>Content-Type</td>
<td>返回内容的MIME类型</td>
<td>Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td>Date</td>
<td>原始服务器消息发出的时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值</td>
<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>Expires</td>
<td>响应过期的日期和时间</td>
<td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
<td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
<tr>
<td>Location</td>
<td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>
<td>Location: <a href="http://www.zcmhi.com/archives/94.html">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Pragma</td>
<td>包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>它指出认证方案和可应用到代理的该URL上的参数</td>
<td>Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td>refresh</td>
<td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td>Refresh: 5; url=<a href="http://www.zcmhi.com/archives/94.html">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Retry-After</td>
<td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>
<td>Retry-After: 120</td>
</tr>
<tr>
<td>Server</td>
<td>web服务器软件名称</td>
<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置Http Cookie</td>
<td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>
</tr>
<tr>
<td>Trailer</td>
<td>指出头域在分块传输编码的尾部存在</td>
<td>Trailer: Max-Forwards</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>文件传输编码</td>
<td>Transfer-Encoding:chunked</td>
</tr>
<tr>
<td>Vary</td>
<td>告诉下游代理是使用缓存响应还是从原始服务器请求</td>
<td>Vary: *</td>
</tr>
<tr>
<td>Via</td>
<td>告知代理客户端响应是通过哪里发送的</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>警告实体可能存在的问题</td>
<td>Warning: 199 Miscellaneous warning</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>表明客户端请求实体应该使用的授权方案</td>
<td>WWW-Authenticate: Basic</td>
</tr>
</tbody>
</table>
<p>3.2 params的示例</p>
<pre class="line-numbers"><code class="language-java">@RequestMapping(value = &quot;/test/{userId}&quot;, method = RequestMethod.GET, params=&quot;myParam=myValue&quot;)    
public void findUser(@PathVariable String userId) {        
  // implementation omitted    
} 
</code></pre>
<p>仅处理请求中包含了名为“myParam”，值为“myValue”的请求，起到了一个过滤的作用。</p>
<p>3.3 consumes/produces</p>
<pre class="line-numbers"><code class="language-java">@Controller    
@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST, consumes=&quot;application/json&quot;, produces=&quot;application/json&quot;)    
@ResponseBody  
public List&lt;User&gt; addUser(@RequestBody User userl) {        
    // implementation omitted    
    return List&lt;User&gt; users;  
} 
</code></pre>
<p>方法仅处理request Content-Type为“application/json”类型的请求. produces标识==&gt;处理request请求中Accept头中包含了&quot;application/json&quot;的请求，同时暗示了返回的内容类型为application/json;</p>
<ol start="4">
<li><strong>总结</strong></li>
</ol>
<p>在本文中，首先介绍了Content-Type主要支持的格式内容，然后基于@RequestMapping标注的内容介绍了主要的使用方法，其中,headers, consumes,produces,都是使用Content-Type中使用的各种媒体格式内容，可以基于这个格式内容来进行访问的控制和过滤。</p>
<p>参考资料：</p>
<ol>
<li>HTTP中支持的Content-Type: <a href="http://tool.oschina.net/commons">http://tool.oschina.net/commons</a></li>
<li>Media Type介绍。 <a href="http://www.iteye.com/topic/1127120">http://www.iteye.com/topic/1127120</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP状态码详解]]></title>
    <link href="https://www.bwrong.cn/17280335390285.html"/>
    <updated>2024-10-04T17:18:59+08:00</updated>
    <id>https://www.bwrong.cn/17280335390285.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td>
</tr>
<tr>
<td>101</td>
<td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td>
</tr>
<tr>
<td>102</td>
<td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td>
</tr>
<tr>
<td>200</td>
<td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td>
</tr>
<tr>
<td>201</td>
<td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。</td>
</tr>
<tr>
<td>202</td>
<td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>
</tr>
<tr>
<td>203</td>
<td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td>
</tr>
<tr>
<td>204</td>
<td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>
</tr>
<tr>
<td>205</td>
<td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td>
</tr>
<tr>
<td>206</td>
<td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td>
</tr>
<tr>
<td>207</td>
<td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>
</tr>
<tr>
<td>300</td>
<td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td>
</tr>
<tr>
<td>301</td>
<td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td>
</tr>
<tr>
<td>302</td>
<td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td>
</tr>
<tr>
<td>303</td>
<td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td>
</tr>
<tr>
<td>304</td>
<td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td>
</tr>
<tr>
<td>305</td>
<td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td>
</tr>
<tr>
<td>306</td>
<td>在最新版的规范中，306状态码已经不再被使用。</td>
</tr>
<tr>
<td>307</td>
<td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td>
</tr>
<tr>
<td>400</td>
<td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。</td>
</tr>
<tr>
<td>401</td>
<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>
</tr>
<tr>
<td>402</td>
<td>该状态码是为了将来可能的需求而预留的。</td>
</tr>
<tr>
<td>403</td>
<td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>
</tr>
<tr>
<td>404</td>
<td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td>
</tr>
<tr>
<td>405</td>
<td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>
</tr>
<tr>
<td>406</td>
<td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>
</tr>
<tr>
<td>407</td>
<td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td>
</tr>
<tr>
<td>408</td>
<td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>
</tr>
<tr>
<td>409</td>
<td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>
</tr>
<tr>
<td>410</td>
<td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone'，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>
</tr>
<tr>
<td>411</td>
<td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>
</tr>
<tr>
<td>412</td>
<td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>
</tr>
<tr>
<td>413</td>
<td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>
</tr>
<tr>
<td>414</td>
<td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>
</tr>
<tr>
<td>415</td>
<td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>
</tr>
<tr>
<td>416</td>
<td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>
</tr>
<tr>
<td>417</td>
<td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>
</tr>
<tr>
<td>421</td>
<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td>422</td>
<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td>422</td>
<td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>424</td>
<td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>425</td>
<td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td>
</tr>
<tr>
<td>426</td>
<td>客户端应当切换到TLS/1.0。（RFC 2817）</td>
</tr>
<tr>
<td>449</td>
<td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>
</tr>
<tr>
<td>500</td>
<td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td>
</tr>
<tr>
<td>501</td>
<td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td>
</tr>
<tr>
<td>502</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td>
</tr>
<tr>
<td>503</td>
<td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td>
</tr>
<tr>
<td>504</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td>
</tr>
<tr>
<td>505</td>
<td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td>
</tr>
<tr>
<td>506</td>
<td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td>
</tr>
<tr>
<td>507</td>
<td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td>
</tr>
<tr>
<td>509</td>
<td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td>
</tr>
<tr>
<td>510</td>
<td>获取资源所需要的策略并没有没满足。（RFC 2774）</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】webgl技术风云录之BabylonJS]]></title>
    <link href="https://www.bwrong.cn/17280335013759.html"/>
    <updated>2024-10-04T17:18:21+08:00</updated>
    <id>https://www.bwrong.cn/17280335013759.html</id>
    <content type="html"><![CDATA[
<p>微软除了在BabylonJS上面布局，同时还投资blender，对未来3D技术布局非常明显。BabylonJS是世界上最强大、最惊艳、最易用的Web3D渲染引擎，并且我们坚持让它完全开源和免费，无论对任何人都如此。Babylon.js 4.1版本的体积小了3倍，速度提升了12%，并且进行了无数的性能优化，在它诞生的那一刻就定位于高性能3D引擎，即使功能越来越强大也会继续贯彻这个理念不动摇。新的Node Material Editor编辑器、真正跨平台的babylon原生应用部署体验、层叠阴影、导航寻路、更强的WebXR虚拟现实及增强现实支持、更完美的glTF格式支持等新功能，让Babylon.js 4.1成为了你不可或缺的web应用开发利器。</p>
<p>Babylonjs不光有微软强大的资金支持，同时它代码功能结构很多参考blender技术体系，如果你同时看了blender代码跟Babylonjs代码，你会发现很多地方都有共同点。</p>
<p>官网：</p>
<p><a href="%E2%80%8Bwww.babylonjs.com/">Babylon.js: Powerful, Beautiful, Simple, Open - Web-Based 3D At Its Best</a></p>
<p>它主要特性有以下几个方面：</p>
<p>1、强大的编辑器，这是threejs跟playcanvas无法比拟的。</p>
<p><img src="https://pic3.zhimg.com/v2-a0d46325eecfb57ab21e6fdf02f13872_r.jpg" alt="" /></p>
<p>编辑器中，对粒子、碰撞、脚本、GUI、精灵图等等各方面功能集成得非常完善，作为一个多年使用微软IDE从事开发的码农，个人一直认为微软的东西很人性化。</p>
<p>2、强大的节点编辑器。在blender里面节点编辑器无处不在，它也是通过connect不同节点的input跟output来实现节点之间的数据联通，这样就把复杂的材质系统变成可视化了。</p>
<p>Node Material Editor是一个强大而易用的材质编辑器，它以可视化的拖拽节点的方式来模拟shader编程，从而为每个从业者解锁了GPU的强大威力。从前，shaders (GPU 编程)着色器编程对于普通程序员门槛很高，因为它过于偏向底层，虽然功能强大，但是晦涩难懂，而Babylon带来的Node Material Editor可以实现与shader同样的效果，但是界面化操作，把难度降到了最低。我们相信，每个人都能使用这个编辑器来创建令人惊叹的视觉效果。</p>
<p><img src="https://pic3.zhimg.com/80/v2-090d22ae6e18cac1fc1d18999ce5ea82_1440w.jpg" alt="" /><br />
材质节点</p>
<p><img src="https://pic2.zhimg.com/80/v2-e68990b0dee4ffd3b9bf0fe017d6828d_1440w.jpg" alt="" /><br />
Babylonjs材质节点</p>
<p>3、NATIVE 跨平台原生应用部署。程序员们写代码都有一个梦想：一次编写实现，多平台共享运行。 所以我们重磅推出了Babylon Native，它可以用原有的Babylon.js代码在任意平台构建一个原生应用，充分释放本机设备的性能优势。 已经支持DirectX on Windows、 Metal on iOS/MacOS、 OpenGL on Android，即将推出Vulkan支持。</p>
<p>Babylonjs的原生打包部署是通过react native技术体系来实现的，这样就可以实现一份代码原生部署，同时保证原生性能。</p>
<p>4、支持先进的WEBXR技术。毫无疑问，在web使用AR/VR技术非常有前景，Babylon最新4.1版本在WebXR上做了进一步的优化和改进：带来了一个简单易用的体检帮助器，针对更高级用户的专用会话管理器，用babylon的相机功能来承载WebXR技术，全面支持任何接受WebXR会话的设备，完整的WebXR输入源支持，关于实验性AR功能、通信、场景交互、物理效果的整套API支持等。</p>
<p><img src="https://pic4.zhimg.com/80/v2-113fe316a7f0ac47282d629cae4c3963_1440w.jpg" alt="" /><br />
webxr支持<br />
总结：</p>
<p>1、如果你要交付内部项目、而且可以是客户端、有U3D开发人员，那么用U3D去交付实现最好，通过安装exe客户端，灯光效果交互、vr支持都是非常完美，而且U3D的开发者论坛、文档、百度教程都非常丰富。</p>
<p>2、如果你项目必须是webgl的，需要浏览器打开，webgl技术风云录中提到的那些平台都无法满足你的需求，建议你用Babylonjs，这是最好的平台，最好的框架。</p>
<p><a href="%E2%80%8Bwww.zhihu.com/column/c_1327931812140441600">webGL技术风云录专栏</a></p>
<p>3、如果您是webgl开发者，你目前毫无头绪，请使用threejs，它是万金油</p>
<p>4、如果您是webgl方面创业公司，正在进行技术选型，请您选择BabylonJS，你要研发自己的模型展示交付平台或者是要研发自己的场景漫游系统，通过BabylonJS引擎、以及他的inspect和编辑器，你可以快速拿出自己的产品，而且产品质量还不低。最后你要做的是业务逻辑开发以及界面美化定制。</p>
<p>目前市面上很多模型展示交付平台，其实它内核部分都没少技术含量，大量是包装过度，如果您用BabylonJS可以快速组装搬运集成，别人一个团队10多个人几年时间，你可以在短短几个开发人员几个月之内追赶上，还可以超越。</p>
<p>下面这家公司使用的就是BabylonJS制作的云展，案例效果不错。</p>
<p><a href="%E2%80%8Bwww.cool360.com/">虚拟博物馆(cool360.com)-官网</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/341360474">查看原文</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】webgl技术风云录之盈利模式]]></title>
    <link href="https://www.bwrong.cn/17280334778925.html"/>
    <updated>2024-10-04T17:17:57+08:00</updated>
    <id>https://www.bwrong.cn/17280334778925.html</id>
    <content type="html"><![CDATA[
<p>作为从事webgl开发的工程师，不得不思考行业的趋势以及同行企业的盈利模式。如果从事游戏开发，不属于此范畴，作者不对游戏行业不够熟悉。目前接触到的webgl很多都是从事展示，更多卖的不是技术本身而是设计，其实就是模型、靠的是三维设计师的能力、赚得是三维设计师的血汗。</p>
<p>当然有些公司依然是靠webgl技术本身赚钱，而不是通过销售设计数据，目前无外乎如下几方面：</p>
<h2><a id="1%E3%80%81%E4%BC%A0%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B1%95%E8%A7%88%E5%85%AC%E5%8F%B8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、传统设计展览公司</h2>
<p>其实很多设计展厅公司都已经上市，他们有固定客户资源、三维设计师对行业专业程度非常高，所以他们通过线下展厅设计施工、加上U3D开发的一些数字互动功能，就可以快速交付项目。对他们来说，webgl意义不大，U3D已经足够，而且是非常好的技术方案，性能好、效果好、VR支持高，因为都是本地部署不要求跨终端浏览器访问。这些公司盈利点也是靠设计、施工、材料来实现利润增长。</p>
<h2><a id="2%E3%80%81720%E4%BA%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、720云</h2>
<p>720云其实满足了很多设计师全景图的快速交付，720云本身不参与数据制作，纯靠技术平台以及全景拍摄硬件来盈利。他能盈利是因为平台本身确实解决了用户痛点，而航拍、户外大场景全景拍摄、全景效果图交付这些需要一个全景展示平台来展示作品，720云经过这些年的沉淀推广，把这一个环节做得非常完善简便，所以它有存在的价值。</p>
<h2><a id="3%E3%80%81%E9%85%B7%E5%AE%B6%E4%B9%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、酷家乐</h2>
<p>酷家乐鼎鼎大名、80亿美金估值，短短几年时间不得不佩服，通过研究它前端代码结构、试用其产品、它的渲染速度、渲染效果都是令人非常满意。它重新定义了室内装修，让繁琐复杂、交付周期长的效果图制作大大缩短，同时降低设计师技术要求，通过模型库、户型图、渲染平台让整个流程一气呵成。webgl技术在它平台算重要的一环，其背后的渲染平台、以及后台架构更加重要，一整套技术成就了这个设计界的霸主。</p>
<h2><a id="4%E3%80%81style3d" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4、style3d</h2>
<p>如果你看见style3d的渲染视频，你会对他柔体建模以及展示佩服不已。三维中刚体最简单、柔体、流体、毛发是非常复杂的几大块，而style3d通过多年垂直领域的沉淀积累、技术打磨，让他成为了服装设计界的明星。它盈利天经地义。</p>
<h2><a id="5%E3%80%81%E5%AE%9D%E7%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5、宝珑</h2>
<p>宝珑珠宝设计，早期用的是flash，而且可以直接decomp其代码，在flash技术体系内，通过shader进行珠宝设计以及展示技术很厉害了。现在他们迎合技术发展趋势，因为flash在很多平台浏览器上支持都慢慢停止，所以他们珠宝设计、展示、定制都迁移到webgl上面，通过threejs进行深度定制来实现。珠宝设计领域，可以去试试他们产品，我有两个珠宝行业朋友，用得就是他们的技术。</p>
<h2><a id="6%E3%80%81matterport%E4%BC%97%E8%B6%A3%E8%B4%9D%E5%A3%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6、matterport &amp; 众趣 &amp;贝壳</h2>
<p>贝壳看房，世界杯轰炸一轮，连我退休的爸妈都知道贝壳看房，而这项技术的引领者应该就是matterport。其实在09年就有人做网上看房，那时候是基于flex，通过全景图或者简单的户型模型来实现，效果太差。matterport把整个体验重新定义，通过硬件线下采集照片以及深度数据，云端进行ai合成户型模型，然后展示端把全景图当纹理贴到户型模型上，让整个体验更加饱满、制作更加简单，而且是照片级1:1还原线下场景。这在看房领域真是福音，因为看房通过纯全景图krpano那种模式效果还是太差，不够身临其境，而matterport这在技术方案彻底解决了这一问题。</p>
<h2><a id="7%E3%80%81%E6%B7%98%E5%AE%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7、淘宝</h2>
<p>阿里在短视频跟直播方面应该没有跟上脚步、直播带货也是后期才追赶，但是三维他肯定不会错过。通过投资躺平设计家、研发ace-tiny、以及今年的几场云展、场景购，已经开始布局整个三维行业，三维对未来购物肯定是非常有意义的，很多商品需要三维才能更加完美展示细节，有些商品通过场景可以提升用户购物欲望。</p>
<p>总之：</p>
<p>可以发现不论什么技术，它必须跟场景结合，必须跟行业结合，必须落地业务逻辑，真正解决特点场景下的某些问题它才有意义。以前大数据，多少投资人血本无归，几千万或者上亿最后只剩下一个没什么人用的看板。如今webgl一样会有很多投资人血本无归，因为光技术本身很难赚钱，除非优化某个行业数据生产方式或者深耕某个行业、跟行业内老玩家联姻，深耕技术沉淀团队方能杀出一条血路。</p>
<p>今年疫情，导致无数个云展公司成立，通过百度推广以及阿里域名查询，就可以发现一大堆公司开始从事这一行业，很多是皮包公司，接单就转包。有些是通过720云直接交付全景图，象征性加入云展厅，因为成本最低。还有很多是传统设计公司，转型卖设计。其实在云展这个行业，卖得不是技术而是设计数据本身。</p>
<p>蝉三维，立足于免费、提供快速模型交付，高效率精简团队可以通过部分软件功能定制、平台定制养活自己，更重要的是技术的不断积累、行业解决方案日益沉淀，最后真正解决特定用户群体切身问题，盈利模式就可以非常清晰。</p>
<p><a href="https://zhuanlan.zhihu.com/p/341414739">查看原文</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转微前端4】qiankun扩展]]></title>
    <link href="https://www.bwrong.cn/17280334440663.html"/>
    <updated>2024-10-04T17:17:24+08:00</updated>
    <id>https://www.bwrong.cn/17280334440663.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>详细流程</h2>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331175532.awebp" alt="image.png" /></p>
<p>简易流程：</p>
<ol>
<li>qiankun 会用 原生fetch方法，请求微应用的 entry 获取微应用资源，然后通过 response.text 把获取内容转为字符串。</li>
<li>将 HTML 字符串传入 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkuitos%2Fimport-html-entry%2Fblob%2F76df4b3737d54112f6bf2dfabcd01709079468e4%2Fsrc%2Fprocess-tpl.js%23L58">processTpl</a> 函数，进行 HTML 模板解析，通过正则匹配 HTML 中对应的 javaScript（内联、外联）、css（内联、外联）、代码注释、entry、ignore 收集并替换，去除 <code>html/head/body</code> 等标签，其他资源保持原样</li>
<li>将收集的 <code>styles</code> 外链URL对象通过 fetch 获取 css，并将 css 内容以 <code>&lt;style&gt;</code> 的方式替换到原来 link标签的位置</li>
<li>收集 script 外链对象，对于异步执行的 JavaScript 资源会打上 <code>async</code> 标识 ，会使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkuitos%2Fimport-html-entry%2Fblob%2F76df4b3737d54112f6bf2dfabcd01709079468e4%2Fsrc%2Findex.js%23L104">requestIdleCallback</a> 方法延迟执行。</li>
<li>接下来会创建一个匿名自执行函数包裹住获取到的 js 字符串，最后通过 eval 去创建一个执行上下文执行 js 代码，通过传入 proxy 改变 window 指向，完成 JavaScript 沙箱隔离。<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkuitos%2Fimport-html-entry%2Fblob%2F76df4b3737d54112f6bf2dfabcd01709079468e4%2Fsrc%2Findex.js%23L45">源码位置</a>。</li>
<li>由于 qiankun 是自执行函数执行微应用的 JavaScript，因此在加载后的微应用中是看不到 JavaScript 资源引用的，只有一个资源被执行替换的标识。</li>
<li>当一切准备就绪的时候，执行微应用的 JavaScript 代码，渲染出微应用</li>
</ol>
<h2><a id="%E6%9E%81%E9%99%90%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>极限应用场景</h2>
<ul>
<li>
<p>与路由绑定的方式渲染微应用</p>
<p>接入这类平台的微应用，通常只需要提供自己的 entry html 地址，并为其分配一个路由规则即可，会根据当前路由自动切换微应用加载。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331164434.jpg" alt="v2-c345f8bf9c8855176037f6b48e315caf_1440w" /></p>
</li>
<li>
<p>以组件的方式使用微应用</p>
<p><video controls height='100%' width='100%' src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331164434.mp4"></video></p>
<p>开发者可以在脱离路由的限制下，以更自由的方式去渲染我们的微应用。</p>
<ul>
<li>嵌套渲染场景</li>
</ul>
<p><video controls height='100%' width='100%' src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331164435.mp4"></video></p>
</li>
<li>
<p>多应用同时渲染：同一时刻可展示多个子应用，子应用更像是一个业务组件而不是应用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331164435.jpg" alt="v2-cc82a2a5a6fbe5c141af9dd5b42622ee_1440w" /></p>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转微前端3】需要关注的问题]]></title>
    <link href="https://www.bwrong.cn/17280334039483.html"/>
    <updated>2024-10-04T17:16:43+08:00</updated>
    <id>https://www.bwrong.cn/17280334039483.html</id>
    <content type="html"><![CDATA[
<p>虽然qiankun已经提供了微前端的一些基本能力，但是在使用过程中还是有很多问题需要关注。</p>
<h2><a id="%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E8%A7%84%E5%88%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目架构规划</h2>
<ul>
<li>Monorepo：多应用管理可以使用<a href="https://lerna.js.org/">lerna</a>或者<a href="https://pnpm.io/zh/">pnpm</a>。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406225207.png" alt="image-20220406225206585" /></p>
<ul>
<li>
<p>Git subtree或者多仓库：在子应用较多的情况可采用此方式，缺点是每次子应用变更后，聚合库还得同步一次变更。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220407165035.jpg" alt="18091274-44952db2fd681a3d" /></p>
</li>
</ul>
<h2><a id="%E5%BA%94%E7%94%A8%E6%8B%86%E5%88%86%E7%B2%92%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用拆分粒度</h2>
<p>微应用的拆与合思考：拆的是系统复杂度，合的是系统复用度。</p>
<p>拆分的时候可以从平台差异、页面结构、产品业务方面考虑。并不是越细越好，业务关联紧密的功能单元应该做成一个微应用，反之关联不紧密的可以考虑拆分成多个微应用。</p>
<h2><a id="%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>样式隔离</h2>
<p>使用qiankun默认的沙箱，仅能确保单实例场景子应用之间的样式隔离，但是无法确保主应用跟子应用、或者多实例场景的子应用样式隔离。目前还没有完美的解决方案，如果遇到样式污染问题，可以考虑如下方案：</p>
<ul>
<li>命名规范+命名空间，可以尝试开启experimentalStyleIsolation（实验阶段）。</li>
<li>ShadowDom：可以开启strictStyleIsolation严格模式，启用ShadowDom，但是这并不是一个可以无脑使用的方案，可能还会有一些其他问题，如子应用的弹窗挂载到body上时样式丢失。</li>
<li>CSS In JS</li>
<li>CSSModule</li>
</ul>
<h2><a id="%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据通信</h2>
<p>应用间尽量避免通信，减少耦合性，如果两个应用间有频繁的通信需求，说明这两个微应用本身就是服务于同一个业务场景，合并成一个微应用可能会更合适。</p>
<p><strong>微前端通信方式：</strong></p>
<ul>
<li><strong>基于 URL</strong>：使用简单、通用性强，但能力较弱，不适用复杂的业务场景。</li>
<li><strong>基于 Props</strong>：最核心的通信能力，能够满足一些简单的场景。适用于主子应用共享组件、公共方法调用等。</li>
<li><strong>GlobalState</strong>：基于发布订阅模式实现，能够满足比较复杂的场景。</li>
<li><strong>本地Storage</strong>：仅适合静态通信场景，且 JSON.stringify()可能会造成数据丢失。</li>
</ul>
<h2><a id="%E6%9D%83%E9%99%90%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>权限处理</h2>
<p>主应用负责身份验证，拿到授权信息后下发到各微应用中，各应用再根据拿到的授权信息过滤各自路由信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331175530.awebp" alt="img" /></p>
<h2><a id="%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>资源共享</h2>
<h3><a id="%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>统一管理维护</h3>
<p>将公共资源提取到一个地方，避免多个地方维护，但是仍然会多次打包。可以通过如下两种方式：</p>
<ul>
<li>file或link方式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220407114412.png" alt="image-20220406235834667" /></p>
<ul>
<li>git仓库或者私服</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406235948.png" alt="image-20220406235948554" /></p>
<h3><a id="%E4%BE%9D%E8%B5%96%E6%8F%90%E5%8F%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>依赖提取</h3>
<p>在一个团队中，技术栈相对固定，所以统一技术栈很多基础依赖相对是固定的，但是默认情况下每个应用都会重复打包一次，会造成重复下载，影响运行性能。例如，如果每个微应用都包括自己的 Vue 副本，那么用户就得多次下载 Vue。</p>
<p>在进行如下改造之前，先确认是否有此必要，因为它会增加应用间的耦合性（如技术栈、依赖版本必须一致） ，而这是和微前端思想相悖的，</p>
<ul>
<li>cdn或者将公共依赖抽离成单独的应用或者文件引用。</li>
<li>由主应用下发（props或者window），需要处理子应用单独运行时依赖的来源问题。</li>
</ul>
<h2><a id="%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>部署与资源路径问题</h2>
<h3><a id="%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>部署方案</h3>
<ul>
<li>主应用和微应用部署到同一个服务器（同一个 IP 和端口）。</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">└── html/                     # 根文件夹
    ├── child/                # 存放所有微应用的文件夹
    |   ├── app1/         
    |   ├── app2/      
    ├── index.html            # 主应用的index.html
    ├── css/                  # 主应用的css文件夹
    ├── js/                   # 主应用的js文件夹
</code></pre>
<pre class="line-numbers"><code class="language-js">registerMicroApps([
  {
    name: 'app1',
    entry: '/child/app1/', // http://localhost:8080/child/app1/
    container: '#container',
    activeRule: '/child-app1',
  },
  {
    name: 'app2',
    entry: '/child/app2/', // http://localhost:8080/child/app2/
    container: '#container',
    activeRule: '/child-app2',
  }
],
</code></pre>
<ul>
<li>主应用和微应用部署在不同的服务器，使用 Nginx 代理访问。</li>
</ul>
<pre class="line-numbers"><code class="language-nginx">/app1/ {
  proxy_pass http://www.b.com/app1/;
  proxy_set_header Host $host:$server_port;
}
</code></pre>
<pre class="line-numbers"><code class="language-js">registerMicroApps([
  {
    name: 'app1',
    entry: '/app1/', // http://localhost:8080/app1/
    container: '#container',
    activeRule: '/child-app1',
  },
],
</code></pre>
<h3><a id="%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>资源路径错误</h3>
<p>在src代码中引用public资源会有问题，资源尽量放到src中，让webpack处理，注入publicPath。</p>
<pre class="line-numbers"><code class="language-vue">&lt;template&gt;
  &lt;img src=&quot;../../assets/images/logo.png&quot; alt=&quot;&quot;&gt;
  &lt;div class=&quot;img-test&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;img-test2 test&quot; :style=&quot;`background:url(${require('../../assets/images/logo.png')})`&quot;&gt;&lt;/div&gt;
	&lt;!-- 路径错误 --&gt;
  &lt;img src=&quot;/logo.png&quot; class=&quot;test&quot; alt=&quot;&quot;&gt;
&lt;/template&gt;
&lt;style scoped&gt;
  .img-test{
    background: url('../../assets/images/logo.png') no-repeat;
    background-size: 100% 100%;
    width: 100px;
    height: 100px;
  }
&lt;/style&gt;
</code></pre>
<h2><a id="%E5%BA%94%E7%94%A8%E4%B9%8B%E9%97%B4%E8%B7%B3%E8%BD%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用之间跳转</h2>
<p>在微应用中如果要进行应用间跳转，不能直接使用微应用的router，可以有如下几种方式：</p>
<ul>
<li>将跳转动作上抛给主应用，由主应用进行切换。</li>
<li>将主应用router下发到微应用，微应用使用该router进行跳转动作。</li>
<li>使用原生方法改变url（不建议，会造成页面刷新）。</li>
</ul>
<h2><a id="%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他问题</h2>
<ul>
<li>VueDevtools调试微应用问题，需要手动处理，但是还是会存在失效问题。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220407171516.png" alt="image-20220407171516398" /></p>
<ul>
<li>对vite构建的微应用支持还有缺陷，因为Vite暂时还不支持运行时修改资源路径和ESModule导致沙箱失效。</li>
<li>各应用间的风格和交互逻辑应该统一，因为对用户来说我们的应用仍然是一体的，要避免应用间给用户造成撕裂感。</li>
<li>运行差异性处理：如果微应用需要单独运行，需要考虑集成运行和单独运行的差异性，做一些hack兼容处理。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转微前端2】聊聊qiankun]]></title>
    <link href="https://www.bwrong.cn/17280333553222.html"/>
    <updated>2024-10-04T17:15:55+08:00</updated>
    <id>https://www.bwrong.cn/17280333553222.html</id>
    <content type="html"><![CDATA[
<p>关于如何使用qiankun，官方文档比较完善，网上文档也较多，所以这里就不再赘述。接下来我们就来看一下目前文档中缺失的部分<a href="https://qiankun.umijs.org/zh/guide#%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">它是如何工作的</a>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331175520.awebp" alt="image.png" /></p>
<h2><a id="%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运行流程</h2>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714da36c103427a~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="qiankun" /></p>
<h2><a id="%E6%A0%B8%E5%BF%83api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>核心API</h2>
<p><code>registerMicroApps</code>和<code>start</code>是qiankun两个核心的API。</p>
<p><code>registerMicroApps</code> 函数的作用是注册子应用，并且在子应用激活时，创建运行沙箱，在不同阶段调用不同的生命周期钩子函数。<code>start</code> 函数负责初始化一些全局设置，然后启动应用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406165052.awebp" alt="qiankun" /></p>
<h2><a id="%E6%B2%99%E7%AE%B1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>沙箱</h2>
<p>qiankun的沙箱环境可以分为三类，主要通过运行环境是否支持Proxy和是否是单实例进行区分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406165518.awebp" alt="qiankun" /></p>
<h3><a id="legacysandbox" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LegacySandbox</h3>
<p>LegacySandbox用于支持Proxy的单实例环境下，沙箱隔离是通过快照模式实现，在激活沙箱时还原子应用状态，卸载时还原主应用状态（子应用挂载前的全局状态）实现的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406170227.awebp" alt="qiankun" /></p>
<ul>
<li>当调用 <code>set</code> 向子应用 <code>proxy/window</code> 对象设置属性时，所有的属性设置和更新都会先记录在 <code>addedPropsMapInSandbox</code> 或 <code>modifiedPropsOriginalValueMapInSandbox</code> 中，然后统一记录到 <code>currentUpdatedPropsValueMap</code> 中。</li>
<li>在激活沙箱时，沙箱会通过 <code>currentUpdatedPropsValueMap</code> 查询到子应用的独立状态池（沙箱可能会激活多次，这里是沙箱曾经激活期间被修改的全局变量），然后还原子应用状态。</li>
<li>在关闭沙箱时，通过 <code>addedPropsMapInSandbox</code> 删除在沙箱运行期间新增的全局变量，通过 <code>modifiedPropsOriginalValueMapInSandbox</code> 还原沙箱运行期间被修改的全局变量，从而还原到子应用挂载前的状态。</li>
</ul>
<p>该方案使用diff算法还原window状态快照，因为使用的是同一个window，所以不能在多实例时使用，而且父子应用之间window对象还是会存在污染。</p>
<h3><a id="proxysandbox" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ProxySandbox</h3>
<p>ProxySandbox用于支持Proxy的多实例环境下，它利用Proxy实现对微应用全局对象操作的拦截，子应用对全局属性的操作就是对该 <code>proxy</code> 对象属性的操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406170830.awebp" alt="qiankun" /></p>
<ul>
<li>当调用 <code>set</code> 向子应用 <code>proxy/window</code> 对象设置属性时，所有的属性设置和更新都会命中 <code>updateValueMap</code>，存储在 <code>updateValueMap</code> 集合中，从而避免对 <code>window</code> 对象产生影响。</li>
<li>当调用 <code>get</code> 从子应用 <code>proxy/window</code> 对象取值时，会优先从子应用的沙箱状态池 <code>updateValueMap</code> 中取值，如果没有命中才从主应用的 <code>window</code> 对象中取值。</li>
</ul>
<p><code>ProxySandbox</code> 是最完备的沙箱模式，完全隔离了对 <code>window</code> 对象的操作，在浏览器对Proxy兼容性兼容的情况下，算是最优的方案。</p>
<h3><a id="snapshotsandbox" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SnapshotSandbox</h3>
<p>在浏览器不支持Proxy时，会回退到SnapshotSandbox沙箱，作为兜底方案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406172205.awebp" alt="qiankun" /></p>
<ul>
<li>在沙箱激活时，会先给当前 <code>window</code> 对象打一个快照，记录沙箱激活前的状态。打完快照后，函数内部将 <code>window</code> 状态通过 <code>modifyPropsMap</code> 记录还原到上次的沙箱运行环境，也就是还原沙箱激活期间（历史记录）修改过的 <code>window</code> 属性。</li>
<li>在沙箱关闭时，调用 <code>inactive</code> 函数，在沙箱关闭前通过遍历比较每一个属性，将被改变的 <code>window</code> 对象属性值记录在 <code>modifyPropsMap</code> 集合中。在记录了 <code>modifyPropsMap</code> 后，将 <code>window</code> 对象通过快照 <code>windowSnapshot</code> 还原到被沙箱激活前的状态，相当于是将子应用运行期间对 <code>window</code> 造成的污染全部清除。</li>
</ul>
<p>作为兜底方案，相比较 <code>ProxySandbox</code> 而言，在子应用激活期间，<code>SnapshotSandbox</code> 将会对 <code>window</code> 对象造成污染。</p>
<p>以上就是qiankun一些比较关键的东西，接下来就分享一下在使用的过程中需要关注的一些问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转微前端1】如何做技术选型]]></title>
    <link href="https://www.bwrong.cn/17280333095797.html"/>
    <updated>2024-10-04T17:15:09+08:00</updated>
    <id>https://www.bwrong.cn/17280333095797.html</id>
    <content type="html"><![CDATA[
<p>当前市面上已出现了很多微前端方案，如何做出正确的选择是一件不容易的事情。</p>
<p>在开始介绍这些方案之前，我们有必要先了解一下微前端架构的核心原则，从而更好的去衡量微前端方案是否成熟。</p>
<h2><a id="%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>核心原则</h2>
<h3><a id="%E5%BA%94%E7%94%A8%E7%8B%AC%E7%AB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用独立</h3>
<p>这里说的独立包含三个方面：</p>
<ul>
<li>独立开发：每个微应用由不同业务团队开发，实现团队自治。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331172854.png" alt="image-20220331172853831" /></p>
<ul>
<li>独立部署：微应用可独立部署运行，每个应用可以有自己的交付部署流程，某个微应用出现故障不影响其他应用。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331173032.png" alt="image-20220331173031824" /></p>
<ul>
<li>独立运行：既可以组合运行，也可以单独运行，运行时环境隔离，提供JavaScript沙箱，CSS 样式隔离，避免应用间运行时污染。</li>
</ul>
<h3><a id="%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息通信</h3>
<p>完善的通信机制，可以降低主应用和微应用、微应用和微应用之间的数据共享难度，是否有完善的通信机制是选型考量的一个关键因素。</p>
<h3><a id="%E6%8A%80%E6%9C%AF%E6%A0%88%E6%97%A0%E5%85%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>技术栈无关</h3>
<p>主应用不限制子应用接入的技术栈。不限制技术栈有如下好处：</p>
<ul>
<li>每个应用可以结合团队情况选择不同的技术栈，也可以集成一些采用了不同技术栈的老旧项目。</li>
<li>应用技术栈切换升级不影响其他应用，可以实现增量升级。通常我们很难对一个已有的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略。</li>
</ul>
<h3><a id="%E4%BE%9D%E8%B5%96%E5%A4%8D%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>依赖复用</h3>
<p>解决各应用间依赖、公共逻辑需要重复维护的问题。应用间相同的依赖需要重复下载。</p>
<h2><a id="%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方案对比</h2>
<p>接下来，我们从四大流派来看一下当下有哪些方案可以选择，并简单做个对比：</p>
<h3><a id="%E4%BC%A0%E7%BB%9F%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>传统式</h3>
<h4><a id="1%E8%B7%AF%E7%94%B1%E5%88%86%E5%8F%91%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 路由分发（服务端）</h4>
<p><strong>描述：</strong> 在HTTP服务器通过反向代理将不同的路由分发到对应的应用上。</p>
<pre class="line-numbers"><code class="language-nginx">http {
  server {
    listen       80;
    server_name  www.phodal.com;
    location /api/ {
      proxy_pass http://http://172.31.25.15:8000/api;
    }
    location /web/admin {
      proxy_pass http://172.31.25.29/web/admin;
    }
    location /web/notifications {
      proxy_pass http://172.31.25.27/web/notifications;
    }
    location / {
      proxy_pass /;
    }
  }
}
</code></pre>
<p><strong>优点：</strong> 简单、快速、易配置。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>应用是完全分开的，通信和数据资源共享很困难；</li>
<li>切换应用需要刷新页面，体验不好；</li>
<li>完全是基于路由的，无法同时加载多个应用。</li>
</ul>
<h4><a id="2-iframe" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. IFrame</h4>
<p><strong>描述：</strong> 将微应用通过iframe载入。</p>
<p>**优点：**接入简单，兼容性好，原生支持沙箱隔离。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>隔离性无法突破，应用间上下文无法共享，比如在子应用弹窗问题（只能基于子应用可视区定位，不能基于整个页面定位）。</li>
<li>应用间通信需要自行实现一套基于postMessage的通信机制。</li>
<li>刷新会导致iframe Url状态丢失，iframe 和主页面共用一个浏览历史，后退前进按钮无法使用。</li>
</ul>
<h3><a id="%E8%87%AA%E7%BB%84%E7%BB%87%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自组织式</h3>
<h4><a id="3-npm%E9%9B%86%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Npm集成</h4>
<p><strong>描述：</strong> 将微应用抽离成包的方式，发布到Npm中，再在主应用中将这些微应用作为依赖项，构建时候集成进项目中。</p>
<p><strong>优点：</strong> 开发与接入成本低，容易理解。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>影响主应用编译速度和打包后的体积。</li>
<li>不支持动态更新，npm包更新后，需要重新更新包，主应用需要重新发布部署。</li>
<li>因为业务应用不能发布到公开库，需要自己搭建npm私有库，提高了工程难度。</li>
</ul>
<h4><a id="4-js%E9%9B%86%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. JS集成</h4>
<p>**描述：**每个微应用提供一个入口js，会导出一个全局变量，主应用引入该js，安装应用时调用相关函数，挂载渲染微应用。</p>
<p>**优点：**相比Npm集成方案，优化的地方是微应用不用构建到主应用中，而是独立构建的。</p>
<p><strong>缺点：</strong> 规范、通信、沙箱都需要自己实现，依赖开发人员设计能力。</p>
<pre class="line-numbers"><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Feed me!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome to Feed me!&lt;/h1&gt;

    &lt;!-- 这些脚本不会马上渲染应用 --&gt;
    &lt;!-- 而是分别暴露全局变量 --&gt;
    &lt;script src=&quot;https://browse.example.com/bundle.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://order.example.com/bundle.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://profile.example.com/bundle.js&quot;&gt;&lt;/script&gt;

    &lt;div id=&quot;micro-frontend-root&quot;&gt;&lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
      // 这些全局函数是上面脚本暴露的
      const microFrontendsByRoute = {
        '/': window.renderBrowseRestaurants,
        '/order-food': window.renderOrderFood,
        '/user-profile': window.renderUserProfile,
      };
      const renderFunction = microFrontendsByRoute[window.location.pathname];

      // 渲染第一个微应用
      renderFunction('micro-frontend-root');
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3><a id="%E5%BE%AE%E4%BB%B6%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>微件式</h3>
<h4><a id="5-web-component" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. Web Component</h4>
<p>**描述：**微应用导出的是一个自定义元素（Web Component），加载微应用时渲染对应的元素即可。</p>
<p>**优点：**浏览器自带能力，接入简单，自带Shadow DOM沙箱。</p>
<p>**缺点：**兼容性不太好，暂时只有较新的浏览器支持，但未来可期。</p>
<h4><a id="6-microapp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6. MicroApp</h4>
<p><strong>描述：</strong> [MicroApp](<a href="https://cangdu.org/micro-app/%E6%98%AF%E4%BA%AC%E4%B8%9C%E9%9B%B6%E5%94%AE%E6%8E%A8%E5%87%BA%E7%9A%84%E4%B8%80%E6%AC%BE%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%98%AF%E5%9F%BA%E4%BA%8EWebComponent%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E6%9E%84%E5%BB%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E7%9A%84%E6%9E%81%E7%AE%80%E6%96%B9%E6%A1%88%E3%80%82">https://cangdu.org/micro-app/是京东零售推出的一款微前端框架，是基于WebComponent实现的一种用于构建微前端应用的极简方案。</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220401104503.png" alt="d879637b4bb34253" /></p>
<p>**优点：**接入成本很低，只需一行代码即可实现微前端，提供了<code>js沙箱</code>、<code>样式隔离</code>、<code>元素隔离</code>、<code>预加载</code>、<code>数据通信</code>、<code>静态资源补全</code>等一系列完善的功能。</p>
<p>**缺点：**依赖于CustomElements和Proxy两个较新的API，兼容性需要考虑。</p>
<h4><a id="7-emp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7. EMP</h4>
<p><strong>描述：</strong> <a href="https://emp2.netlify.app/">EMP</a>由欢聚时代（YY）自主研发的单页微前端解决方案，主要基于Webpack5的新特性Module Federation实现。</p>
<p>**优点：**强调去中心化，每个微应用都可以引入其他的微应用，无中心应用（容器/主应用）的概念。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>接入有一定成本，不同技术栈接入有一定难度；</li>
<li>因为使用了Module Federation，所以仅支持webpack5+构建的应用。</li>
</ul>
<h3><a id="%E5%9F%BA%E5%BA%A7%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基座式</h3>
<h4><a id="7-single-spa" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7. Single-spa</h4>
<p><strong>描述：</strong><a href="https://zh-hans.single-spa.js.org/">Single-spa</a>在上面的js集成方案，加入了生命周期，算是比较老牌的微前端框架了。</p>
<p>**优点：**支持生命周期和代码延迟加载。</p>
<p>**缺点：沙箱环境需要自行处理，有一定的侵入性。</p>
<h4><a id="8-qiankun" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>8. qiankun</h4>
<p><strong>描述：</strong><a href="https://qiankun.umijs.org/zh/">qiankun</a>由蚂蚁团队基于single-spa构建的微前端解决方案，功能比较完善，已有多个成功应用案例验证，是目前应用最多的微前端框架。</p>
<p><img src="https://pic2.zhimg.com/80/v2-d55549366b52cde19c93835cfa2a58c9_1440w.jpg" alt="v2-d55549366b52cde19c93835cfa2a58c9_1440w" /></p>
<p><strong>优点：</strong></p>
<ul>
<li>接入成本相对较低，框架本身已包含构建微前端系统时所需要的基本能力。</li>
<li>微应用入口支持多种方式。</li>
</ul>
<p>**缺点：**没有提供依赖复用，需要自行解决。</p>
<h4><a id="9-icestark" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>9.  icestark</h4>
<p><strong>描述：</strong> <a href="https://micro-frontends.ice.work/">icestark</a>是阿里飞冰出品的面向大型系统的微前端解决方案。</p>
<p>**优点：**相比qiankun，支持微模块，一种粒度更小的挂件，可以随处挂载。</p>
<p>**缺点：**样式隔离问题目前还只能靠规范来规避，Shadow DOM方案还在实验中。</p>
<h4><a id="10-garfish" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>10. Garfish</h4>
<p><strong>描述：</strong><a href="https://garfish.top/">Garfish</a>是字节跳动出品，包含构建微前端系统时所需要的基本能力。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220406160138.png" alt="image.png" /></p>
<p>**优点：**api简单，接入成本低，自带依赖共享api，支持插件扩展。</p>
<h2><a id="%E8%B7%AF%E5%9C%A8%E4%BD%95%E6%96%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>路在何方</h2>
<p>可以看到，在上述方案中，比较成熟的方案有MicroApp、EMP、qiankun、Garfish。当下微前端相应的解决方案其实挺多的，但是并不存在银弹，每一个方案都有优缺点，只有结合实际需求进行选择最合适的那个方案就行。</p>
<p>当然除了前面说的几个微前端的核心原则，一般在选型时，我们还注意如下几个纬度：</p>
<table>
<thead>
<tr>
<th>纬度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>稳定性</td>
<td>该方案是否经历了社区的考验，有较多的成熟案例，同时保持较高的活跃性，有完善的文档。</td>
</tr>
<tr>
<td>可拓展性</td>
<td>支持定制化开发，提供较高的可拓展能力，同时成本可以在接受范围内</td>
</tr>
<tr>
<td>可控性</td>
<td>发生问题后，能够在第一时间内进行问题排查，以最快的响应速度来处理问题，修复的方案是否会依赖于外部环境</td>
</tr>
<tr>
<td>低成本</td>
<td>学习成本和项目接入改造成本是一个很重要的考量因素，成本太高会适得其反。</td>
</tr>
</tbody>
</table>
<p>所以，结合上述和项目的一些因素，当时我们最终选择了qiankun。接下来我们就聊一聊qiankun。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转微前端0】微前端是什么]]></title>
    <link href="https://www.bwrong.cn/17280332492564.html"/>
    <updated>2024-10-04T17:14:09+08:00</updated>
    <id>https://www.bwrong.cn/17280332492564.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%9B%B0%E5%B1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>困局</h2>
<p>在开始前，我们先来看看传统架构方式的一个发展历程：</p>
<p><img src="https://swearer23.github.io/micro-frontends/ressources/diagrams/organisational/monolith-frontback-microservices.png" alt="Monolithic Frontends" /></p>
<p>可以归纳为三个阶段：</p>
<ol>
<li>前后端一体</li>
<li>前后端分离，单体应用</li>
<li>前后端分离，后端微服务化</li>
</ol>
<p>在前后端进行分离后，后端仅负责数据处理工作，前端的职责开始扩张。同时前端技术的发展也促使前端应用的复杂度不断提升。这时，传统的单体架构在大型应用中就稍显乏力了，尤其是中后台项目，时间跨度长，很容易就演变成巨石应用，越来越难以维护。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331161639.png" alt="aba723dd5766a90fca78309da0dc980893221" /></p>
<p>举例: 一个持续多年的应用，经历几年的业务的更新迭代，当项目发展到一定程度的时候就会遇到以下问题</p>
<ol>
<li>业务模块之间不断的堆叠，交错引用，业务耦合如何治理？</li>
<li>老技术、老代码不敢动，新技术、新架构又想用？</li>
<li>万年技术债？既要跟随业务敏捷迭代，又要保证代码库向好发展，旧的框架类库如何平稳升级？</li>
<li>一个项目多个团队开发，你冲突我，我冲突你，如何解决并行开发的冲突？</li>
<li>代码库持续膨胀，难以维护的项目代码，是屎上雕花？还是从头再来？</li>
</ol>
<p>你们的项目是否有上述这些情况呢？我们该如何解决这些问题呢？</p>
<h2><a id="%E7%A0%B4%E5%B1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>破局</h2>
<p>“微前端”这个词首次出现是在2016年 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.thoughtworks.com%2Fradar%2Ftechniques%2Fmicro-frontends">ThoughtWorks Technology Radar</a> 中，但是直到最近几年才被频频提及，那么它是破局之法吗？</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331093221.png" alt="radar" /></p>
<p>微前端源自微服务这种服务端的技术范式，微服务的核心关键在于服务的抽象，用于解决服务端高并发、高可用等问题。而微前端和微服务不尽相同，微前端是一种多个团队通过独立发布的方式来共同构建现代化 web 应用的技术手段及方法。微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用后，随之而来的工程膨胀、开发维护困难等问题。</p>
<p>微前端背后的思想是认为：现代复杂的web应用，通常由很多 <strong>相对独立的功能模块组合而成</strong>，而对这些模块负责的可能是 <strong>相互独立的多个团队</strong>。这些独立的团队由于专业分工不同，会负责着 <strong>特定的业务领域</strong>，以及完成 <strong>特定的开发任务</strong>。这样的团队，通常在人员组成方面囊括了从前端开发到服务端开发，从UI实现到数据库设计这样 <strong>端到端</strong> 的 <strong>跨职能人员</strong> 构成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20220331163236.png" alt="End-To-End Teams with Micro Frontends" /></p>
<p>然而微前端这个概念并不新鲜。它实际上与 <a href="http://scs-architecture.org/">自包含系统</a> 概念一脉相承。在过去，微前端之类的思路，会被称为 <a href="https://dev.otto.de/2014/07/29/scaling-with-microservices-and-vertical-decomposition/">面向垂直划分系统的前端集成</a>。称之为微前端，是因为这个词，对于前端开发人员来说更加易于理解。</p>
<p><strong>定义：微前端并不是指某一具体的技术，而是一种整合了技术、策略和方法的宏观架构方案，是一种将多个可独立交付的小型前端应用聚合为一个整体的架构风格。</strong></p>
<h2><a id="%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用场景</h2>
<p>目前来说，微前端并不是一个无脑使用的架构方案，相比现行的架构方案，还是会带来一些工程复杂度的提升。那么什么场景下可以考虑使用微前端呢？</p>
<h3><a id="1%E5%A4%8D%E7%94%A8%E5%88%AB%E7%9A%84%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%A1%B5%E9%9D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 复用别的的项目页面</h3>
<p>在新项目中需要集成一些其他已开发好的项目时，或者直接复用已有的一些功能模块时，常规的方案就是把代码直接拷贝过来，但是会有一些问题：</p>
<ul>
<li>技术栈不一致，依赖版本不一致，等等问题需要做处理。</li>
<li>更新比较麻烦，别人代码更新，我们需要去做同步。</li>
</ul>
<h3><a id="2%E5%B7%A8%E6%97%A0%E9%9C%B8%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%87%AA%E7%94%B1%E6%8B%86%E5%88%86%E7%BB%84%E5%90%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 巨无霸项目的自由拆分组合</h3>
<p>一个功能齐全的大型项目，在开发维护时面临到如下问题：</p>
<ul>
<li>代码越来越多，打包越来越慢，部署升级麻烦，一些插件的升级和公共组件的修改需要考虑的更多，很容易牵一发而动全身</li>
<li>项目太大，参与人员越多，代码规范比较难管理，代码冲突也频繁。</li>
<li>产品功能齐全，但是客户往往只需要其中的部分功能。剥离不需要的代码后，需要独立制定版本，独立维护，增加人力成本。</li>
</ul>
<p>当你遇到如上两种情况，那么你可以考虑接入微前端。</p>
<p>想了解微前端更多的信息请查阅<a href="https://swearer23.github.io/micro-frontends/">micro-frontends</a>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】以反战为名，百万周下载量node-ipc包作者进行供应链投毒]]></title>
    <link href="https://www.bwrong.cn/17280332063046.html"/>
    <updated>2024-10-04T17:13:26+08:00</updated>
    <id>https://www.bwrong.cn/17280332063046.html</id>
    <content type="html"><![CDATA[
<p>以反战为名的供应链投毒？</p>
<p>开始有人以为只是个恶作剧，但事情并非如此简单。有开发者在对代码进行测试处理后发现，node-ipc 包的作者 RIAEvangelist 在投毒。他起初提交的是一段恶意攻击代码：如果主机的 IP 地址来自俄罗斯或白俄罗斯，该代码将对其文件进行攻击，将文件全部替换成 ❤。该作者是个反战人士，还特意新建了一个 peacenotwar 仓库来宣传他的反战理念。</p>
<p><img src="media/17280332063046/17280339240592.jpg" alt="" /></p>
<p>虽然作者删除了该段代码，但贺师俊认为这仍然是一种恶劣的供应链投毒。“这里，具体的动机不重要，无论其动机多么良好（更不用说，很多人可能并不同意其政治倾向和道德立场），这样的行为都严重破坏了开源生态中的信任。”</p>
<p>OpenHarmony 项目群工作委员会执行总监、中国科学院软件研究所高级工程师罗未也表示，开源软件供应链安全是一个及其严酷的议题，如果说 log4j 还能看做难以避免的工程误差，这件事就存在违法嫌疑。</p>
<p>有开发者提供了该问题的解决方式：首先按照 readme 正常 install，构建结束后，用编辑器全局搜索'peacenotwar'，将其全部删除；然后在项目的 node_models 目录下，将'peacenotwar'目录删除；之后将'项目 /node_modules/node-ipc/node-ipc.js'这个文件中引用'peacenotwar'的代码注释掉，便可以正常启动项目。</p>
<p>此外，Vue-cli 昨天发布了 新版本5.0.2 （<a href="https://github.com/vuejs/vue-cli/blob/dev/CHANGELOG.md%EF%BC%89%EF%BC%8C%E5%B0%86">https://github.com/vuejs/vue-cli/blob/dev/CHANGELOG.md），将</a> node-ipc 版本锁定到 v9.2.1，用户可以直接升级。据悉，受恶意代码受影响的 node-ipc 版本为 v10.1.3 ，已经被作者删除或被 NPM 撤下，而 WITH-LOVE-FROM-AMERICA.txt 文件是由 v11.0.0 版本引入的。</p>
<p>在此次事件中，有开发者认为 （<a href="https://github.com/vuejs/vue-cli/issues/7054%EF%BC%89Vue">https://github.com/vuejs/vue-cli/issues/7054）Vue</a> 团队在发布新版本方面做得还不够，Vue 团队应该在官方网站上添加关于该事件的弹出窗口，弃用所有受感染的 vue-cli 包，为其添加一条消息。另外还可以在发布新版本时添加一些警告，以便用户看到警告并自动升级。</p>
<p>脆弱的 Node.js 生态</p>
<p>这一事件再次显示了 JS/Node/NPM 生态的脆弱。</p>
<p>去年 10 月，NPM 官方仓库 ua-parser-js 被恶意劫持，多个版本被植入了挖矿脚本。这个库每周下载数百万次，被用于一千多个项目，包括 Facebook、微软、亚马逊、Instagram、谷歌、Slack、Mozilla、Discord、Elastic、Intuit、Reddit 等公司的项目。同年 2 月，NPM 遭遇供应链投毒攻击，其官方仓库被上传了 radar-cms 恶意包，借此窃取 K8s 集群凭证。</p>
<p>NPM 模块备受开发人员欢迎，这些模块间还普遍存在复杂的依赖关系，某个包通常安装另一个包作为依赖项，而开发人员对此却并不知情。依赖项的绝对数量也带来了更多的安全问题。只要破坏了开发人员普遍使用的流行包，恶意代码可以直接大规模地传播给受害者，而这完全可以通过依赖混淆、劫持弱凭据、利用漏洞访问目标代码或使用开发人员放弃的包的名称来完成。</p>
<p>另外，NPM 存储库 npmjs.com 不要求 NPM 包中的代码与链接的 GitHub 存储库中的代码相同。这意味着攻击者不需要破坏 GitHub 存储库，只要破坏 NPM 包即可。</p>
<p>贺师俊在知乎上表示，要解决或缓解这一问题，应该考虑在 JS 语言和 JS 运行时层面引入一些机制，比如说针对包级别的权限管理（deno 那样粗粒度的应用级别的权限管理并不足以解决供应链投毒问题）、在更多的 API 中引入类似 TrustedType 的机制等。“而这显然已经超出了库、框架或工程管控的层面。这也是为什么我一直说国内头部大厂应该要投入资源去参与语言标准、引擎和平台实现。”</p>
<p>罗未提出，开源软件可参照其他行业的处理方式，如建筑设计师要终生为建筑设计质量担责、银行批贷员要终生为发放的贷款担责等。</p>
<p>“开源软件，特别是重要的核心开源软件，往往远比一笔贷款或一个建筑对全球社会经济影响深远。开源软件作为一个具有风险的重型工程行业，必须匹配的行业风险管控体系，这是我们不得不面对的问题。”</p>
<p>结束语</p>
<p>“看一遍开源协议，要么 fork 要么忍着。”有开发人员对该事件评论道。前有 Node、React、pytorch、GitHub 等官网声明支援乌克兰，后有个人开发者进行供应链投毒，战争让大家对开源有了不同以往的认识。</p>
<p>开源组织应不应该旗帜鲜明地表达自己技术之外的立场，并利用自身影响力去支持某一方呢？这是一个仁者见仁、智者见智的问题，我们不做赘述。但这个问题实实在在地出现了，就成了整个开源行业应该考虑的问题：当开源开始“站队”时，开发者该如何自处？</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】既要低头前行，也要仰望星空]]></title>
    <link href="https://www.bwrong.cn/17280331672522.html"/>
    <updated>2024-10-04T17:12:47+08:00</updated>
    <id>https://www.bwrong.cn/17280331672522.html</id>
    <content type="html"><![CDATA[
<p>记得小时候农忙时节，农村农活非常多，放学回家自己弄好饭吃，和兄弟姐妹们自觉的就背着背篓上山了，扎进山里，整块地都被爸妈给收拾了一半了。但是剩下的还很多，一不注意天就暗下来，踏着月光和星辰，走在回家的路上。小时候总喜欢抬头望着星空，然后问爸爸，为什么天上会有这么多的星星？爸爸总是意味深长的说，星星是为了照亮你回家的路，低头看好你脚下的路。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/15440860-587c2f1664c6d980.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/874/format/webp" alt="img" /></p>
<p>长大后，脚下的路，越走越长，一路奋进，不停地奔走，忘了拐过多少弯，越过多少坎，停下来，才发现如迷失的登山者一样，面对茫茫的大山，却不知何去何从。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/15440860-672a2d00a1f6feff.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/874/format/webp" alt="img" /></p>
<p>低头走路，已经有多久，没再抬头仰望星空了。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/15440860-c58f858482120588.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/874/format/webp" alt="img" /></p>
<p>​    为了更好的生活，我们努力的前行，低头苦干，为生活疲于奔命。逐渐的迷失自我，有人活成了蚂蚁，终日埋头，低头苦干，忙碌奔波，不知明天在何处，也不问明天去何方；有人活得像老鼠，整天偷偷摸摸的，不务正业，只知道上蹿下跳，四处钻山打洞，，而他们心中可能都驻着一个遥不可及的梦。只有在夜晚，梦中才能和梦想对话。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/15440860-4ce049c50fe02fbc.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/874/format/webp" alt="img" /></p>
<p>三毛在《梦里花落知多少》一书中提到老师布置了一个作业题目，叫做《我的志愿》，三毛写道：</p>
<p>我有一天长大了，希望做一个拾破烂的人，因为这种职业，不但可以呼吸新鲜的空气，同时又可以大街小巷的游走玩耍，一面工作一面游戏，自由快乐得如同天上的飞鸟。更重要的是，人们常常不知不觉的将许多还可以利用的好东西当作垃圾丢掉，拾破烂的人最愉快的时刻就是将这些蒙尘的好东西再度发掘出来，这……</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/15440860-114af483225924d3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/874/format/webp" alt="img" /></p>
<p>这个梦想近似荒唐，惹得老师大怒，结果重写了很多遍都不满意。但是当我们将时光轴拉长，纵观三毛的一生，何尝不是一个追梦的过程呢。求学西班牙，流浪撒哈拉，环游全世界，自由快乐得如同天上的飞鸟；而所到之处，都是拾荒之旅，比如荷西给三毛的定情信物是沙漠里捡来的骆驼骨。沙漠之家的家具是别人拉棺材丢弃的木料。而更多的物件和宝贝都是在地摊及自然中寻到的。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/15440860-b9a9897f860d968f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/874/format/webp" alt="img" /></p>
<p>曾今我也有和三毛一样的想法，不想被一栋楼，一间办公室，一个方格子困住自己的人生，也想呼吸新鲜的空气，自由快乐得如天上的飞鸟。只是走在路上时，满以为已经找到了自己的路，不曾想又进入了另一个围城。困守于一地如笼中之鸟，勾心斗角如上演宫廷剧，一片混乱自己又无权解决。低头苦干却看不到价值和意义。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/15440860-76a884570f4715ec.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/874/format/webp" alt="img" /></p>
<p>​    在夜深人静时，抬头仰望星空，才再一次认识自己，回想起爸爸说过的话，星星是为了照亮你回家的路。灵魂深处，找到最初的自我，才不会迷路。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/15440860-59989d9c74fd0482.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/874/format/webp" alt="img" /></p>
<p>原文链接：<a href="https://www.jianshu.com/p/a32251b42b86">https://www.jianshu.com/p/a32251b42b86</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前端开发规范参考]]></title>
    <link href="https://www.bwrong.cn/17280331339857.html"/>
    <updated>2024-10-04T17:12:13+08:00</updated>
    <id>https://www.bwrong.cn/17280331339857.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开发规范</h2>
<h3><a id="%E5%A4%A7%E5%8E%82%E8%A7%84%E8%8C%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>大厂规范</h3>
<ul>
<li><a href="https://guide.aotu.io/">凹凸实验室</a></li>
<li><a href="https://tgideas.qq.com/doc/index.html">腾讯</a></li>
<li><a href="http://nec.netease.com/">网易</a></li>
<li><a href="https://codeguide.bootcss.com/">Bootstrap</a></li>
<li><a href="https://juejin.cn/post/6893891476913291278">推荐几个大厂的前端代码规范，学会了，你也能写出诗一样的代码</a></li>
</ul>
<h3><a id="js" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JS</h3>
<ul>
<li><a href="https://standardjs.com/rules-zhcn.html">Standard</a></li>
<li><a href="https://standardjs.com/rules-zhcn.html">standard</a></li>
<li><a href="https://juejin.cn/post/6844903921412997127">前端代码规范 — JavaScript 风格指南</a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/style">ES6编程风格</a></li>
</ul>
<h3><a id="vue" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vue</h3>
<ul>
<li><a href="https://cn.vuejs.org/v2/style-guide/">vuejs 风格指南</a></li>
<li><a href="https://juejin.cn/post/6844903593896574990">Vue前端开发规范</a></li>
<li><a href="https://pablohpsilva.github.io/vuejs-component-style-guide/#/chinese">Vue.js 组件编码规范</a></li>
</ul>
<h3><a id="%E5%91%BD%E5%90%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>命名</h3>
<ul>
<li><a href="https://juejin.cn/post/6922225108094287880">编写高质量可维护的代码：优雅命名</a></li>
<li><a href="https://juejin.cn/post/6844903593896574990">Vue前端开发规范</a></li>
</ul>
<h2><a id="%E5%8D%8F%E4%BD%9C%E8%A7%84%E8%8C%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>协作规范</h2>
<ul>
<li><a href="https://www.yuque.com/fe9/basic/nruxq8">Git 协同与提交规范</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/07/git.html">Git分支管理策略</a></li>
</ul>
<h2><a id="%E5%85%B6%E4%BB%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他</h2>
<ul>
<li><a href="https://juejin.cn/post/6844903897610321934">if 我是前端团队 Leader，怎么制定前端协作规范?</a></li>
<li><a href="https://juejin.cn/post/6844903824512008205">前端代码质量管理</a></li>
<li><a href="https://juejin.cn/post/6844903479698259975">前端开发规范：命名规范、html规范、css规范、js规范</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[qiankun子应用无法使用vue devtools如何解决]]></title>
    <link href="https://www.bwrong.cn/17280330897640.html"/>
    <updated>2024-10-04T17:11:29+08:00</updated>
    <id>https://www.bwrong.cn/17280330897640.html</id>
    <content type="html"><![CDATA[
<p>解决办法：将子应用的实例挂载为主应用的一个组件。</p>
<ol>
<li>子应用：</li>
</ol>
<pre class="line-numbers"><code class="language-js">new Vue({ 
  el: '#app',
  mounted() {
    if (window.__POWERED_BY_QIANKUN__ &amp;&amp; process.env.NODE_ENV === 'development') {
        // 将子应用实例挂载到window.__QIANKUN_SUB_APP_VM__  方便主应用获取
      window.__QIANKUN_SUB_APP_VM__ = this
    }
  }
})
</code></pre>
<ol start="2">
<li>主应用</li>
</ol>
<pre class="line-numbers"><code class="language-js">let rootInstance = new Vue({ 
    // ...
 })
registerMicroApps(apps, 
  {
    afterMount: () =&gt; {
      if (window.proxy.__QIANKUN_SUB_APP_VM__ &amp;&amp; process.env.NODE_ENV === 'development') {
        rootInstance.$children.push(window.proxy.__QIANKUN_SUB_APP_VM__);
      }
    }
  }
)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【Vue3】基础与入门]]></title>
    <link href="https://www.bwrong.cn/17280329145839.html"/>
    <updated>2024-10-04T17:08:34+08:00</updated>
    <id>https://www.bwrong.cn/17280329145839.html</id>
    <content type="html"><![CDATA[
<p>字数：7887， 阅读时间：40分钟，点击<a href="https://www.bwrong.cn/post/vue3-01/">阅读原文</a></p>
<p>从2013年12月8日发布第一个版本至今已，Vue已走过了快八个年头，你了解每个版本名字的意义吗？</p>
<table>
<thead>
<tr>
<th>版本号</th>
<th>名字</th>
<th>释义</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>V0.9</td>
<td>Animatrix</td>
<td>黑客帝国动画版</td>
<td>2014.2.25</td>
</tr>
<tr>
<td>V0.10</td>
<td>Blade Runner</td>
<td>银翼杀手</td>
<td>2014.3.23</td>
</tr>
<tr>
<td>V0.11</td>
<td>Cowboy Bebop</td>
<td>星际牛仔</td>
<td>2014.11.7</td>
</tr>
<tr>
<td>V0.12</td>
<td>Dragon Ball</td>
<td>龙珠</td>
<td>2015.6.12</td>
</tr>
<tr>
<td>V1.0</td>
<td>Evangelion</td>
<td>新世纪福音战士</td>
<td>2015.10.27</td>
</tr>
<tr>
<td>V2.0</td>
<td>Ghost in the Shell</td>
<td>攻壳机动队</td>
<td>2016.9.30</td>
</tr>
<tr>
<td>V2.1</td>
<td>Hunter X Hunter</td>
<td>全职猎人</td>
<td>2016.11.22</td>
</tr>
<tr>
<td>V2.2</td>
<td>Initial D</td>
<td>头文字D</td>
<td>2017.2.26</td>
</tr>
<tr>
<td>V2.3</td>
<td>JoJo's Bizarre Adventure</td>
<td>JoJo的奇妙冒险</td>
<td>2017.4.2</td>
</tr>
<tr>
<td>V2.4</td>
<td>Kill la Kill</td>
<td>斩服少女</td>
<td>2017.7.13</td>
</tr>
<tr>
<td><strong>V2.5</strong></td>
<td>Level E</td>
<td>灵异E接触</td>
<td>2017.10.13</td>
</tr>
<tr>
<td><strong>V2.6</strong></td>
<td>Macross</td>
<td>超时空要塞</td>
<td>2019.2.4</td>
</tr>
<tr>
<td>V3.0</td>
<td>One Piece</td>
<td>海贼王</td>
<td>2020.9.18</td>
</tr>
<tr>
<td>V3.1</td>
<td>Pluto</td>
<td>地上最强机器人</td>
<td>2021.6.8</td>
</tr>
<tr>
<td>V3.2</td>
<td>Quintessential Quintuplets</td>
<td>五等分的花嫁</td>
<td>2021.8.10</td>
</tr>
</tbody>
</table>
<p>原来每个版本的名字都是以漫画命名，那么这些动漫，你看过几部呢？</p>
<p>那么接下来我们就重点聊聊Vue3.0。</p>
<h1><a id="%E7%BC%98%E8%B5%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缘起</h1>
<p>一个新工具的出现，一定是为了解决已有工具存在的问题。我们常常听说Vue不适合开发大型复杂的项目，一个根本原因是 Vue 现有的 API 迫使我们通过选项组织代码，但是有的时候通过逻辑关系组织代码更有意义。另一个原因是目前缺少一种简洁且低成本的机制来提取和重用多个组件之间的逻辑。</p>
<p>那么接下来我们就来看看2.0的问题，以及Vue3是如何来解决的。</p>
<h2><a id="option%E5%BC%8F%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%BA%E9%99%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Option式组织代码的缺陷</h2>
<p>options式组织代码，同一个功能分散在各个option中，导致在开发时需要在data、methods、computed等option横跳。</p>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20210821095807.awebp" alt="option" /></p>
<p>Vue3推出了CompositionApi，目的就是为了解决这个问题，它将分散在各个option中的逻辑组合到一起，下面我们对比看下：</p>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20210821095754.awebp" alt="" /></p>
<h2><a id="mixin%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mixin的问题</h2>
<p>对于复杂的功能，我们可能会想到使用Mixin来抽离到单独的文件。但是Mixin会有一些使用上的问题，比如命名冲突、属性来源不明确。</p>
<p>Vue3提出了Hooks的方式，可以将每个功能提取到hooks，一个hooks即是一个独立的函数，所以不会再有上述问题。</p>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20210821095749.awebp" alt="" /></p>
<h2><a id="typescript%E6%94%AF%E6%8C%81%E7%9A%84%E4%B8%8D%E5%81%A5%E5%85%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeScript支持的不健全</h2>
<p>现在大型项目都会标配 TypeScript ，Vue 当前的 API 在集成 TypeScript 时遇到了不小的麻烦，其主要原因是 Vue 依靠一个简单的 <code>this</code> 上下文来暴露 property，我们现在使用 <code>this</code> 的方式是比较微妙的。（比如 <code>methods</code> 选项下的函数的 <code>this</code> 是指向组件实例的，而不是这个 <code>methods</code> 对象）。</p>
<p>换句话说，Vue 现有的 API 在设计之初没有照顾到类型推导，这使适配 TypeScript 变得复杂。</p>
<p>当前，大部分使用 TypeScript 的 Vue 开发者都在通过 <code>vue-class-component</code> 这个库将组件撰写为 TypeScript class (借助 decorator)。它必须依赖 decorator——一个在实现细节上存在许多未知数的非常不稳定的 stage 2 提案。基于它是有极大风险的。</p>
<p>Vue3中提出的方案更多地利用了天然对类型友好的普通变量与函数，完美享用类型推导，并且也不用做太多额外的类型标注。</p>
<p>这也同样意味着你写出的 JavaScript 代码几乎就是 TypeScript 的代码。即使是非 TypeScript 开发者也会因此得到更好的 IDE 类型支持而获益。</p>
<h2><a id="%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%92%8C%E6%80%A7%E8%83%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>更好的响应式和性能</h2>
<p>众所周知，Vue2的响应式是通过<code>Object.defineProperty</code> 是给对象的某个已存在的属性添加对应的 <code>getter</code> 和 <code>setter</code>，所以它只能监听这个属性值的变化，而不能去监听对象属性的新增和删除。在 Vue 2 的实现中，在组件初始化阶段把数据变成响应式时，遇到子属性仍然是对象的情况，会递归执行 <code>Object.defineProperty</code> 定义子对象的响应式，会有一些性能问题。而且还有一个常见的问题就是通过索引修改数组、为对象直接新增属性，并不会触发响应式更新机制。</p>
<p>而在Vue3中则使用了Proxy来实现响应式，其实并不是Proxy的本身的性能优于<code>Object.defineProperty</code>，其实恰恰相反。那么为什么还要选择Proxy呢？</p>
<p>因为 <code>Proxy</code> 本质上是对某个对象的劫持，这样它不仅仅可以监听对象某个属性值的变化，还可以监听对象属性的新增和删除。而且在实现响应式时，采用了延时处理的方式，当嵌套较深的对象时，只有在其属性被访问的时候才会处理属性的响应式，在性能上会有一定的提升。</p>
<h2><a id="%E6%94%AF%E6%8C%81%E5%85%A8%E5%B1%80api-treeshaking" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>支持全局API Treeshaking</h2>
<p>Vue3重构了全局和局部的api，均采用ESModule的命名导出访问，支持tree-shaking，只打包使用到的功能，用户只为实际使用的功能买单，同时包体积的减少，也意味着性能的提升。</p>
<pre class="line-numbers"><code class="language-js">// vue2
import Vue from 'vue'

Vue.nextTick(() =&gt; {
  // 一些和DOM有关的东西
})

</code></pre>
<pre class="line-numbers"><code class="language-js">// vue3
import { nextTick } from 'vue'

nextTick(() =&gt; {
  // 一些和DOM有关的东西
})
</code></pre>
<p>以上就是Vue主要的变化，那么接下来我们就来看看有哪些新特性。</p>
<h1><a id="%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8E%E5%8F%98%E6%9B%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>新特性与变更</h1>
<p>接下来我们主要看一下一些非兼容的重大变更：</p>
<h2><a id="%E5%85%A8%E5%B1%80api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全局API</h2>
<ul>
<li>
<p>支持多个应用根实例，防止全局配置污染</p>
<pre class="line-numbers"><code class="language-js">// vue2
// 这会影响两个根实例
Vue.mixin({
  /* ... */
})
const app1 = new Vue({ el: '#app-1' })
const app2 = new Vue({ el: '#app-2' })
</code></pre>
<pre class="line-numbers"><code class="language-js">// vue3
import { createApp } from 'vue'

const app = createApp({})
app.mixin({
  /* ... */
})
</code></pre>
<p>一些其他全局Api的变更详情请查阅<a href="https://v3.cn.vuejs.org/guide/migration/global-api.html#%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%85%A8%E5%B1%80-api-createapp">全局 API</a>。</p>
</li>
<li>
<p>全局 API重构为可Treeshaking</p>
<pre class="line-numbers"><code class="language-js">import { nextTick } from 'vue'

nextTick(() =&gt; {
  // 一些和DOM有关的东西
})
// **** 受影响的API
// Vue.nextTick
// Vue.observable (用 Vue.reactive 替换)
// Vue.version
// Vue.compile (仅完整构建版本)
// Vue.set (仅兼容构建版本)
// Vue.delete (仅兼容构建版本)
</code></pre>
</li>
</ul>
<h2><a id="%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%8C%87%E4%BB%A4%E7%9B%B8%E5%85%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模板和指令相关</h2>
<ul>
<li>更好用的<code>v-model</code></li>
</ul>
<p>替代原有的<code>v-model</code>和<code>v-bind.sync</code>修饰符，通过参数形式，支持使用多个<code>v-model</code>进行双向绑定。</p>
<pre class="line-numbers"><code class="language-html">&lt;!-- vue2 --&gt;
&lt;ChildComponent v-model=&quot;pageTitle&quot; :title.sync=&quot;title&quot;/&gt;
&lt;!-- 完整 --&gt;
&lt;ChildComponent :value=&quot;pageTitle&quot; @input=&quot;(title)=&gt; (pageTitle=title)&quot; :title=&quot;title&quot; @update:title=&quot;(title)=&gt; (title=title)&quot;/&gt;
</code></pre>
<pre class="line-numbers"><code class="language-html">&lt;!-- vue3 --&gt;
&lt;ChildComponent v-model=&quot;pageTitle&quot; v-modle:title=&quot;title&quot;/&gt;
&lt;!-- 完整 --&gt;
&lt;ChildComponent :model-value=&quot;pageTitle&quot; @update:modelValue=&quot;(title)=&gt; (pageTitle=title)&quot; :title=&quot;title&quot; @update:title=&quot;(title)=&gt; (title=title)&quot;/&gt;
</code></pre>
<ul>
<li><code>&lt;template v-for&gt;</code>的变化</li>
</ul>
<pre class="line-numbers"><code class="language-vue">&lt;!-- vue2 --&gt;
&lt;template v-for=&quot;item in list&quot;&gt;
  &lt;div :key=&quot;'heading-' + item.id&quot;&gt;...&lt;/div&gt;
  &lt;span :key=&quot;'content-' + item.id&quot;&gt;...&lt;/span&gt;
&lt;/template&gt;
</code></pre>
<pre class="line-numbers"><code class="language-vue">&lt;!-- vue 3 --&gt;
&lt;template v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;
  &lt;div&gt;...&lt;/div&gt;
  &lt;span&gt;...&lt;/span&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li><code>v-bind</code> 合并顺序变化</li>
</ul>
<pre class="line-numbers"><code class="language-html">&lt;!-- vue2 --&gt;
&lt;div id=&quot;red&quot; v-bind=&quot;{ id: 'blue' }&quot;&gt;&lt;/div&gt;
&lt;!-- result --&gt;
&lt;div id=&quot;red&quot;&gt;&lt;/div&gt;
</code></pre>
<pre class="line-numbers"><code class="language-html">&lt;!-- vue3 --&gt;
&lt;div id=&quot;red&quot; v-bind=&quot;{ id: 'blue' }&quot;&gt;&lt;/div&gt;
&lt;!-- result --&gt;
&lt;div id=&quot;blue&quot;&gt;&lt;/div&gt;
</code></pre>
<ul>
<li>
<p>移除<code>v-on.native</code>修饰符</p>
<p>在以前的版本中，要将原生 DOM 监听器添加到子组件的根元素中，可以使用 <code>.native</code> 修饰符。</p>
</li>
</ul>
<pre class="line-numbers"><code class="language-html">&lt;!-- vue2 --&gt;
&lt;my-component
  v-on:close=&quot;handleComponentEvent&quot;
  v-on:click.native=&quot;handleNativeClickEvent&quot;
/&gt;
</code></pre>
<p>在vue3中，组件中<em>未</em>被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 <code>inheritAttrs: false</code>)</p>
<pre class="line-numbers"><code class="language-html">&lt;!-- vue3 --&gt;
&lt;my-component
  v-on:close=&quot;handleComponentEvent&quot;
  v-on:click=&quot;handleNativeClickEvent&quot;
/&gt;
&lt;script&gt;
  export default {
    emits: ['close']
  }
&lt;/script&gt;
</code></pre>
<ul>
<li>支持片段（多根节点）</li>
</ul>
<pre class="line-numbers"><code class="language-vue">&lt;!-- vue2 --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;header&gt;...&lt;/header&gt;
    &lt;main&gt;...&lt;/main&gt;
    &lt;footer&gt;...&lt;/footer&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>在vue2中，组件必须包含在某个元素内部，不支持多个根节点，这有时会给我们写样式带来烦恼，所以vue3中支持了多根节点。</p>
<pre class="line-numbers"><code class="language-vue">&lt;!-- vue3 --&gt;
&lt;template&gt;
  &lt;header&gt;...&lt;/header&gt;
  &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;
  &lt;footer&gt;...&lt;/footer&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li>新增Teleport传送门</li>
</ul>
<p>vue应用开发的核心就是组件编写，将 UI 和相关行为封装到组件中来构建 UI。但是有时组件模板的一部分逻辑上属于该组件，而从技术角度来看，最好将模板的这一部分移动到 DOM 中 Vue app 之外的其他位置。</p>
<p>比如最常见的模态窗，我们希望模态窗的逻辑存在于组件中，但在UI上，元素最好又挂载到DOM根节点（如body）上，方便我们进行css来定位。</p>
<pre class="line-numbers"><code class="language-html">&lt;body&gt;
  &lt;div style=&quot;position: relative;&quot;&gt;
    &lt;h3&gt;Tooltips with Vue 3 Teleport&lt;/h3&gt;
    &lt;div&gt;
      &lt;modal-button&gt;&lt;/modal-button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<pre class="line-numbers"><code class="language-js">const app = Vue.createApp({});

app.component('modal-button', {
  template: `
    &lt;button @click=&quot;modalOpen = true&quot;&gt;
        Open full screen modal!
    &lt;/button&gt;

    &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt;
      &lt;div&gt;
        I'm a modal!
        &lt;button @click=&quot;modalOpen = false&quot;&gt;
          Close
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  `,
  data() {
    return {
      modalOpen: false
    }
  }
})
</code></pre>
<p>在上面的例子中，我们可以看到一个问题——模态框是在深度嵌套的 <code>div</code> 中渲染的，而模态框的 <code>position:absolute</code> 以父级相对定位的 <code>div</code> 作为引用，最终的效果会受父级定位的影响，这可能并不是我们期望的结果。</p>
<p>Teleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。</p>
<pre class="line-numbers"><code class="language-js">app.component('modal-button', {
  template: `
    &lt;button @click=&quot;modalOpen = true&quot;&gt;
        Open full screen modal! (With teleport!)
    &lt;/button&gt;

    &lt;teleport to=&quot;body&quot;&gt;
      &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt;
        &lt;div&gt;
          I'm a teleported modal!
          (My parent is &quot;body&quot;)
          &lt;button @click=&quot;modalOpen = false&quot;&gt;
            Close
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/teleport&gt;
  `,
  data() {
    return {
      modalOpen: false
    }
  }
})
</code></pre>
<h2><a id="%E7%BB%84%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>组件</h2>
<ul>
<li>函数式组件</li>
</ul>
<p>在vue2中我们可能因为性能和多根节点的需求而使用函数式组件，当在vue3中，针对普通组件性能做了优化，已经和函数组件性能相差无几，而且也支持多根节点，因此函数式组件的使用场景不是很有必要了，所以针对函数式组件进行了一些调整：</p>
<pre class="line-numbers"><code class="language-vue">&lt;!-- Vue 2 函数式组件示例 --&gt;
&lt;script&gt;
export default {
  functional: true,
  props: ['level'],
  render(h, { props, data, children }) {
    return h(`h${props.level}`, data, children)
  }
}
&lt;/script&gt;

&lt;!-- Vue 2 函数式组件示例使用 &lt;template&gt; --&gt;
&lt;template functional&gt;
  &lt;component
    :is=&quot;`h${props.level}`&quot;
    v-bind=&quot;attrs&quot;
    v-on=&quot;listeners&quot;
  /&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  props: ['level']
}
&lt;/script&gt;
</code></pre>
<p>在vue3中删除了<code>functional option</code>和<code>functional attribute</code>,上面两种方式不能在vue3中使用了。</p>
<p>在vue3中函数式组件即是一个普通函数，接收两个参数：<code>props</code> 和 <code>context</code>。</p>
<pre class="line-numbers"><code class="language-js">// vue3
import { h } from 'vue'

const DynamicHeading = (props, context) =&gt; {
  return h(`h${props.level}`, context.attrs, context.slots)
}

DynamicHeading.props = ['level']

export default DynamicHeading
</code></pre>
<ul>
<li>创建异步组件</li>
</ul>
<p>以前可以通过返回一个Promise的函数来定义异步组件：</p>
<pre class="line-numbers"><code class="language-js">// vue2
const asyncModal = () =&gt; import('./Modal.vue');
// 或者带上配置
const asyncModal = {
  component: () =&gt; import('./Modal.vue'),
  delay: 200,
  timeout: 3000,
  error: ErrorComponent,
  loading: LoadingComponent
}
</code></pre>
<p>在vue3中，新增呢一个api（defineAsyncComponent）来显示定义异步组件。</p>
<pre class="line-numbers"><code class="language-js">// vue3
import { defineAsyncComponent } from 'vue'
import ErrorComponent from './components/ErrorComponent.vue'
import LoadingComponent from './components/LoadingComponent.vue'

// 不带选项的异步组件
const asyncModal = defineAsyncComponent(() =&gt; import('./Modal.vue'))

// 带选项的异步组件
const asyncModalWithOptions = defineAsyncComponent({
  loader: () =&gt; import('./Modal.vue'),
  delay: 200,
  timeout: 3000,
  errorComponent: ErrorComponent,
  loadingComponent: LoadingComponent
})
</code></pre>
<ul>
<li>新增<code>emits</code>选项，定义和验证发出的自定义事件</li>
</ul>
<pre class="line-numbers"><code class="language-vue">&lt;!-- vue2 --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;{{ text }}&lt;/p&gt;
    &lt;button v-on:click=&quot;$emit('accepted')&quot;&gt;OK&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    props: ['text']
  }
&lt;/script&gt;
</code></pre>
<p>vue3中增加了emits选项来显示定义组件的自定义事件，未声明 <code>emits</code> 的事件监听器都会被算入组件的 <code>$attrs</code> 并绑定在组件的根节点上。</p>
<pre class="line-numbers"><code class="language-vue">&lt;!-- vue3 --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;{{ text }}&lt;/p&gt;
    &lt;button v-on:click=&quot;$emit('accepted')&quot;&gt;OK&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    props: ['text'],
    emits: ['accepted']
  }
&lt;/script&gt;
</code></pre>
<p>emits还可以支持对自定义事件进行验证，只需要改为对象形式即可。</p>
<pre class="line-numbers"><code class="language-js">emits: {
    // 没有验证函数
    click: null,

    // 带有验证函数
    submit: payload =&gt; {
      if (payload.email &amp;&amp; payload.password) {
        return true
      } else {
        console.warn(`Invalid submit event payload!`)
        return false
      }
    }
  }
</code></pre>
<p>强烈建议使用 <code>emits</code> 记录每个组件所触发的所有事件，而且记录的事件会有代码提示。</p>
<h2><a id="%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>渲染函数</h2>
<ul>
<li>
<p>统一插槽API</p>
<p>以前，在组件中获取插槽是两个不同的api（<code>this.$scopedSlots</code> 和 <code>this.$slots</code>），现在统一使用<code>this.$slots</code>。</p>
</li>
<li>
<p>整合<code>$listeners</code>、class、style到<code>$attrs</code></p>
</li>
</ul>
<p>在vue2时，我们可以通过如下方式访问<code>attribute</code> 和事件监听器：</p>
<pre class="line-numbers"><code class="language-vue">&lt;!-- vue3 --&gt;
&lt;template&gt;
  &lt;label&gt;
    &lt;input type=&quot;text&quot; v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot; /&gt;
  &lt;/label&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    inheritAttrs: false
  }
&lt;/script&gt;
</code></pre>
<p>在 Vue 3 的虚拟 DOM 中，事件监听器现在只是以 <code>on</code> 为前缀的 attribute，这样就成了 <code>$attrs</code> 对象的一部分，因此 <code>$listeners</code> 被移除了。</p>
<pre class="line-numbers"><code class="language-vue">&lt;!-- vue3 --&gt;
&lt;template&gt;
  &lt;label&gt;
    &lt;input type=&quot;text&quot; v-bind=&quot;$attrs&quot; /&gt;
  &lt;/label&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  inheritAttrs: false
}
&lt;/script&gt;
</code></pre>
<p>在 Vue 2 的虚拟 DOM 实现中对 <code>class</code> 和 <code>style</code> attribute 有一些特殊处理。因此，它们<em>不</em>包含在 <code>$attrs</code> 中，Vue3中简化了这部分的处理，用<code>$attrs</code> 包含<em>所有的</em> attribute，包括<code>class</code>和<code>style</code>。</p>
<h2><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义元素</h2>
<ul>
<li>只能在<code>&lt;component&gt;</code>元素中使用<code>is</code>prop</li>
</ul>
<p>在vue3中不能在普通组件和元素使用<code>is</code>属性，仅能在<code>component</code>内置组件中使用。</p>
<h2><a id="%E5%85%B6%E4%BB%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他</h2>
<ul>
<li>
<p>生命周期变更</p>
<ul>
<li><code>destroyed</code> 生命周期选项被重命名为 <code>unmounted</code></li>
<li><code>beforeDestroy</code> 生命周期选项被重命名为 <code>beforeUnmount</code></li>
</ul>
</li>
<li>
<p>自定义指令生命周期调整，和组件生命周期统一</p>
<ul>
<li>created - 新的！在元素的 attribute 或事件侦听器应用之前调用。</li>
<li>bind → <strong>beforeMount</strong></li>
<li>inserted → <strong>mounted</strong></li>
<li><strong>beforeUpdate</strong>：新的！这是在元素本身更新之前调用的，很像组件生命周期钩子。</li>
<li>update → 移除！有太多的相似之处要更新，所以这是多余的，请改用 <code>updated</code>。</li>
<li>componentUpdated → <strong>updated</strong></li>
<li><strong>beforeUnmount</strong>：新的！与组件生命周期钩子类似，它将在卸载元素之前调用。</li>
<li>unbind -&gt; <strong>unmounted</strong></li>
</ul>
</li>
<li>
<p>Mixin 合并行为变更</p>
</li>
</ul>
<p>当来自组件的 <code>data()</code> 及其 mixin 或 extends 基类被合并时，现在将<em>浅层次</em>执行合并。</p>
<ul>
<li>过渡的class名更改</li>
</ul>
<p>过渡类名 <code>v-enter</code> 修改为 <code>v-enter-from</code>、过渡类名 <code>v-leave</code> 修改为 <code>v-leave-from</code>。</p>
<ul>
<li>
<p>VNode 生命周期事件变更</p>
<pre class="line-numbers"><code class="language-vue">&lt;!-- vue2 --&gt;
&lt;template&gt;
  &lt;child-component @hook:updated=&quot;onUpdated&quot;&gt;
&lt;/template&gt;
</code></pre>
<pre class="line-numbers"><code class="language-vue">&lt;!-- vue3 --&gt;
&lt;template&gt;
  &lt;child-component @vnode-updated=&quot;onUpdated&quot;&gt;
&lt;/template&gt;
</code></pre>
</li>
</ul>
<h2><a id="%E5%BA%9F%E5%BC%83%E7%9A%84api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>废弃的API</h2>
<ul>
<li><code>keyCode</code>作为<code>v-on</code>的修饰符及<code>config.keyCodes</code>配置。</li>
</ul>
<pre class="line-numbers"><code class="language-vue">&lt;!-- 键码版本（废弃） --&gt;
&lt;input v-on:keyup.13=&quot;submit&quot; /&gt;

&lt;!-- 别名版本 --&gt;
&lt;input v-on:keyup.enter=&quot;submit&quot; /&gt;

&lt;script&gt;
Vue.config.keyCodes = { // 废弃
  f1: 112
}
&lt;/script&gt;

</code></pre>
<ul>
<li><code>$on</code>，<code>$off</code> 和 <code>$once</code> 实例方法已被移除，组件实例不再实现事件触发接口</li>
</ul>
<p>在vue2中我们可以通过EventBus实现组件通信：</p>
<pre class="line-numbers"><code class="language-js">// eventBus.js
const eventBus = new Vue()
export default eventBus
</code></pre>
<pre class="line-numbers"><code class="language-js">// ChildComponent.vue
import eventBus from './eventBus'
export default {
  mounted() {
    // 添加 eventBus 监听器
    eventBus.$on('custom-event', () =&gt; {
      console.log('Custom event triggered!')
    })
  },
  beforeDestroy() {
    // 移除 eventBus 监听器
    eventBus.$off('custom-event')
  }
}
</code></pre>
<pre class="line-numbers"><code class="language-js">// ParentComponent.vue
import eventBus from './eventBus'
export default {
  methods: {
    callGlobalCustomEvent() {
      eventBus.$emit('custom-event') // 当 ChildComponent 被挂载，控制台中将显示一条消息
    }
  }
}
</code></pre>
<p>在vue3中，此方式不再有效，因为完全移除了 <code>$on</code>、<code>$off</code> 和 <code>$once</code> 方法。如果需要，可以使用一些实现了事件触发器接口的外部库，或者使用Provide，复杂的直接上Vuex就对了。</p>
<ul>
<li>不再支持过滤器</li>
</ul>
<pre class="line-numbers"><code class="language-vue">&lt;!-- vue2 --&gt;
&lt;template&gt;
  &lt;h1&gt;Bank Account Balance&lt;/h1&gt;
  &lt;p&gt;{{ accountBalance | currencyUSD }}&lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    props: {
      accountBalance: {
        type: Number,
        required: true
      }
    },
    filters: {
      currencyUSD(value) {
        return '$' + value
      }
    }
  }
&lt;/script&gt;
</code></pre>
<p>在vue3中可以使用方法或者计算属性替代：</p>
<pre class="line-numbers"><code class="language-vue">&lt;!-- vue3 --&gt;
&lt;template&gt;
  &lt;h1&gt;Bank Account Balance&lt;/h1&gt;
  &lt;p&gt;{{ accountInUSD }}&lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    props: {
      accountBalance: {
        type: Number,
        required: true
      }
    },
    computed: {
      accountInUSD() {
        return '$' + this.accountBalance
      }
    }
  }
&lt;/script&gt;
</code></pre>
<ul>
<li>
<p>删除<code>$children</code>property</p>
<p><code>$children</code> property 已移除，不再支持。如果你需要访问子组件实例，我们建议使用 <a href="https://v3.cn.vuejs.org/guide/component-template-refs.html#%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8">$refs</a>。</p>
</li>
<li>
<p>全局函数 <code>set</code> 和 <code>delete</code> 以及实例方法 <code>$set</code> 和 <code>$delete</code>。基于代理的变化检测不再需要它们了。</p>
</li>
</ul>
<p>当然，上面的只是开胃菜，接下来的才是我们最值得关注的新特性。</p>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20210823173734.jpg" alt="" /></p>
<h1><a id="%E7%BB%84%E5%90%88%E5%BC%8Fapi" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>组合式Api</h1>
<p>为了解决我们前面说的逻辑复用和代码组织的问题，vue3推出了新的代码编写方式，这个vue3最重要的特性，也是未来编写vue的主要趋势。</p>
<p>下面是一个显示某个用户的仓库列表的视图，同时带有搜索和筛选功能，伪代码如下：</p>
<pre class="line-numbers"><code class="language-js">// src/components/UserRepositories.vue

export default {
  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },
  props: {
    user: {
      type: String,
      required: true
    }
  },
  data () {
    return {
      repositories: [], // 1
      filters: { ... }, // 3
      searchQuery: '' // 2
    }
  },
  computed: {
    filteredRepositories () { ... }, // 3
    repositoriesMatchingSearchQuery () { ... }, // 2
  },
  watch: {
    user: 'getUserRepositories' // 1
  },
  methods: {
    getUserRepositories () {
      // 使用 `this.user` 获取用户仓库
    }, // 1
    updateFilters () { ... }, // 3
  },
  mounted () {
    this.getUserRepositories() // 1
  }
}
</code></pre>
<p>可以看到，按option组织代码，功能逻辑点是碎片化的分散在各个组件选项中，特别是遇到一些内容较多的组件，需要在各个选项中反复跳转，阅读和书写代码将是一件非常痛苦的事情，大大降低了组件的可维护性。</p>
<p>其实，在开发和阅读组件代码的时候，我们更多是关注的功能点，而不是去关注用了那些options，这正是组合式api解决的问题。</p>
<pre class="line-numbers"><code class="language-js">// src/composables/useUserRepositories.js

import { fetchUserRepositories } from '@/api/repositories'
import { ref, onMounted, watch } from 'vue'

export default function useUserRepositories(user) {
  const repositories = ref([])
  const getUserRepositories = async () =&gt; {
    repositories.value = await fetchUserRepositories(user.value)
  }

  onMounted(getUserRepositories)
  watch(user, getUserRepositories)

  return {
    repositories,
    getUserRepositories
  }
}
</code></pre>
<pre class="line-numbers"><code class="language-js">// src/composables/useRepositoryNameSearch.js

import { ref, computed } from 'vue'

export default function useRepositoryNameSearch(repositories) {
  const searchQuery = ref('')
  const repositoriesMatchingSearchQuery = computed(() =&gt; {
    return repositories.value.filter(repository =&gt; {
      return repository.name.includes(searchQuery.value)
    })
  })

  return {
    searchQuery,
    repositoriesMatchingSearchQuery
  }
}
</code></pre>
<pre class="line-numbers"><code class="language-js">// src/components/UserRepositories.vue
import { toRefs } from 'vue'
import useUserRepositories from '@/composables/useUserRepositories'
import useRepositoryNameSearch from '@/composables/useRepositoryNameSearch'
import useRepositoryFilters from '@/composables/useRepositoryFilters'

export default {
  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },
  props: {
    user: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const { user } = toRefs(props)

    const { repositories, getUserRepositories } = useUserRepositories(user)

    const {
      searchQuery,
      repositoriesMatchingSearchQuery
    } = useRepositoryNameSearch(repositories)

    const {
      filters,
      updateFilters,
      filteredRepositories
    } = useRepositoryFilters(repositoriesMatchingSearchQuery)

    return {
      // 因为我们并不关心未经过滤的仓库
      // 我们可以在 `repositories` 名称下暴露过滤后的结果
      repositories: filteredRepositories,
      getUserRepositories,
      searchQuery,
      filters,
      updateFilters
    }
  }
}
</code></pre>
<p>组合式API分离了组件的逻辑关注点，更具组织性，代码的可读性和可维护性也更好。而且可以将可复用的逻辑抽离成Hooks，具有更好的可复用性。</p>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20210824102437.png" alt="" /></p>
<p>由于组合式API的特殊性，需要使用新的API，接下来我们就来看看这些API。</p>
<h2><a id="setup" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>setup</h2>
<p>setup是组合式API的入口，所有的内容都需要包含在其中，它仅在组件创建<strong>之前</strong>执行<strong>一次</strong>，所以此时this并不是指向当前组件实例。</p>
<pre class="line-numbers"><code class="language-js">setup(props,context){
  const { attrs, slots, emit } = context;
	// ...
}
</code></pre>
<h3><a id="%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数</h3>
<ul>
<li><code>{Data} props</code>：接收到的props数据，是响应式的。</li>
<li><code>{SetupContext} context</code>：一个对象，包含组件需要的上下文信息，包含<code>attrs</code>、<code>slots</code>、<code>emit</code>。</li>
</ul>
<h3><a id="%E8%BF%94%E5%9B%9E%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>返回值</h3>
<ul>
<li>如果返回一个对象，那么该对象的 property 以及传递给 <code>setup</code> 的 <code>props</code> 参数中的 property 就都可以在模板中访问到。</li>
</ul>
<pre class="line-numbers"><code class="language-vue">&lt;!-- MyBook.vue --&gt;
&lt;template&gt;
  &lt;div&gt;{{ collectionName }}: {{ readersNumber }} {{ book.title }}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import { ref, reactive } from 'vue'

  export default {
    props: {
      collectionName: String
    },
    setup(props) {
      const readersNumber = ref(0)
      const book = reactive({ title: 'Vue 3 Guide' })

      // 暴露给 template
      return {
        readersNumber,
        book
      }
    }
  }
&lt;/script&gt;
</code></pre>
<ul>
<li>如果返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态。</li>
</ul>
<pre class="line-numbers"><code class="language-js">// MyBook.vue

import { h, ref, reactive } from 'vue'

export default {
  setup() {
    const readersNumber = ref(0)
    const book = reactive({ title: 'Vue 3 Guide' })
    // 请注意这里我们需要显式调用 ref 的 value
    return () =&gt; h('div', [readersNumber.value, book.title])
  }
}
</code></pre>
<h2><a id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生命周期钩子</h2>
<p>为了使组合式 API 的功能和选项式 API 一样完整，我们还需要一种在 <code>setup</code> 中注册生命周期钩子的方法。组合式 API 上的生命周期钩子与选项式 API 的名称相同，但前缀为 <code>on</code>：即 <code>mounted</code> 看起来会像 <code>onMounted</code>。</p>
<pre class="line-numbers"><code class="language-js">import { onMounted, onUpdated, onUnmounted } from 'vue'

const MyComponent = {
  setup() {
    onMounted(() =&gt; {
      console.log('mounted!')
    })
    onUpdated(() =&gt; {
      console.log('updated!')
    })
    onUnmounted(() =&gt; {
      console.log('unmounted!')
    })
  }
}
</code></pre>
<p>setup代替了<code>beforeCreate</code>和<code>created</code>，对比如下：</p>
<table>
<thead>
<tr>
<th>选项式 API</th>
<th>Hook inside <code>setup</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>beforeCreate</code></td>
<td>Not needed*</td>
</tr>
<tr>
<td><code>created</code></td>
<td>Not needed*</td>
</tr>
<tr>
<td><code>beforeMount</code></td>
<td><code>onBeforeMount</code></td>
</tr>
<tr>
<td><code>mounted</code></td>
<td><code>onMounted</code></td>
</tr>
<tr>
<td><code>beforeUpdate</code></td>
<td><code>onBeforeUpdate</code></td>
</tr>
<tr>
<td><code>updated</code></td>
<td><code>onUpdated</code></td>
</tr>
<tr>
<td><code>beforeUnmount</code></td>
<td><code>onBeforeUnmount</code></td>
</tr>
<tr>
<td><code>unmounted</code></td>
<td><code>onUnmounted</code></td>
</tr>
<tr>
<td><code>errorCaptured</code></td>
<td><code>onErrorCaptured</code></td>
</tr>
<tr>
<td><code>renderTracked</code></td>
<td><code>onRenderTracked</code></td>
</tr>
<tr>
<td><code>renderTriggered</code></td>
<td><code>onRenderTriggered</code></td>
</tr>
<tr>
<td><code>activated</code></td>
<td><code>onActivated</code></td>
</tr>
<tr>
<td><code>deactivated</code></td>
<td><code>onDeactivated</code></td>
</tr>
</tbody>
</table>
<h2><a id="%E5%93%8D%E5%BA%94%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>响应式</h2>
<p>在vue3中，使用了<code>Proxy</code>代替了<code>Object.defineProperty</code>，使 Vue 3 避免了 Vue 早期版本中存在的一些响应性问题。</p>
<p>当我们从一个组件的 <code>data</code> 函数中返回一个普通的 JavaScript 对象时，Vue 会将该对象包裹在一个带有 <code>get</code> 和 <code>set</code> 处理程序的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> 中。</p>
<p>举个🌰：</p>
<pre class="line-numbers"><code class="language-js">const dinner = {
  meal: 'tacos'
}

const handler = {
  get(target, property, receiver) { // 捕捉器
    track(target, property)  // 跟踪property读取，收集依赖
    return Reflect.get(...arguments) // Reflect将this绑定到Proxy
  },
  set(target, property, value, receiver) {
    trigger(target, property) // 执行副作用依赖项
    return Reflect.set(...arguments)
  }
}

const proxy = new Proxy(dinner, handler)
console.log(proxy.meal)

// tacos
</code></pre>
<ol>
<li><strong>当一个值被读取时进行追踪</strong>：proxy 的 <code>get</code> 处理函数中 <code>track</code> 函数记录了该 property 和当前副作用。</li>
<li><strong>当某个值改变时进行检测</strong>：在 proxy 上调用 <code>set</code> 处理函数。</li>
<li><strong>重新运行代码来读取原始值</strong>：<code>trigger</code> 函数查找哪些副作用依赖于该 property 并执行它们。</li>
</ol>
<p>该被代理的对象对于用户来说是不可见的，但是在内部，它们使 Vue 能够在 property 的值被访问或修改的情况下进行依赖跟踪和变更通知。</p>
<p>那么组件是如何让渲染响应数据变化的呢？</p>
<p>组件的模板会被编译成一个 <a href="https://v3.cn.vuejs.org/guide/render-function.html"><code>render</code></a> 函数，它用来创建 <a href="https://v3.cn.vuejs.org/guide/render-function.html#%E8%99%9A%E6%8B%9F-dom-%E6%A0%91">VNodes</a>，描述该组件应该如何被渲染。这个render函数被包裹在一个副作用中，允许 Vue 在运行时跟踪被“触达”的 property，当property变化的时候，就会执行对应的副作用，从而执行render重新渲染。当然在渲染并不会整个重新渲染，这里有一些优化手段，网上资料很多，这里不展开讲。</p>
<p>接下来我们看看几个常用的响应式API。</p>
<h3><a id="ref" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ref</h3>
<pre class="line-numbers"><code class="language-ts">interface Ref&lt;T&gt; {
  value: T
}
function ref&lt;T&gt;(value: T): Ref&lt;T&gt;
</code></pre>
<p>接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property <code>.value</code>。</p>
<pre class="line-numbers"><code class="language-js">import { ref } from 'vue'

const counter = ref&lt;number&gt;(0)

console.log(counter) // { value: 0 }
console.log(counter.value) // 0

counter.value++
console.log(counter.value) // 1
</code></pre>
<p>因为在 JavaScript 中，<code>Number</code> 或 <code>String</code> 等基本类型是通过值而非引用传递的，在任何值周围都有一个封装对象，这样我们就可以在整个应用中安全地传递它，而不必担心在某个地方失去它的响应性。</p>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20210824224551.gif" alt="pass-by-reference-vs-pass-by-value-animation" /></p>
<p><em>注意：ref嵌套在响应式对象（如reactive、readonly）或者用在模板中，将自动解包</em>。</p>
<h3><a id="reactive" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>reactive</h3>
<pre class="line-numbers"><code class="language-ts">function reactive&lt;T extends object&gt;(target: T): UnwrapNestedRefs&lt;T&gt;
</code></pre>
<p>返回对象的响应式副本，即一个深层递归转换的proxy对象。</p>
<pre class="line-numbers"><code class="language-js">import { reactive } from 'vue'
interface IState{
  count:number
}
// state 现在是一个响应式的状态
const state = reactive&lt;IState&gt;({
  count: 0,
})
</code></pre>
<p><strong>ref和reactive</strong>：</p>
<ul>
<li>一般基础数据类型使用ref，对象使用reactive</li>
<li>如果将对象分配为 ref 值，则通过 <a href="https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive">reactive</a> 方法使该对象具有高度的响应式。</li>
</ul>
<h3><a id="readonly" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>readonly</h3>
<p>接受一个对象 (响应式或纯对象) 或 <a href="https://v3.cn.vuejs.org/api/refs-api.html#ref">ref</a> 并返回原始对象的只读代理。只读代理是深层的：任何被访问的嵌套 property 也是只读的。</p>
<pre class="line-numbers"><code class="language-js">const original = reactive({ count: 0 })

const copy = readonly(original)

watchEffect(() =&gt; {
  // 用于响应性追踪
  console.log(copy.count)
})

// 变更 original 会触发依赖于副本的侦听器
original.count++

// 变更副本将失败并导致警告
copy.count++ // 警告!
</code></pre>
<h3><a id="unref" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>unref</h3>
<p>如果参数是一个 <a href="https://v3.cn.vuejs.org/api/refs-api.html#ref"><code>ref</code></a>，则返回内部值，否则返回参数本身。这是 <code>val = isRef(val) ? val.value : val</code> 的语法糖函数。</p>
<pre class="line-numbers"><code class="language-ts">function useFoo(x: number | Ref&lt;number&gt;) {
  const unwrapped = unref(x) // unwrapped 现在一定是数字类型
}
</code></pre>
<h3><a id="toref" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>toRef</h3>
<p>可以用来为源响应式对象上的某个 property 新创建一个 <a href="https://v3.cn.vuejs.org/api/refs-api.html#ref"><code>ref</code></a>,它会保持对其源 property 的响应式连接。</p>
<pre class="line-numbers"><code class="language-js">const state = reactive({
  foo: 1,
  bar: 2
})

const fooRef = toRef(state, 'foo')

fooRef.value++
console.log(state.foo) // 2

state.foo++
console.log(fooRef.value) // 3
</code></pre>
<h3><a id="torefs" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>toRefs</h3>
<p>将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 <a href="https://v3.cn.vuejs.org/api/refs-api.html#ref"><code>ref</code></a>。</p>
<pre class="line-numbers"><code class="language-js">function useFeatureX() {
  const state = reactive({
    foo: 1,
    bar: 2
  })

  // 操作 state 的逻辑

  // 返回时转换为ref
  return toRefs(state)
}

export default {
  setup() {
    // 可以在不失去响应性的情况下解构
    const { foo, bar } = useFeatureX()

    return {
      foo,
      bar
    }
  }
}
</code></pre>
<p>要识别数据是否使用上述api处理过，可以使用这些api：isRef<code>、</code>isProxy<code>、</code>isReactive<code>、</code>isReadonly`。</p>
<h3><a id="computed" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>computed</h3>
<pre class="line-numbers"><code class="language-ts">// 只读的
function computed&lt;T&gt;(
  getter: () =&gt; T,
  debuggerOptions?: DebuggerOptions
): Readonly&lt;Ref&lt;Readonly&lt;T&gt;&gt;&gt;

// 可写的
function computed&lt;T&gt;(
  options: {
    get: () =&gt; T
    set: (value: T) =&gt; void
  },
  debuggerOptions?: DebuggerOptions
): Ref&lt;T&gt;
interface DebuggerOptions {
  onTrack?: (event: DebuggerEvent) =&gt; void
  onTrigger?: (event: DebuggerEvent) =&gt; void
}
interface DebuggerEvent {
  effect: ReactiveEffect
  target: any
  type: OperationTypes
  key: string | symbol | undefined
}
</code></pre>
<ul>
<li>接受一个 getter 函数，并根据 getter 的返回值返回一个不可变的响应式 <a href="https://v3.cn.vuejs.org/api/refs-api.html#ref">ref</a> 对象。</li>
</ul>
<pre class="line-numbers"><code class="language-js">const count = ref(1)
const plusOne = computed(() =&gt; count.value + 1)

console.log(plusOne.value) // 2

plusOne.value++ // 错误
</code></pre>
<ul>
<li>接受一个具有 <code>get</code> 和 <code>set</code> 函数的对象，用来创建可写的 ref 对象。</li>
</ul>
<pre class="line-numbers"><code class="language-js">const count = ref(1)
const plusOne = computed({
  get: () =&gt; count.value + 1,
  set: val =&gt; {
    count.value = val - 1
  }
})

plusOne.value = 1
console.log(count.value) // 0
</code></pre>
<h3><a id="watcheffect" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>watchEffect</h3>
<pre class="line-numbers"><code class="language-ts">function watchEffect(
  effect: (onInvalidate: InvalidateCbRegistrator) =&gt; void,
  options?: WatchEffectOptions
): StopHandle

interface WatchEffectOptions {
  flush?: 'pre' | 'post' | 'sync' // 默认：'pre'
  onTrack?: (event: DebuggerEvent) =&gt; void
  onTrigger?: (event: DebuggerEvent) =&gt; void
}

interface DebuggerEvent {
  effect: ReactiveEffect
  target: any
  type: OperationTypes
  key: string | symbol | undefined
}

type InvalidateCbRegistrator = (invalidate: () =&gt; void) =&gt; void

type StopHandle = () =&gt; void
</code></pre>
<p>立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p>
<pre class="line-numbers"><code class="language-js">const count = ref(0)

watchEffect(() =&gt; console.log(count.value))
// -&gt; logs 0

setTimeout(() =&gt; {
  count.value++
  // -&gt; logs 1
}, 100)
</code></pre>
<ul>
<li>停止侦听</li>
</ul>
<p>当 <code>watchEffect</code> 在组件的 <a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup()</a> 函数或<a href="https://v3.cn.vuejs.org/guide/composition-api-lifecycle-hooks.html">生命周期钩子</a>被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。当然也可以显式调用返回值以停止侦听：</p>
<pre class="line-numbers"><code class="language-js">const stop = watchEffect(() =&gt; {
  /* ... */
})
// later
stop()
</code></pre>
<ul>
<li>清除副作用</li>
</ul>
<p>有时副作用函数会执行一些异步的副作用，这些响应需要在其失效时清除。所以侦听副作用传入的函数可以接收一个 <code>onInvalidate</code> 函数作入参，用来注册清理失效时的回调。当以下情况发生时，这个失效回调会被触发：</p>
<ol>
<li>
<p>副作用即将重新执行时</p>
</li>
<li>
<p>侦听器被停止 (如果在 <code>setup()</code> 或生命周期钩子函数中使用了 <code>watchEffect</code>，则在组件卸载时)</p>
</li>
</ol>
<pre class="line-numbers"><code class="language-js">watchEffect(onInvalidate =&gt; {
  const token = performAsyncOperation(id.value)
  onInvalidate(() =&gt; {
    // id has changed or watcher is stopped.
    // invalidate previously pending async operation
    token.cancel()
  })
})
</code></pre>
<p>另外可以使用flush option或者watchPostEffect<code>和</code>watchSyncEffect来调整其刷新时机。</p>
<h3><a id="watch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>watch</h3>
<pre class="line-numbers"><code class="language-ts">// 侦听单一源
function watch&lt;T&gt;(
  source: WatcherSource&lt;T&gt;,
  callback: (
    value: T,
    oldValue: T,
    onInvalidate: InvalidateCbRegistrator
  ) =&gt; void,
  options?: WatchOptions
): StopHandle

// 侦听多个源
function watch&lt;T extends WatcherSource&lt;unknown&gt;[]&gt;(
  sources: T
  callback: (
    values: MapSources&lt;T&gt;,
    oldValues: MapSources&lt;T&gt;,
    onInvalidate: InvalidateCbRegistrator
  ) =&gt; void,
  options? : WatchOptions
): StopHandle

type WatcherSource&lt;T&gt; = Ref&lt;T&gt; | (() =&gt; T)

type MapSources&lt;T&gt; = {
  [K in keyof T]: T[K] extends WatcherSource&lt;infer V&gt; ? V : never
}

// 参见 `watchEffect` 共享选项的类型声明
interface WatchOptions extends WatchEffectOptions {
  immediate?: boolean // 默认：false
  deep?: boolean
}
</code></pre>
<p><code>watch</code> 需要侦听特定的数据源，并在单独的回调函数中执行副作用。默认情况下，它也是惰性的——即回调仅在侦听源发生变化时被调用。</p>
<ul>
<li>与 <a href="https://v3.cn.vuejs.org/api/computed-watch-api.html#watcheffect">watchEffect</a> 相比，<code>watch</code> 允许我们：
<ul>
<li>惰性地执行副作用；</li>
<li>更具体地说明应触发侦听器重新运行的状态；</li>
<li>访问被侦听状态的先前值和当前值。</li>
</ul>
</li>
</ul>
<pre class="line-numbers"><code class="language-js">// 侦听一个 getter
const state = reactive({ count: 0 })
watch(
  () =&gt; state.count,
  (count, prevCount) =&gt; {
    /* ... */
  }
)

// 直接侦听一个 ref
const count = ref(0)
watch(count, (count, prevCount) =&gt; {
  /* ... */
})
</code></pre>
<pre class="line-numbers"><code class="language-js">watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =&gt; {
  /* ... */
})
</code></pre>
<p>当然，前面只是介绍了常用的API，更多的请查看<a href="https://v3.cn.vuejs.org/api/reactivity-api.html">响应式API</a>。</p>
<h2><a id="%E5%BC%8A%E7%AB%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>弊端</h2>
<p>当然组合式API也并不是银弹，至少目前来说不是，还是存在一些问题。</p>
<ul>
<li>Ref 的心智负担</li>
</ul>
<p>读写ref必须带上.value，语法冗余，目前还没有确定的方案来解决此问题。不过尤大给出了refSuger2提案，就看后续社区认可度怎么样了。</p>
<pre class="line-numbers"><code class="language-js">&lt;script setup&gt;
  // declaring a variable that compiles to a ref
  let count = $ref(1)

  console.log(count) // 1

  function inc() {
    // the variable can be used like a plain value
    count++
  }
&lt;/script&gt;

&lt;template&gt;
  &lt;button @click=&quot;inc&quot;&gt;{{ count }}&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li><del>难看冗长的返回语句</del></li>
</ul>
<p><code>setup()</code> 的返回语句变得冗长，像是重复劳动，而且还是存在代码上下横跳问。</p>
<p>在vue3.2提供了SetupScript语法糖，就没有这个问题了。</p>
<ul>
<li>需要更多的自我克制</li>
</ul>
<p>虽然组合式 API 在代码组织方面提供了更多的灵活性，但它也需要开发人员更多地自我克制来 “正确地完成它”。也有些人担心 API 会让没有经验的人编写出面条代码。换句话说，虽然组合式 API 提高了代码质量的上限，但它也降低了下限。</p>
<p>我们需要更多的考虑如何合理的组织代码，推荐根据逻辑关注点将程序分解成函数和模块来组织它。</p>
<h2><a id="setupscript" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SetupScript</h2>
<p><code>&lt;script setup&gt;</code> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。相比于普通的 <code>&lt;script&gt;</code> 语法，它具有更多优势：</p>
<ul>
<li>更少的样板内容，更简洁的代码。</li>
<li>能够使用纯 Typescript 声明 props 和发出事件。</li>
<li>更好的运行时性能 (其模板会被编译成与其同一作用域的渲染函数，没有任何的中间代理)。</li>
<li>更好的 IDE 类型推断性能 (减少语言服务器从代码中抽离类型的工作)。</li>
</ul>
<pre class="line-numbers"><code class="language-vue">&lt;script setup&gt;
// 导入
import { capitalize } from './helpers'
// 组件
import MyComponent from './MyComponent.vue'
// 变量
const msg = 'Hello!'

// 函数
function log() {
  console.log(msg)
}

&lt;/script&gt;

&lt;template&gt;
  &lt;div @click=&quot;log&quot;&gt;{{ msg }}&lt;/div&gt;
  &lt;div&gt;{{ capitalize('hello') }}&lt;/div&gt;
  &lt;MyComponent /&gt;
&lt;/template&gt;
</code></pre>
<p>上面<code>&lt;script setup&gt;</code>中的代码会被编译成组件<code>setup()</code>函数的内容，不同的是<code>&lt;script setup&gt;</code> 中的代码会在每次组件实例被创建的时候执行。而且所有<strong>顶层</strong>的绑定 (包括变量，函数声明，以及 import 引入的内容) 都会暴露给模板，可以直接使用，甚至连组件都无需手动注册。</p>
<p>在继续下面的内容前，我们来看一个词<strong>编译器宏</strong>，他们不需要导入，且会在处理 <code>&lt;script setup&gt;</code> 的时候被编译处理掉。<code>&lt;script setup&gt;</code>提供了如下几个编译器宏：</p>
<pre class="line-numbers"><code class="language-markdown">- defineProps
- defineEmits
- defineExpose
- withDefaults
</code></pre>
<p>接下来看一下<code>&lt;script setup&gt;</code>独有的API：</p>
<ul>
<li><code>defineProps</code>声明Props，接收<code>props</code>选项相同的值</li>
</ul>
<pre class="line-numbers"><code class="language-js">const props = defineProps({
  foo: {
    type:String,
    default:''
  }
})
</code></pre>
<p>如果使用了TypeScript，也可以使用纯类型声明来声明Props。</p>
<pre class="line-numbers"><code class="language-ts">// 普通
const props = defineProps&lt;{
  foo: string
  bar?: number
}&gt;()


// 默认值
interface Props {
  msg?: string
  labels?: string[]
}

const props = withDefaults(defineProps&lt;Props&gt;(), {
  msg: 'hello',
  labels: () =&gt; ['one', 'two']
})
</code></pre>
<ul>
<li><code>defineEmits</code>声明emits，接收 <code>emits</code> 选项相同的值</li>
</ul>
<pre class="line-numbers"><code class="language-ts">// 普通
const emit = defineEmits(['change', 'delete'])
// TS类型声明
const emit = defineEmits&lt;{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}&gt;()
</code></pre>
<ul>
<li><code>defineExpose</code>声明暴露的绑定</li>
</ul>
<p>使用 <code>&lt;script setup&gt;</code> 的组件是<strong>默认关闭</strong>的，也即通过模板 ref 或者 <code>$parent</code> 链获取到的组件的公开实例，不会暴露任何在 <code>&lt;script setup&gt;</code> 中声明的绑定。需要开发者明确声明暴露的属性。</p>
<pre class="line-numbers"><code class="language-js">&lt;script setup&gt;
import { ref } from 'vue'

const a = 1
const b = ref(2)

defineExpose({
  a,
  b
})
&lt;/script&gt;
</code></pre>
<ul>
<li><code>useSlots</code> 和 <code>useAttrs</code>分别对应<code>setupContext.slots</code> 和 <code>setupContext.attrs</code>，也可以在普通的组合式 API 中使用。</li>
</ul>
<pre class="line-numbers"><code class="language-vue">&lt;script setup&gt;
import { useSlots, useAttrs } from 'vue'

const slots = useSlots()
const attrs = useAttrs()
&lt;/script&gt;
</code></pre>
<p>目前还有一些事情是 <code>&lt;script setup&gt;</code>不能做到的，就需要和普通的<code>&lt;script&gt;</code>一起使用:</p>
<pre class="line-numbers"><code class="language-vue">&lt;script&gt;
// 普通 &lt;script&gt;, 在模块范围下执行(只执行一次)
runSideEffectOnce()

// 声明额外的选项
export default {
  inheritAttrs: false,
  customOptions: {}
}
&lt;/script&gt;

&lt;script setup&gt;
// 在 setup() 作用域中执行 (对每个实例皆如此)
&lt;/script&gt;
</code></pre>
<p>更多内容请查看<a href="https://v3.cn.vuejs.org/api/sfc-script-setup.html">SetupScript</a>。</p>
<h1><a id="%E5%85%B6%E4%BB%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他</h1>
<ul>
<li>
<p><a href="https://v3.cn.vuejs.org/api/sfc-style.html">Style新特性</a></p>
<ul>
<li>选择器</li>
</ul>
<pre class="line-numbers"><code class="language-css">/* 深度选择器 */
.a :deep(.b) {
  /* ... */
}

/* 插槽选择器 */
:slotted(div) {
  color: red;
}

/* 全局选择器 */
:global(.red) {
  color: red;
}
</code></pre>
<ul>
<li><code>&lt;style module&gt;</code></li>
</ul>
</li>
</ul>
<pre class="line-numbers"><code class="language-vue">&lt;template&gt;
  &lt;p :class=&quot;$style.red&quot;&gt;
    This should be red
  &lt;/p&gt;
&lt;/template&gt;

&lt;style module&gt;
.red {
  color: red;
}
&lt;/style&gt;
</code></pre>
<p>也可以自定义注入的名称：</p>
<pre class="line-numbers"><code class="language-vue">&lt;template&gt;
  &lt;p :class=&quot;classes.red&quot;&gt;red&lt;/p&gt;
&lt;/template&gt;

&lt;style module=&quot;classes&quot;&gt;
.red {
  color: red;
}
&lt;/style&gt;
</code></pre>
<p>我们可以在组合API中通过<a href="https://v3.cn.vuejs.org/api/global-api.html#usecssmodule"><code>useCssModule</code></a>来使用：</p>
<pre class="line-numbers"><code class="language-js">// 默认, 返回 &lt;style module&gt; 中的类
useCssModule()

// 命名, 返回 &lt;style module=&quot;classes&quot;&gt; 中的类
useCssModule('classes')
</code></pre>
<p>使用状态驱动的动态 CSS：</p>
<pre class="line-numbers"><code class="language-vue">&lt;script setup&gt;
const theme = {
  color: 'red'
}
&lt;/script&gt;

&lt;template&gt;
  &lt;p&gt;hello&lt;/p&gt;
&lt;/template&gt;

&lt;style scoped&gt;
p {
  color: v-bind('theme.color');
}
&lt;/style&gt;
</code></pre>
<ul>
<li>关注<a href="https://github.com/vuejs/rfcs">RFCS</a>，回溯历史，洞悉未来</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【Vue3】实用指南]]></title>
    <link href="https://www.bwrong.cn/17280329757438.html"/>
    <updated>2024-10-04T17:09:35+08:00</updated>
    <id>https://www.bwrong.cn/17280329757438.html</id>
    <content type="html"><![CDATA[
<p>通过上一篇文章<a href="https://juejin.cn/post/7003240214147629070">Vue3基础与入门</a>，我们知道了Vue3的一些基础用法，接下来就看看相关的生态和使用技巧。</p>
<h1><a id="%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何创建项目</h1>
<ul>
<li>VueCli4.5+</li>
</ul>
<p>安装：</p>
<pre class="line-numbers"><code class="language-bash">npm install -g @vue/cli
# OR
yarn global add @vue/cli
</code></pre>
<p>使用：</p>
<pre class="line-numbers"><code class="language-bash">vue create &lt;项目名称&gt;
</code></pre>
<p><img src="https://cli.vuejs.org/cli-select-features.png" alt="cli-select-features" /></p>
<p>或者直接使用<code>vue ui</code>命令，通过图形化界面方式创建。</p>
<p>关于VueCli更多使用方法请查看<a href="https://cli.vuejs.org/zh/">官方文档</a>。</p>
<ul>
<li>Vite</li>
</ul>
<pre class="line-numbers"><code class="language-bash"># npm 6.x
npm init vite@latest my-vue-app --template vue

# npm 7+, 需要额外的双横线：
npm init vite@latest my-vue-app -- --template vue

# yarn
yarn create vite my-vue-app --template vue
</code></pre>
<p>关于Vite更多使用方法请查看<a href="https://cn.vitejs.dev/">官方文档</a></p>
<h1><a id="%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>迁移指南</h1>
<p>关于Vue2的项目是否要迁移到Vue3，个人觉得大可不必，因为官方后续也并没有废弃OptionsApi的计划。而且2.0后续也会维护，推出兼容组合式API的方案。如果是新项目那么可以考虑Vue3。</p>
<p>如果确实需要迁移，建议查看官方的<a href="https://v3.cn.vuejs.org/guide/migration/migration-build.html">迁移指南</a>。</p>
<h1><a id="%E7%94%9F%E6%80%81%E7%8E%B0%E7%8A%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生态现状</h1>
<p>截止到目前，vue3出来已经很长一段时间了，相关生态的适配已经不错了，基本使用是完全没问题的。</p>
<p>下面就大概列一下：</p>
<h2><a id="%E8%A7%84%E6%A8%A1%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>规模化</h2>
<h3><a id="vue-router4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vue-router4</h3>
<ul>
<li>创建路由</li>
</ul>
<pre class="line-numbers"><code class="language-js">import { createRouter } from 'vue-router'
const router = createRouter({
  // ...
})
</code></pre>
<ul>
<li>mode配置</li>
</ul>
<pre class="line-numbers"><code class="language-js">import { createRouter, createWebHistory } from 'vue-router'
// 还有 createWebHashHistory 和 createMemoryHistory

createRouter({
  history: createWebHistory(),
  routes: [],
})
// 设置base
createRouter({
  history: createWebHistory('/base-directory/'),
  routes: [],
})
</code></pre>
<ul>
<li><code>*</code>通配符路由</li>
</ul>
<p>Vue Router 不再使用 <code>path-to-regexp</code>，而是实现了自己的解析系统，允许路由排序并实现动态路由。</p>
<pre class="line-numbers"><code class="language-js">const routes = [
  // pathMatch 是参数的名称，例如，跳转到 /not/found 会得到
  // { params: { params: { pathMatch: ['not', 'found'] }}
  // 这要归功于最后一个 *，意思是重复的参数，如果你
  // 打算直接使用未匹配的路径名称导航到该路径，这是必要的
  { path: '/:pathMatch(.*)*', name: 'not-found', component: NotFound },
  // 如果你省略了最后的 `*`，在解析或跳转时，参数中的 `/` 字符将被编码
  { path: '/:pathMatch(.*)', name: 'bad-not-found', component: NotFound },
]
</code></pre>
<ul>
<li><code>&lt;router-view&gt;</code>、<code>&lt;keep-alive&gt;</code> 和 <code>&lt;transition&gt;</code></li>
</ul>
<pre class="line-numbers"><code class="language-html">&lt;router-view v-slot=&quot;{ Component }&quot;&gt;
  &lt;transition&gt;
    &lt;keep-alive&gt;
      &lt;component :is=&quot;Component&quot; /&gt;
    &lt;/keep-alive&gt;
  &lt;/transition&gt;
&lt;/router-view&gt;
</code></pre>
<ul>
<li>组合式API</li>
</ul>
<pre class="line-numbers"><code class="language-js">import { useRouter, useRoute } from 'vue-router'

export default {
  setup() {
    const router = useRouter() // 相当于 this.$router
    const route = useRoute()  // 相当于 this.$route

    function pushWithQuery(query) {
      router.push({
        name: 'search',
        query: {
          ...route.query,
        },
      })
    }
  },
}
</code></pre>
<pre class="line-numbers"><code class="language-js">import { onBeforeRouteLeave, onBeforeRouteUpdate } from 'vue-router'

export default {
  setup() {
    // 与 beforeRouteLeave 相同，无法访问 `this`
    onBeforeRouteLeave((to, from) =&gt; {
      const answer = window.confirm(
        'Do you really want to leave? you have unsaved changes!'
      )
      // 取消导航并停留在同一页面上
      if (!answer) return false
    })

    const userData = ref()

    // 与 beforeRouteLeave 相同，无法访问 `this`
    onBeforeRouteUpdate(async (to, from) =&gt; {
      //仅当 id 更改时才获取用户，例如仅 query 或 hash 值已更改
      if (to.params.id !== from.params.id) {
        userData.value = await fetchUser(to.params.id)
      }
    })
  },
}
</code></pre>
<p>关于VueRouter4的更多用法请查看<a href="https://next.router.vuejs.org/zh/">官方文档</a>。</p>
<h3><a id="vuex4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vuex4</h3>
<ul>
<li>创建</li>
</ul>
<pre class="line-numbers"><code class="language-js">// src/store/index.js
import { createStore } from 'vuex'

export const store = createStore({
  state () {
    return {
      count: 1
    }
  }
})

// src/main.js
import { createApp } from 'vue'
import { store } from './store'
import App from './App.vue'

const app = createApp(App)
app.use(store)
app.mount('#app')
</code></pre>
<ul>
<li>组合式API</li>
</ul>
<pre class="line-numbers"><code class="language-js">import { useStore } from 'vuex'

export default {
  setup () {
    const store = useStore() // 相当于 this.$store
  }
}
</code></pre>
<p>关于Vuex4的更多用法请查看<a href="https://next.vuex.vuejs.org/zh/index.html">官方文档</a>。</p>
<h2><a id="%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开发工具</h2>
<h3><a id="%E8%84%9A%E6%89%8B%E6%9E%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>脚手架</h3>
<ul>
<li><a href="https://cli.vuejs.org/zh/">VueCli4.5+</a></li>
<li><a href="https://cn.vitejs.dev/">Vite</a></li>
</ul>
<h3><a id="%E5%BC%80%E5%8F%91%E8%BE%85%E5%8A%A9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开发辅助</h3>
<ul>
<li><a href="https://github.com/johnsoncodehk/volar">Volar</a>：Volar 是一个专为 Vue 3 构建的语言支持插件。它基于<a href="https://www.npmjs.com/package/@vue/reactivity"><code>@vue/reactivity</code></a>按需计算一切，实现原生 TypeScript 语言服务级别性能。在Vue3的项目中强烈建议使用该插件，并禁用掉Vuter，它提供了很多好用的东西。</li>
<li><a href="https://devtools.vuejs.org/">VueDevTools</a>：新版插件可以同时兼容Vue2和3，建议安装。</li>
</ul>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20210909112704.png" alt="image-20210909112702791" /></p>
<h3><a id="hooks" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hooks</h3>
<p>Vue3带来的组合式API，让我们在复用代码逻辑的时候可以使用hooks，所以社区出现了一些比较好用的hooks库。</p>
<ul>
<li><a href="https://vueuse.org/">VueUse</a>：VueUse 是一个基于<a href="https://v3.vuejs.org/guide/composition-api-introduction.html">Composition API</a>的实用函数集合</li>
<li><a href="https://www.attojs.org/">VueRequest</a>：一个能轻松帮你管理请求状态（支持SWR，轮询，错误重试，缓存，分页等）的 Vue 3 composition API 请求库</li>
</ul>
<h3><a id="ui%E7%BB%84%E4%BB%B6%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>UI组件库</h3>
<h4><a id="pc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PC</h4>
<ul>
<li><a href="https://element-plus.org/#/zh-CN">Element+</a></li>
<li><a href="https://2x.antdv.com/components/overview/">Antdv2.0</a></li>
<li><a href="https://www.naiveui.com/zh-CN/os-theme">NaiveUI</a></li>
</ul>
<h4><a id="%E7%A7%BB%E5%8A%A8%E7%AB%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>移动端</h4>
<ul>
<li><a href="https://youzan.github.io/vant/v3/#/zh-CN">VantUI 3.0</a></li>
<li><a href="https://nutui.jd.com/3x/#/intro">NutUI 3.0</a></li>
</ul>
<h3><a id="%E8%B7%A8%E7%AB%AF%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>跨端方案</h3>
<ul>
<li><a href="https://uniapp.dcloud.io/">UniApp</a></li>
<li><a href="https://taro.jd.com/">Taro</a></li>
</ul>
<h1><a id="%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84hooks" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何封装自己的Hooks</h1>
<p>下面就就简单的实现一个执行Promise的hooks：</p>
<pre class="line-numbers"><code class="language-js">// usePromise.js
import { reactive, toRefs } from &quot;vue&quot;;
interface _IOptions {
  autoRun?: boolean;
  params?: unknown;
  initData?: unknown;
}
export default &lt;T = unknown&gt;(
  promiseFn: (runParams?: unknown) =&gt; Promise&lt;any&gt;,
  options: _IOptions = {}
) =&gt; {
  const {
    autoRun = false,
    params = null,
    initData = [],
  } = options as _IOptions;
  const state = reactive({
    loading: false,
    data: initData as T,
    error: null,
  });
  const run = (runParams?: unknown) =&gt; {
    state.loading = true;
    return promiseFn(runParams)
      .then((res) =&gt; {
        state.data = res;
      })
      .catch((error) =&gt; {
        console.error(error);
        state.error = error;
      })
      .finally(() =&gt; {
        state.loading = false;
      });
  };
  autoRun &amp;&amp; run(params);
  return {
    run,
    ...toRefs(state),
  };
};
</code></pre>
<p>使用：</p>
<pre class="line-numbers"><code class="language-js">// 接口或者异步任务
const task = () =&gt;
  new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      resolve({
        list: [1, 2, 3],
      });
    }, 1000);
  });
const { run, loading, data } = usePromise&lt;{ list: number[] }&gt;(task);
const handleClick = () =&gt; {
  run() // 手动调用run，或者使用自动触发方式
};
</code></pre>
<h1><a id="%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>个人使用模板</h1>
<p>这个模板可能并不美观或者适合你，网上也有很多优秀的模板，但是我做这个一个是不想太复杂，网上很多都是功能非常完善，但是随之而来的就是使用成本，所以我只封装一些很基础的东西，降低上手难度。这套ui也只是为了应付我这边的项目（有些产品的审美你们懂滴），如果觉得丑，自己重新设计也很简单，或者使用其他优秀的模板。</p>
<h3><a id="%E8%8E%B7%E5%8F%96%E9%80%94%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取途径</h3>
<ul>
<li><a href="https://github.com/BWrong/admin-antd-vue3">GitHub</a></li>
<li><a href="https://github.com/BWrong/misthinTools">MisthinTools</a>：MisthinTools是一款辅助开发软件，目前提供了项目模板和自动部署两个功能，里面也可以下载这套模板。</li>
</ul>
<h3><a id="%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>功能概述</h3>
<ul>
<li>数据请求封装</li>
<li>数据Mock</li>
<li>页面及按钮鉴权</li>
<li>常用布局</li>
<li>一些常用工具</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【前端工程化】篇七 沧海遗珠-其他工具]]></title>
    <link href="https://www.bwrong.cn/17280328680249.html"/>
    <updated>2024-10-04T17:07:48+08:00</updated>
    <id>https://www.bwrong.cn/17280328680249.html</id>
    <content type="html"><![CDATA[
<p>【前端工程化】系列文章链接：</p>
<ul>
<li><a href="https://www.bwrong.cn/post/dev-tools01/">01 扬帆起航-开发环境</a></li>
<li><a href="https://www.bwrong.cn/post/dev-tools02/">02 白璧微瑕-包管理器</a></li>
<li><a href="https://www.bwrong.cn/post/dev-tools03/">03 席卷八荒-Webpack基础篇</a></li>
<li><a href="https://www.bwrong.cn/post/dev-tools04/">04 席卷八荒-Webpack进阶篇</a></li>
<li><a href="https://www.bwrong.cn/post/dev-tools05/">05 未来已来-Babel</a></li>
<li><a href="https://www.bwrong.cn/post/dev-tools06/">06 规矩方圆-ESLint</a></li>
</ul>
<p><em>示例代码仓库：<a href="https://github.com/BWrong/dev-tools">https://github.com/BWrong/dev-tools</a></em></p>
<p><em>声明：如按照文中代码执行报错，请检查依赖版本是否和示例代码仓库中一致。</em></p>
<p>除了前面我们介绍的几种工具外，其实还有很多实用的工具，但是由于太简单了，没必要单独开一篇文章来讲，所以这里就简单介绍一下。</p>
<h1><a id="mock%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MOCK服务</h1>
<p>有的时候，为了赶进度，需要前后端同时开发，接口出来之前，就需要前端进行数据Mock，等接口出来再进行联调。</p>
<p>数据Mock一般有如下几种方式：</p>
<ul>
<li>使用在线mock服务，如<a href="https://www.easy-mock.com/">Easy-mock</a>、<a href="https://hellosean1025.github.io/yapi/">Yapi</a>、<a href="https://apizza.net/pro/#/">Apizza</a>。</li>
<li>基于<a href="https://github.com/typicode/json-server">json-server</a>提供本地服务。</li>
<li>请求拦截，基于<a href="http://mockjs.com/">MockJs</a>创建本地mock服务。</li>
</ul>
<p>我在项目中一般会使用第三种请求拦截，这里就简单分享下我项目中的做法。主要使用<a href="https://www.npmjs.com/package/@bwrong/mock">@bwrong/mock</a>，利用webpack-dev-server的before钩子来做数据mock，以vue项目为例：</p>
<p>实现了如下功能：</p>
<ul>
<li>mock的文件更新，会自动重载</li>
<li>支持接收请求参数，动态处理返回数据</li>
<li>延迟响应：可以设置延迟响应时间，应对调试loading的场景</li>
<li>自定义header：可以全局设置header，也可以为某个mock接口设置header</li>
<li>可以使用mockjs语法</li>
</ul>
<pre class="line-numbers"><code class="language-bash">npm i -D @bwrong/mock
</code></pre>
<pre class="line-numbers"><code class="language-js">// webpack.config.js
const mockServer = require('@bwrong/mock');

module.exports = {
    // ...
    devServer: {
        before(app) {
          mockServer(app, resolve('./mock/'), {
            pattern: '**/[^_]*.js',
            delay: 0,
            prefix: '/api',
            debug: true,
            headers: {},
            watchOptions: {}
          });
        }
    }
}
</code></pre>
<p>在mock目录中，<code>index.js</code>用来做文件自动载入，而其他文件则为模拟数据，每个功能模块可以分割为一个文件，模块化管理。</p>
<p><em>提示：mock的这些文件是在webpack中使用的，需要遵循commonjs规范。</em></p>
<pre class="line-numbers"><code class="language-js">const list = {
  code: 0,
  msg: '',
  'data|10': [
    {
      id: '@id',
      name: '@cname',
      des: '@csentence',
      web: '@url',
      photo: '@image',
      address: '@county(true)',
      email: '@email',
      lastIp: '@ip',
      date: '@datetime(yyyy-MM-dd hh:mm:ss)'
    }
  ]
};
const info = {
  code: 0,
  msg: '',
  data: {
    id: '@id',
    name: '@cname',
    department: 'xxx',
    jibTitle: 'yyy',
    org: 'zzzzz',
    count: {
      sum: '@integer(0,10000)',
      score: '@float(0,5,0,2)',
      today: '@integer(0,200)',
      reservation: '@integer(0,200)'
    }
  }
};
module.exports = [
  {
    url: '/user',
    response: list
  },
  {
    url: '/testhtml',
    method: 'get',
    headers: {
      'Content-Type': 'text/html'
    },
    response: '&lt;html&gt;&lt;h1&gt;html测试&lt;/h1&gt;&lt;a href=&quot;https://www.bwrong.cnm&quot;&gt;bwrong&lt;/a&gt;&lt;/html&gt;'
  },
  {
    url: '/user/info/:id',
    response: (req,res) =&gt; {
      return {
        ...info,
        id: req.params.id
      }
    }
  }
];
</code></pre>
<p>如上仅提供一种思路，如果有更好的方法，欢迎勾搭。</p>
<h1><a id="browserslist" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Browserslist</h1>
<p>用于在不同前端工具之间共享目标浏览器和Node.js版本的配置，消除在每个工具中进行配置的烦恼。<br />
可用于：</p>
<ul>
<li>autoprefix</li>
<li>babel</li>
<li>postcss-preset-env</li>
<li>eslint-plugin-compat</li>
<li>stylelint-no-unsupported-browser-features</li>
<li>postcss-normalize</li>
<li>obsolete-webpack-plugin</li>
</ul>
<h3><a id="%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置方式</h3>
<ul>
<li>package.json中</li>
</ul>
<pre class="line-numbers"><code class="language-json">&quot;browserslist&quot;: [
    &quot;defaults&quot;,
    &quot;not IE 11&quot;,
    &quot;not IE_Mob 11&quot;,
    &quot;maintained node versions&quot;
]
</code></pre>
<ul>
<li>.browserslistrc</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">last 1 version
&gt; 1%
IE 10
</code></pre>
<p>更多使用方式请查看<a href="https://github.com/browserslist/browserslist">browserslist</a>。</p>
<h1><a id="postcss" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PostCSS</h1>
<p>PostCSS是一个允许使用插件来进行样式转换的工具，本身相当于一个平台，通过这个平台我们可以添加相应的插件，来实现各种转换，如<code>autoprefixer</code>、<code>cssmodules</code>、<code>stylelint</code>，而且可以和很多工具结合使用。</p>
<pre class="line-numbers"><code class="language-js">// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        exclude: /node_modules/,
        use: [
          {
            loader: 'style-loader',
          },
          {
            loader: 'css-loader',
            options: {
              importLoaders: 1,
            }
          },
          {
            loader: 'postcss-loader'
          }
        ]
      }
    ]
  }
}
</code></pre>
<pre class="line-numbers"><code class="language-js">// postcss.config.js
module.exports = {
  plugins: [
    require('precss'),
    require('autoprefixer')
  ]
}
</code></pre>
<p>具体的使用方法请查看官方文档<a href="https://postcss.org/">官网</a>。</p>
<h1><a id="git" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Git</h1>
<p>我相信，git大家都很熟悉了，而且网上的教程也有很多，这里我就不介绍了。但是在使用的过程中我发现有两个问题还是值得再提一下。</p>
<ul>
<li>分支管理：很多人都是只有一个master分支，所有的东西都是在上面操作，这样在大一点的团队或者有多个环境的时候，会很不方便。所以便有了分支管理策略的说法，可以看看阮一峰老师的文章<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">Git分支管理策略</a>。</li>
<li>提交信息：我曾经遇到过一个同事，所有的git提交信息都是'修改'，如果要让做代码回溯，我相信加班是跑不脱了。友好的提交信息不仅可以清晰的看到开发记录，而且还可以用来生成更新日志。关于提交规范，社区其实有很多方案，目前用的比较多的是<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">Angular规范</a>，也可以看看阮一峰老师的另一篇文章<a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></li>
</ul>
<p>这些方案都是一些参考，并不一定就适合每个团队，最好的是根据团队情况制定出符合需求的一套规范，因地制宜才能事半功倍。</p>
<p>阅读资料：<a href="https://www.notion.so/57b80f3f75b741e3a54546c20ae5e8e7">项目规范化开发探索</a></p>
<h1><a id="editorconfig" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>EditorConfig</h1>
<p>EditorConfig有助于维护跨多个编辑器和IDE从事同一项目的多个开发人员的一致编码风格，团队必备神器。</p>
<p><strong>.editorconfig文件</strong>:</p>
<pre class="line-numbers"><code class="language-markdown"># EditorConfig is awesome: https://EditorConfig.org

# top-most EditorConfig file 表示是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件
root = true

# Unix-style newlines with a newline ending every file 对于所有的文件  始终在文件末尾插入一个新行
[*]
end_of_line = lf
insert_final_newline = true

# Matches multiple files with brace expansion notation
# Set default charset  对于所有的js,py文件，设置文件字符集为utf-8
[*.{js,py}]
charset = utf-8

# 4 space indentation 控制py文件类型的缩进大小
[*.py]
indent_style = space
indent_size = 4

# Tab indentation (no size specified) 设置某中文件的缩进风格为tab Makefile未指明
[Makefile]
indent_style = tab

# Indentation override for all JS under lib directory  设置在lib目录下所有JS的缩进为
[lib/**.js]
indent_style = space
indent_size = 2

# Matches the exact files either package.json or .travis.yml 设置确切文件 package.json/.travis/.yml的缩进类型
[{package.json,.travis.yml}]
indent_style = space
indent_size = 2

</code></pre>
<p>配置说明：</p>
<pre class="line-numbers"><code class="language-plain_text">
indent_style    设置缩进风格(tab是硬缩进，space为软缩进)
indent_size     用一个整数定义的列数来设置缩进的宽度，如果indent_style为tab，则此属性默认为tab_width
tab_width       用一个整数来设置tab缩进的列数。默认是indent_size
end_of_line     设置换行符，值为lf、cr和crlf
charset         设置编码，值为latin1、utf-8、utf-8-bom、utf-16be和utf-16le，不建议使用utf-8-bom
trim_trailing_whitespace  设为true表示会去除换行行首的任意空白字符。
insert_final_newline      设为true表示使文件以一个空白行结尾
root           表示是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件
</code></pre>
<h1><a id="%C2%A0%E8%84%9A%E6%89%8B%E6%9E%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a> 脚手架</h1>
<p>脚手架大家都不陌生，VueCli、Vite、CreateReactApp我相信大家都是比较熟悉了，他们的目的都是快速生成项目模板，提高开发效率。但是这些模板都是很基础的，当团队有一定规模或者有一定积累的时候，定制一些自己的项目模板就很有必要了。这时就可以考虑自己开发一套脚手架来管理这些模板，方便管理维护。</p>
<p>这类的文章网上多如牛毛，其内容都是差不多，大致分为两种：</p>
<ul>
<li>基于<a href="https://yeoman.io/">Yeoman</a>实现：相当于一个开发脚手架的框架，很多东西它已经提供，自己吧模板放进去就OK，社区也有很多模板可以使用。</li>
<li>开发脚手架：灵活，整个底层需要自己借助一些工具实现，具体的可以查看我之前的一篇博客<a href="https://www.bwrong.cn/post/cli/">也来盘盘前端脚手架的那些事儿</a>。</li>
</ul>
<h1><a id="%E7%BB%93%E8%AF%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结语</h1>
<p>终于写完了，原本计划一个月结果拖拖拉拉到差不多三个月，不过总归是有所成果了。</p>
<h3><a id="%E5%88%9D%E8%A1%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>初衷</h3>
<p>写这系列文章，其实有几个因素：</p>
<ul>
<li>自己对效率工具类的东西比较感兴趣，可能是因为技术太渣了吧</li>
<li>帮助团队提高开发效率和质量，现在不都是讲合作吗，只有团队提升了，自己才能获得更好的成长，水涨船高嘛</li>
</ul>
<h3><a id="%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>问题</h3>
<p>由于第一次写这种长文，问题不少：</p>
<ul>
<li>文章内容组织欠佳</li>
<li>文章排班还需要优化</li>
<li>文字功底还需要提升</li>
<li>拖延比较严重，前面激情满满，后面停滞不前</li>
<li>...</li>
</ul>
<h3><a id="%E5%90%8E%E7%BB%AD%E8%AE%A1%E5%88%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>后续计划</h3>
<p>后面如果有时间，这个系列可能还会更新一些东西：</p>
<ul>
<li>开发规范</li>
<li>自动化测试</li>
<li>CI/CD</li>
</ul>
<p>自己收获还是蛮大的，为了尽量保证内容的完备性和正确性，会去查阅很多资料，加深了记忆；而且把这些列知识串起来了，不再是一个个孤岛，更加系统化了；另外有了这部分内容，收藏夹好多吃灰的文章就可以解放了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【前端工程化】篇六 规矩方圆-ESLint]]></title>
    <link href="https://www.bwrong.cn/17280328175326.html"/>
    <updated>2024-10-04T17:06:57+08:00</updated>
    <id>https://www.bwrong.cn/17280328175326.html</id>
    <content type="html"><![CDATA[
<p>字数：7543， 阅读时间：20分钟，点击<a href="https://www.bwrong.cn/post/dev-tools06/">阅读原文</a></p>
<blockquote>
<p>天下从事者，不可以无法仪。无法仪而其事能成者，无有也。        -------墨子《法仪》</p>
</blockquote>
<p>【前端工程化】系列文章链接：</p>
<ul>
<li><a href="https://www.bwrong.cn/post/dev-tools01/">01 扬帆起航-开发环境</a></li>
<li><a href="https://www.bwrong.cn/post/dev-tools02/">02 白璧微瑕-包管理器</a></li>
<li><a href="https://www.bwrong.cn/post/dev-tools03/">03 席卷八荒-Webpack基础篇</a></li>
<li><a href="https://www.bwrong.cn/post/dev-tools04/">04 席卷八荒-Webpack进阶篇</a></li>
<li><a href="https://www.bwrong.cn/post/dev-tools05/">05 未来已来-Babel</a></li>
</ul>
<p><em>示例代码仓库：<a href="https://github.com/BWrong/dev-tools">https://github.com/BWrong/dev-tools</a></em></p>
<p><em>声明：如按照文中代码执行报错，请检查依赖版本是否和示例代码仓库中一致。</em></p>
<p>古人有云“不以规矩，不能成方圆”，看来规矩方圆之说古已有之，而在高度文明的现代社会，法制规则更加完善，只有大家遵守这些规则，我们的生活才能井井有条，社会才能稳定和谐。</p>
<p>万事均有规矩，编程也是如此，尤其是在多人协作的时候，遵循好的编程规范尤其重要，所以也诞生了很多的工具来做代码审查工作。这篇文章我们仅介绍<code>ESLint</code>，它也是目前前端最流行的代码审查工具。</p>
<h1><a id="%E6%A6%82%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概述</h1>
<p><code>JavaScript</code>是一门动态弱类型语言，虽说使用时很灵活，不过也容易出错。而<code>Lint</code>工具有助于我们在开发时就发现由于书写不规范导致的一些问题。</p>
<p>Lint工具主要解决如下问题：</p>
<ul>
<li>避免一些低级错误的发生，找出语法错误，冗余代码</li>
<li>确保代码遵循推荐的风格，统一团队的代码规范</li>
</ul>
<h2><a id="%E8%BF%9B%E5%8C%96%E5%8F%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进化史</h2>
<p>在Lint工具（仅指JS）的进化过程中，诞生过三个有代表性的工具：JSLint、JSHint 和 ESLint。</p>
<ul>
<li>JSLint</li>
</ul>
<p>JSLint是第一个JavaScript的Lint工具，它是由Douglas Crockford 大佬（《JavaScript 语言精粹》作者）开发，当时前端还处在萌芽阶段，一片混沌，Lint工具作用巨大。不过如作者大佬一般，JSLint极具个人风格，它不允许使用者更改规则，如果要使用它，就必须遵守全部规则。</p>
<ul>
<li>JSHint</li>
</ul>
<p>由于JSLint无法更改规则，很多人无法忍受，所以JSHint出现了，它提供了丰富的配置项，开发者可以根据自己的情况来做个性化的定制。而且它是由社区驱动，所以它出现后，用户迅速增长。早期的jQuery也是采用JSHint做代码检查。</p>
<ul>
<li>ESLint</li>
</ul>
<p>在2013年的时候，Nicholas C. Zakas (《JavaScript 高级程序设计》作者)在开发时，想在JSHint增加一条自定义处理规则，可是发现并不可行。受到PHP Linter的启发，在同年六月份的一个周末，大神就自己搞了一个Linter，这就是ESLint。这就是牛人，一言不合就造轮子。</p>
<p>与前面两个工具不同，ESLint是通过AST的方式对代码进行解析检测，具有很高的扩展性，所以在ES6和jsx这类东西出现后，只要有对应的解析器或插件，就可以快速支持，这是其他两个工具无法实现的。所以ESLint在ES6出现后迅速火了起来，Babel也为它提供了babel-eslint解析器，让ESLint更加流行。</p>
<p>在2016年，ESLint整合了和它同一时期诞生的另一个Linter工具JSCS（也是基于AST的方式），至此，ESLint坐稳了JS Linter的王座，成为了前端工程化必不可少的一个工具。</p>
<p>在TypeScript前期，并没有使用ESLint，而是使用了自研TSLint，但是由于其设计问题，在2019年的时候，官方放弃了TSLint，投入了ESLint的怀抱，通过为ESLint提供解析器和插件的方式来进行支持。</p>
<p>ESLint无疑是成功的，它的成功得益于采用了良好的架构设计：</p>
<ol>
<li>关注点分离：解析器、核心、规则都是相对独立的，各司其职，具有良好的可维护性和可扩展性。</li>
<li>支持自定义规则：可以自定义规则及相关事件，给与开发者更多的扩展空间。迄今，社区已经拥有许多的规则插件，如<code>eslint-plugin-react</code>，<code>eslint-plugin-vue</code>等。</li>
<li>保持内核尽量简单：内核尽量保持简单，通过插件的方式进行功能扩展，核心不和任何框架、库耦合，具有较强的适应性。</li>
</ol>
<p>关于ESLint成功的原因，Zakas也专门写了<a href="https://humanwhocodes.com/blog/2016/02/reflections-on-eslints-success/">一篇文章</a>，想了解的可以看看。</p>
<p>参考资料：<a href="https://zhuanlan.zhihu.com/p/34656263/">JS Linter 进化史</a></p>
<h2><a id="eslint" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ESLint</h2>
<p><code>ESLint</code>官方定义为一个用于查找并报告代码中问题的工具，并且支持部分问题自动修复。除了JSLint和JSHint类似的功能外，ESLint还有如下特点：</p>
<ul>
<li>ESLint使用<a href="https://github.com/eslint/espree">Espree</a>进行JavaScript解析。</li>
<li>ESLint使用AST评估代码中的模式。</li>
<li>ESLint是完全可插拔的，每个规则都是一个插件，可以在运行时添加更多内容。</li>
</ul>
<p>说了这么多，下面我们就一起来看下如何使用ESLint。</p>
<h1><a id="%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用</h1>
<h2><a id="%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装</h2>
<p>可以采用全局或者本地安装，推荐使用本地安装，后面我们也是采用此方式。</p>
<pre class="line-numbers"><code class="language-shell"># 全局安装
npm install -g eslint
# 项目本地安装（推荐）
npm install -D eslint
</code></pre>
<p>安装成功后，在项目根目录执行如下命令，完成一系列设置来创建配置文件。</p>
<pre class="line-numbers"><code class="language-shell">npx eslint --init
</code></pre>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20200918112423.png" alt="image-20200918112422980" /></p>
<p>执行如上命令，会在项目根目录创建一个<code>.eslintrc.js</code>文件，内容如下：</p>
<pre class="line-numbers"><code class="language-js">module.exports = {
    'env': { // 环境设置
        'browser': true,
        'es2021': true,
        'node': true
    },
    'extends': 'eslint:recommended', // 使用官方或社区预设的规则
    'parserOptions': { // 解析器配置
        'ecmaVersion': 12,
        'sourceType': 'module'
    },
    'rules': {  // 自定义规则
        'indent': [
            'error',
            4
        ],
        'linebreak-style': [
            'error',
            'windows'
        ],
        'quotes': [
            'error',
            'single'
        ],
        'semi': [
            'error',
            'always'
        ]
    }
};
</code></pre>
<p>这个就是ESLint的配置文件，当然还有很多其他方式进行配置，我们在后面的配置部分会详细介绍，这里我们暂时使用这种方式。</p>
<h2><a id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何使用</h2>
<p>ESLint使用非常灵活，可以在多种场景使用，下面我们就瞧瞧。</p>
<h3><a id="%E5%91%BD%E4%BB%A4%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>命令行</h3>
<p>现在创建一个文件<code>./src/index.js</code>：</p>
<pre class="line-numbers"><code class="language-js">// ./src/index.js
let test = 1
</code></pre>
<p>然后在命令行输入命令：</p>
<pre class="line-numbers"><code class="language-shell">npx eslint ./src/index.js
</code></pre>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20200918171659.png" alt="image-20200918171659654" /></p>
<p>可以看到，ESLint给我们提示了两个错误：</p>
<ul>
<li><code>test</code>变量定义了，但是未使用</li>
<li><code>let test = 1</code>后面缺少分号，因为在上面的配置文件中是要求始终添加分号的</li>
</ul>
<p>这就是ESLint的第一个功能：找出并警告代码中有问题的地方。</p>
<p>像给代码加上分号这种小事情，其实没必要我们亲力亲为的（懒果然是程序猿的共性），ESLint提供了自动修复的功能，可以帮我们自动修复一些简单的问题。</p>
<p>执行命令，加上<code>--fix</code>参数：</p>
<pre class="line-numbers"><code class="language-shell">npx eslint --fix ./src/index.js
</code></pre>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20200918172959.png" alt="image-20200918172959131" /></p>
<p>我们可以看到，只有一个错误了，另外再看下<code>./src/index.js</code>：</p>
<pre class="line-numbers"><code class="language-js">// ./src/index.js
let test = 1;
</code></pre>
<p>是不是自动加上分号了呢？oh~oh!，太酷了。</p>
<p><strong>注意：</strong></p>
<ol>
<li>自动修复只能修复一些简单的问题，一般是书写格式之类的，修复不会影响代码的执行结果，如上面的第一个问题，ESLint是不知道如何修复，所以它不会处理，而直接抛出报错或警告了。</li>
<li>执行命令时，除了指定具体的文件外，也可以使用通配符，指定多个文件，如<code>npx eslint ./src/**</code>就可以检查src目录下的所有文件。</li>
</ol>
<p>上面我们介绍了ESLint最基础的使用场景---命令行方式，这种方式除了上面的用法，还可以传入很多参数，下面列出几个常用的：</p>
<ul>
<li><code>-c</code>， <code>--config</code>：指定配置文件</li>
<li><code>--env</code>：指定执行环境</li>
<li><code>--global</code>：定义全局变量</li>
<li><code>-h</code>：查看帮助</li>
</ul>
<p>更多用法请查看<a href="https://eslint.org/docs/user-guide/command-line-interface">官方文档</a>。</p>
<h3><a id="webpack%EF%BC%88eslint-loader%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Webpack（eslint-loader）</h3>
<p>前面我们介绍了如何在命令行模式下的使用，在需要检测的时候必须要在命令行中执行相关命令才可以，有没有方法能够在我们启动项目的时候自动运行呢？</p>
<p>答案是肯定的，webpack作为当下最流行的构建工具，ESLint也为其提供了<code>eslint-loader</code>，以在构建的时候来做代码检查和修复。</p>
<p>首先需要安装<code>eslint-loader</code>和<code>eslint</code>：</p>
<pre class="line-numbers"><code class="language-shell">npm install eslint-loader eslint --save-dev
</code></pre>
<p>然后在webpack配置中添加对应配置：</p>
<pre class="line-numbers"><code class="language-js">// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'eslint-loader',
        options: {
          // 这里是eslint的配置，建议是用配置文件
        },
      },
    ],
  },
  // ...
};
</code></pre>
<p><strong>注意：</strong></p>
<ol>
<li>因为ESLint是针对我们书写的代码做检查，而不是针对其他loader编译后的代码，所以我们必须要保证<code>eslint-loader</code>最先执行，所以应该放在该规则的最后面，也可以使用<code>enforce: 'pre'</code>设置来强制设置到其他loader前面执行。</li>
<li><code>eslint-loader</code>的配置推荐放在eslint的配置文件中，而不放在loader的options中。</li>
</ol>
<p>如上配置以后，在执行构建命令的时候，就会先执行检查并在终端输出检查结果（仅做检查，不会影响构建结果）。</p>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20200922160134.png" alt="image-20200922160134442" /></p>
<p>不过，我们一般编码的时候，终端都运行在后台的，查看这些信息就必须要来回切换，甚是不便。作为一个懒癌患者，肯定是不愿意的。用过vue-cli的同学都知道，如果有错误提示，是会在浏览器弹出浮层提示的。</p>
<p>其实配置相当简单，不明白的自己回去看看前面webpack那部分吧。</p>
<pre class="line-numbers"><code class="language-js">// webpack.config.js
module.exports = {
    // ...
 	devServer: {
        overlay: true  // 默认此项为false，设置为true即可
    }
    // ...
}
</code></pre>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20200922161111.png" alt="image-20200922161111872" /></p>
<h3><a id="%E5%9C%A8%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%88vscode%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在编辑器中使用（VSCode）</h3>
<p>前面介绍的使用方式已经非常方便了，但是作为一个懒癌重度患者，在使用中我还是发现了一些问题：</p>
<ul>
<li>需要编译后才能发现代码中的问题，而不是书写代码的时候，所以缺乏及时性，那能在书写的时候就立即提示吗？</li>
<li>如果是一些简单的格式问题，在保存前，能不能执行自动修复，而不用我们来操心呢？</li>
<li>一些古老的项目并没有使用webpack来构建，在我们编码的时候，怎么给与错误提示呢？</li>
</ul>
<p>果然懒才是生产力，一些大佬为编辑器提供了ESLint插件，完美的解决了如上的问题。</p>
<p><em>提示：下面仅介绍VSCode中的使用，其他编辑器请自行查阅使用方法。</em></p>
<p>首先安装<a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint</a>插件，在VSCode中<code>ctrl+p</code>然后输入以下命令：</p>
<pre class="line-numbers"><code class="language-shell">ext install dbaeumer.vscode-eslint
</code></pre>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20200922163527.png" alt="image-20200922163527375" /></p>
<p>现在用VSCode打开前面的代码，可以看到有的代码下面会有黄色（警告）或者红色（错误）的波浪线提示，把鼠标移上去，还可以看到错误详情以及修复方案。</p>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20200922163709.png" alt="image-20200922163709515" /></p>
<p>现在，我们书写代码的时候，就会立即给与提示，不用再去终端或者浏览器查看错误信息，然后再去文件中查找问题代码了。</p>
<p>那么，第二问题呢，一些简单的格式能不能自动修复呢？</p>
<p>只需要在VSCode的配置中加上如下配置，当保存文件的时候，一些简单的格式问题就会被自动修复，是不是又可以多撸几把王者农药了呢。</p>
<pre class="line-numbers"><code class="language-json">&quot;editor.codeActionsOnSave&quot;: {
    &quot;source.fixAll.eslint&quot;: true
 }
</code></pre>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20200922170339.gif" alt="img" /></p>
<p><em>提示：vscode-eslint是支持<a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">配置</a>的，提供了<code>eslint.options</code>来设置全局配置，如果项目中没有配置，会以这里的配置兜底。</em></p>
<pre class="line-numbers"><code class="language-json">&quot;eslint.options&quot;: {
  &quot;root&quot;: true,
  &quot;plugins&quot;: [],
  &quot;env&quot;: {},
  &quot;extends&quot;: [],
  &quot;rules&quot;: {},
  &quot;exclude&quot;: []
  &quot;parserOptions&quot;: {}
},
</code></pre>
<p>对于一些项目，即使没有使用webpack也没有关系，只需要在项目中安装ESLint和添加对应的配置，在编写代码的时候也是能够生效的。</p>
<blockquote>
<p>ESLint插件还提供了全局的方式，全局安装ESLint，并在VSCode的ESLint插件配置中放入eslint规则配置，则会对所有打开的文件生效。</p>
<p>如果项目中也有自己的配置，那么会执行配置合并，如果配置项有冲突，项目中的配置项拥有优先使用权，会覆盖全局的配置。</p>
</blockquote>
<p>至此，ESLint常见的使用方式就介绍完了，接下来我们就来看看比较核心的东东。</p>
<h1><a id="%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置</h1>
<p>ESLint提供了丰富的配置项，让使用者可以根据自己的需求对其<strong>解析器</strong>、<strong>环境</strong>、<strong>全局</strong>、<strong>规则</strong>、<strong>插件</strong>进行配置。</p>
<p>具体这些配置项我们后面再详细介绍，先来看看如何添加配置。</p>
<h2><a id="%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置方式</h2>
<p>ESLint支持多种配置方式，总结起来大概分为如下几种：</p>
<ul>
<li><a href="https://eslint.org/docs/user-guide/command-line-interface#-rule">命令行</a>：在执行eslint命令的时候，将配置信息通过cli提供的配置参数传入，使用比较繁琐，一般不使用此方式。</li>
</ul>
<pre class="line-numbers"><code class="language-shell"># 一些常用配置
# --env：设置环境
eslint --env browser,node file.js
eslint --env browser --env node file.js
# --global：设置全局变量
eslint --global require,exports:true file.js
eslint --global require --global exports:true
# --rule：设置规则
eslint --rule 'quotes: [2, double]'
eslint --rule 'guard-for-in: 2' --rule 'brace-style: [2, 1tbs]'
eslint --rule 'jquery/dollar-sign: 2'
# ...
</code></pre>
<ul>
<li><a href="https://eslint.org/docs/user-guide/configuring#using-configuration-comments">内联注释</a>：将配置以注释的方式写在代码文件中（一般放在文件的最前面），由于缺乏复用性，所以也不常用，如果某个文件需要特殊配置，可以采用此方式。</li>
</ul>
<pre class="line-numbers"><code class="language-js">/* eslint-env browser, node */     // 设置环境
/* global var1, var2:writable */   // 设置全局变量
/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; */    // 设置规则
</code></pre>
<ul>
<li><a href="https://eslint.org/docs/user-guide/configuring#using-configuration-files-2">配置文件</a>（推荐）：提供<code>.eslintrc.*</code>文件或者在<code>package.json</code>中<code>eslintConfig</code>属性中配置。</li>
</ul>
<p><em>提示：由于使用配置文件简单直观，所以是我最常用的方式，下面的内容也基于此方式，其他方式也大同小异，唯格式有所差异。</em></p>
<p>上面的.eslintrc.中的是指ESLint的配置文件支持多种文件格式：<code>js</code>、<code>cjs</code>、<code>yaml</code>、<code>yml</code>、<code>json</code>，如果在当前目录同时存在多个格式的配置文件，ESLint仅会选择其中一个，优先选择的顺序如下：</p>
<ol>
<li><code>.eslintrc.js</code>（推荐，<code>eslint --init</code>生成的默认就是此格式的配置）</li>
<li><code>.eslintrc.cjs</code></li>
<li><code>.eslintrc.yaml</code></li>
<li><code>.eslintrc.yml</code></li>
<li><code>.eslintrc.json</code></li>
<li><code>.eslintrc</code>(废弃)</li>
<li><code>package.json</code></li>
</ol>
<p>由于<code>.eslintrc.js</code>配置比较灵活且具有较高的优先级，所以一般我们都适用此格式的配置文件。</p>
<h4><a id="%E9%85%8D%E7%BD%AE%E7%BB%84%E5%90%88%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置组合及优先级</h4>
<p>当使用<code>.eslintrc.*</code>和<code>package.json</code>方式进行配置时，会触发级联组合行为。它的工作方式是：</p>
<ul>
<li>优先使用就近的<code>.eslintrc.*</code>配置，然后在所有父级目录依次查找所有配置，以此类推，直到根目录或找到某个配置了<code>&quot;root&quot;:true</code>的配置文件，才会停止继续向上级查找。</li>
<li>上一步匹配到的所有配置将会按照查找到的顺序（由内而外）进行组合，内层的配置拥有更高的优先级，如果组合后配置项有冲突，将采用高优先级的配置项（内&gt;外）。</li>
<li>如果在同一目录中同时有<code>.eslintrc.*</code>和<code>package.json</code>文件，将使用前者的配置，后者的配置将会忽略。</li>
<li>可以在配置中添加<code>&quot;root&quot;:true</code>将该目录强制设置为根目录，来阻止继续查找。</li>
</ul>
<p>举个:chestnut:：</p>
<pre class="line-numbers"><code class="language-plain_text">your-project
├── package.json  &lt;- { &quot;eslintConfig&quot;: {...} }
├── .eslintrc.js
├── lib
  └── source.js
└─┬ test1
  ├── .eslintrc.js
  └── index.js
└─┬ test2
  ├── .eslintrc.js  &lt;- { &quot;root&quot;: true }
  └── index.js
</code></pre>
<p>如上的目录结构，大概有以下几种组合方式：</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>生效配置</th>
<th>组合方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/lib/*</code></td>
<td><code>/.eslintrc.js</code></td>
<td><code>lib</code>目录无配置文件，会向上级查找，找到<code>/.eslintrc.js</code>和<code>/package.json</code>，但是它们在同一目录，仅<code>/.eslintrc.js</code>生效。</td>
</tr>
<tr>
<td><code>/test1/*</code></td>
<td><code>/test1/.eslintrc.js</code>+<code>/.eslintrc.js</code></td>
<td><code>test1</code>目录找到配置后，继续向上查找，找到<code>/.eslintrc.js</code>和<code>/package.json</code>（忽略），将<code>/test1/.eslintrc.js</code>和<code>/.eslintrc.js</code>组合</td>
</tr>
<tr>
<td><code>/test2/*</code></td>
<td><code>/test2/.eslintrc.js</code></td>
<td><code>test2</code>目录存在配置，且配置了<code>&quot;root&quot;:true</code>，所以不会向上查找，仅<code>/test2/.eslintrc.js</code>生效</td>
</tr>
</tbody>
</table>
<p>ESLint支持的配置方式比较多，有必要介绍一下他们的优先级，从高到低的顺序如下：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>配置方式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>内联注释配置</td>
<td><code>/*eslint-disable*/</code> 和 <code>/*eslint-enable*/</code> <code>/*global*/</code> <code>/*eslint*/</code> <code>/*eslint-env*/</code></td>
</tr>
<tr>
<td>2</td>
<td>命令行选项</td>
<td><code>--global</code> <code>--rule</code> <code>--env</code> <code>-c</code>， <code>--config</code></td>
</tr>
<tr>
<td>3</td>
<td>项目级配置文件</td>
<td><code>.eslintrc.*</code>或<code>package.json</code></td>
</tr>
</tbody>
</table>
<p>了解这些组合规则及优先级很有必要，可以进行合理利用。</p>
<h2><a id="%E9%85%8D%E7%BD%AE%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置项</h2>
<p>前面我们有提到，ESLint配置主要是针对<strong>解析器</strong>、<strong>环境</strong>、<strong>全局</strong>、<strong>规则</strong>、<strong>插件</strong>这几个内容，那么下面我们就来仔细看看。</p>
<p><em>提示：后面的配置均采用<code>.eslintrc.js</code>方式，如需其他方式请自行探索。</em></p>
<h3><a id="%E8%A7%A3%E6%9E%90%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解析器</h3>
<p>默认情况下，ESLint使用<a href="https://github.com/eslint/espree">Espree</a>作为其解析器，不过我们也可以指定其他解析器。</p>
<pre class="line-numbers"><code class="language-js">// .eslintrc.js
module.exports = {
	parser: &quot;esprima&quot;
}
</code></pre>
<p>下面是一些常用的解析器：</p>
<ul>
<li><a href="https://www.npmjs.com/package/esprima">Esprima</a>：ESLint早期采用的解析器，Espree最初就是在它基础上创建的。</li>
<li><a href="https://www.npmjs.com/package/@babel/eslint-parser">@ babel/eslint-parser</a> ：使babel和ESLint兼容，对一些Babel语法提供支持。</li>
<li><a href="https://www.npmjs.com/package/@typescript-eslint/parser">@ typescript-eslint/parser</a>：TSLint被弃用后，TypeScript提供了此解析器用于将其与ESTree兼容，使ESLint对TypeScript进行支持。</li>
</ul>
<p>除了配置解析器，还可以提供一些选项对解析器进行配置：</p>
<pre class="line-numbers"><code class="language-js">// .eslintrc.js
module.exports = {
	&quot;parser&quot;: &quot;esprima&quot;,
	&quot;parserOptions&quot;: {
        &quot;ecmaVersion&quot;: 6, // 默认5，指定ECMAScript版本，支持年份和版本号两种格式，用于支持该版本新语法
        &quot;sourceType&quot;: &quot;module&quot;, // 默认'script'，使用了ESModule需要设置为'module'，否则import、export关键字会报错
        &quot;ecmaFeatures&quot;: {
            &quot;jsx&quot;: true,   // 启用jsx语法
            &quot;globalReturn&quot;: false,  // 是否允许全局return
            &quot;impliedStrict&quot;: false  // 是否启用严格模式，仅ecmaVersion大于5有效
        }
    }
}
</code></pre>
<h3><a id="%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>环境</h3>
<p>环境配置主要用于预定义一些全局环境变量及相应环境的语法支持，可以指定一个或者多个环境。</p>
<pre class="line-numbers"><code class="language-js">// .eslintrc.js
module.exports = {
    &quot;env&quot;: {
        &quot;browser&quot;: true,
        &quot;node&quot;: true
    }
}
</code></pre>
<p>常用的环境如下：</p>
<table>
<thead>
<tr>
<th>环境</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>browser</code></td>
<td>添加浏览器的全局变量，如<code>window</code></td>
</tr>
<tr>
<td><code>node</code></td>
<td>添加Node.js全局变量和Node.js作用域</td>
</tr>
<tr>
<td><code>es6</code>、 <code>es2017</code>、<code>es2020</code>、 <code>es2021</code>...</td>
<td>添加该版本的全局变量，并将<code>parserOptions.ecmaVersion</code>设置为该版本号</td>
</tr>
<tr>
<td><code>amd</code></td>
<td>添加<code>require()</code>和<code>define()</code>全局变量</td>
</tr>
<tr>
<td><code>jquery</code></td>
<td>添加<code>jQuery</code>和<code>$</code>全局变量</td>
</tr>
</tbody>
</table>
<p>更多环境请查看<a href="https://eslint.org/docs/user-guide/configuring#specifying-environments">官方文档</a>。</p>
<p>一些插件中提供了环境，可以按照如下格式使用：</p>
<pre class="line-numbers"><code class="language-js">// .eslintrc.js
module.exports = {
    &quot;plugins&quot;: [&quot;example&quot;],
    &quot;env&quot;: {
        &quot;example/custom&quot;: true
    }
}
</code></pre>
<h3><a id="%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全局变量</h3>
<p>在使用一些全局变量，而这些变量又没在当前文件中定义时，ESLint会抛出错误，告诉我们该变量未定义，这时我们可以手动在配置文件中将该变量添加到全局变量。</p>
<pre class="line-numbers"><code class="language-js">// .eslintrc.js
module.exports = {
    &quot;globals&quot;: {
        &quot;var1&quot;: &quot;writable&quot;,
        &quot;var2&quot;: &quot;readonly&quot;,
        &quot;var3&quot;: &quot;off&quot;
    }
}
</code></pre>
<p>支持三种配置值：</p>
<ul>
<li>writable：允许变量被修改覆盖</li>
<li>readonly：设置变量仅为只读，不可覆盖</li>
<li>off：设置变量禁止使用</li>
</ul>
<h3><a id="%E6%8F%92%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>插件</h3>
<p>ESLint提供了插件机制，可以让开发者自定义校验逻辑、校验规则，或对一些特殊语法提供支持，插件可以对外提供其扩展配置、规则、环境等配置。ESLint的插件均以<code>eslint-plugin-</code>开头，在配置的时候需要省略该前缀。</p>
<pre class="line-numbers"><code class="language-js">// .eslintrc.js
module.exports = {
    // ...
    &quot;plugins&quot;: [
        &quot;jquery&quot;,   // eslint-plugin-jquery
        &quot;@foo/foo&quot;, // @foo/eslint-plugin-foo
        &quot;@bar&quot;      // @bar/eslint-plugin
    ],
    &quot;extends&quot;: [
        // 扩展插件中的配置，需要加上plugin:
        &quot;plugin:@foo/foo/recommended&quot;,
        &quot;plugin:@bar/recommended&quot;
    ],
    &quot;rules&quot;: {
        // 修改插件中的规则
        &quot;jquery/a-rule&quot;: &quot;error&quot;,
        &quot;@foo/foo/some-rule&quot;: &quot;error&quot;,
        &quot;@bar/another-rule&quot;: &quot;error&quot;
    },
    &quot;env&quot;: {
        // 修改插件中的环境
        &quot;jquery/jquery&quot;: true,
        &quot;@foo/foo/env-foo&quot;: true,
        &quot;@bar/env-bar&quot;: true,
    }
    // ...
}
</code></pre>
<p>一些常用的插件：</p>
<table>
<thead>
<tr>
<th>插件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.npmjs.com/package/eslint-plugin-react"><code>eslint-plugin-react</code></a></td>
<td>对react提供支持</td>
</tr>
<tr>
<td><a href="https://eslint.vuejs.org/"><code>eslint-plugin-vue</code></a></td>
<td>对vue提供支持，支持<code>.vue</code>文件</td>
</tr>
<tr>
<td><a href="https://www.npmjs.com/package/eslint-plugin-prettier"><code>eslint-plugin-prettier</code></a></td>
<td>prettier支持按ESLint规则格式化</td>
</tr>
<tr>
<td><a href="https://www.npmjs.com/package/@typescript-eslint/eslint-plugin"><code>@typescript-eslint/eslint-plugin</code></a></td>
<td>提供对TypeScript的支持</td>
</tr>
</tbody>
</table>
<p><em>提示：如果想自己开发插件，可以基于ESLint官方提供的模板<code>generator-eslint</code>开发。</em></p>
<h3><a id="%E8%A7%84%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>规则</h3>
<p>ESLint提供了大量的<a href="https://eslint.org/docs/rules/">规则</a> ，我们可以针对这些规则进行精细的的控制。</p>
<p>配置的格式如下：</p>
<pre class="line-numbers"><code class="language-js">// .eslintrc.js
module.exports = {
    &quot;rules&quot;: {
        &quot;eqeqeq&quot;: &quot;off&quot;,
        &quot;curly&quot;: &quot;error&quot;,
        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]
    }
}
</code></pre>
<p>上面的配置值也可以采用数值的形式，对应关系如下：</p>
<table>
<thead>
<tr>
<th>配置值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>off</code>或<code>0</code></td>
<td>关闭对该规则的检测</td>
</tr>
<tr>
<td><code>warn</code>或<code>1</code></td>
<td>启用对改规则的检测，不满足时抛出<strong>警告</strong></td>
</tr>
<tr>
<td><code>error</code>或<code>2</code></td>
<td>启用对改规则的检测，不满足时抛出<strong>错误</strong></td>
</tr>
</tbody>
</table>
<p>配置的规则如果有配置项，可以把值写成数组格式，第一个元素为配置的值，第二个元素为配置项。</p>
<h3><a id="%E6%89%A9%E5%B1%95%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展配置</h3>
<p>ESLint提供了如此多的规则，我们不可能每次都从头一个一个去配置吧！所以ESLint提供了<code>extends</code>配置项，我们可以基于一些成熟的配置来做扩展，也可以覆写其规则：</p>
<pre class="line-numbers"><code class="language-js">// .eslintrc.js
module.exports = {
    &quot;plugins&quot;: [
        &quot;react&quot;
    ],
    &quot;extends&quot;: [
        &quot;eslint:recommended&quot;,
        &quot;plugin:react/recommended&quot; // 扩展插件中的配置
    ],
    &quot;rules&quot;: {
       &quot;react/no-set-state&quot;: &quot;off&quot;  // 覆写规则
    }
}
</code></pre>
<p>目前社区提供了很多<a href="https://www.npmjs.com/search?q=eslintconfig">配置集</a>供我们扩展，这里列举一些常用的：</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>eslint:recommended</code></td>
<td>ESLint内置，开启了一些推荐的核心校验规则</td>
</tr>
<tr>
<td><code>eslint:all</code></td>
<td>ESLint内置，开启了所有的核心校验规则</td>
</tr>
<tr>
<td><a href="https://www.npmjs.com/package/eslint-config-airbnb"><code>eslint-config-airbnb</code></a></td>
<td>按照airbnb风格规则进行校验</td>
</tr>
<tr>
<td><a href="https://www.npmjs.com/package/eslint-config-standard"><code>eslint-config-standard</code></a></td>
<td>按照standard风格规则进行校验</td>
</tr>
<tr>
<td><a href="https://www.npmjs.com/package/eslint-config-prettier"><code>eslint-config-prettier</code></a></td>
<td>关闭prettier有冲突的规则</td>
</tr>
</tbody>
</table>
<p>除了使用社区提供的配置，团队也可以自己定制一套配置，然后发布到npm，以便团队<a href="https://eslint.org/docs/developer-guide/shareable-configs">共享配置</a>。发布的包须以<code>eslint-config-</code>开头来进行命名，如<code>eslint-config-myconfig</code>，并建议将关键字设为<code>eslintconfig</code>，以便其他人能够找到。包的内容和<code>.eslintrc.js</code>类似：</p>
<pre class="line-numbers"><code class="language-js">// eslint-config-myconfig/index.js
module.exports = {

    globals: {
        MyGlobal: true
    },

    rules: {
        semi: [2, &quot;always&quot;]
    }

};
</code></pre>
<h2><a id="%E7%A6%81%E7%94%A8%E5%92%8C%E5%BF%BD%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>禁用和忽略</h2>
<p>ESLint虽好，但是总有些情况我们还是想静静，不愿被这太多的“俗世凡尘”规则所羁绊。尤其是拿到一份上古时代的代码，开启ESLint校验后，可能会让你怀疑你的出现可能是个错误:broken_heart::broken_heart::broken_heart:，这时禁用或忽略一些规则和文件就是个不错的主意了。</p>
<p>禁用规则有如下几种方式：</p>
<pre class="line-numbers"><code class="language-js">// 1. 放在文件最前面，对该文件检测时禁止所有规则
/* eslint-disable */
alert('foo');

// 2. 对该文件检测时禁止指定的规则
/* eslint-disable no-alert, no-console */
alert('foo');
console.log('bar');

// 3. 对该行检测时禁止所有规则
alert('foo'); // eslint-disable-line
alert('foo'); /* eslint-disable-line */

// 4. 对下一行行检测时禁止所有规则
// eslint-disable-next-line
alert('foo');
/* eslint-disable-next-line */
alert('foo');

// 5. 对该行检测时禁止指定规则
alert('foo'); // eslint-disable-line no-alert, quotes, semi
alert('foo'); /* eslint-disable-line no-alert, quotes, semi */

// 6. 对下一行行检测时禁止指定规则
// eslint-disable-next-line no-alert, quotes, semi
alert('foo');
/* eslint-disable-next-line no-alert, quotes, semi */
alert('foo');
</code></pre>
<p>除了上述在文件中配置的方式外，也可以通过配置来对一组文件禁用校验规则：</p>
<pre class="line-numbers"><code class="language-js">// .eslintrc.js
module.exports = {
  &quot;rules&quot;: {...},
  &quot;overrides&quot;: [
    {
      &quot;files&quot;: [&quot;*-test.js&quot;,&quot;*.spec.js&quot;],
      &quot;rules&quot;: {
        &quot;no-unused-expressions&quot;: &quot;off&quot;
      }
    }
  ]
}
</code></pre>
<p>ESLint还提供了一个文件<code>.eslintignore</code>用来忽略对文件的校验，其中配置的目录均会被ESLint忽略。</p>
<pre class="line-numbers"><code class="language-js">/build/
/config/
/dist/
/*.js
</code></pre>
<h1><a id="%E4%B8%80%E4%BA%9B%E6%A1%88%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一些案例</h1>
<p>上面我们介绍了ESLint的使用方法，下面我们就来看一下一些常用的使用案例：</p>
<h2><a id="eslint-typescript" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ESLint +TypeScript</h2>
<p>要对TypeScript进行支持，需要配置对应的解析器<a href="https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/parser"><code>@typescript-eslint/parser </code></a>来支持TS特殊的语法，另外还需要安装<a href="https://www.npmjs.com/package/@typescript-eslint/eslint-plugin"><code>@typescript-eslint/eslint-plugin</code></a>来提供校验规则。</p>
<ol>
<li>安装依赖包</li>
</ol>
<pre class="line-numbers"><code class="language-shell">npm install @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint typescript --save-dev
</code></pre>
<ol start="2">
<li>配置解析器，更多的解析器配置查看[该文档 <a href="../../../../../Desktop/nginx.conf">nginx.conf</a> ](<a href="https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/parser">https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/parser</a>)</li>
</ol>
<pre class="line-numbers"><code class="language-js">// .eslintrc.js
module.exports = {
  &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;, // 配置解析器
  &quot;parserOptions&quot;: {
      &quot;ecmaFeatures&quot;: {
        &quot;jsx&quot;: true  // 如果用到jsx需要开启
      },
      &quot;project&quot;: &quot;./tsconfig.json&quot;,  // ts配置文件
      // ...更多配置
  }
}
</code></pre>
<ol start="3">
<li>配置插件及规则配置</li>
</ol>
<pre class="line-numbers"><code class="language-js">// .eslintrc.js
module.exports = {
  &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,
  &quot;plugins&quot;: [&quot;@typescript-eslint&quot;], // 配置插件
  &quot;extends&quot;: [&quot;plugin:@typescript-eslint/recommended&quot;] // 扩展继承typescript-eslint推荐的规则
  &quot;rules&quot;: {
      &quot;@typescript-eslint/indent&quot;: [&quot;error&quot;, 2], // 覆写插件校验规则配置
  }
  // ...
}
</code></pre>
<p>更多typescript-eslint用法可以查看<a href="https://github.com/typescript-eslint/typescript-eslint">typescript-eslint文档</a>。</p>
<h2><a id="eslint-prettier" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ESLint + Prettier</h2>
<h3><a id="prettier" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Prettier</h3>
<p>在开始这部分内容前，有必要先简单了解一下<a href="https://prettier.io/">Prettier</a>。</p>
<p>Prettier是一款“有主见”的代码格式化工具，它支持多种语法，如JSX、Vue(vetur中使用了Prettier)、TypeScript、Less、Sass、JSON、GraphQL等，基本上前端能用到的文件格式它都可以搞定。而且它能够在多种场景下使用，是当下最流行的格式化工具。</p>
<p>下面我们来看下最常用的一种方式，即作为编辑器插件来使用：</p>
<ol>
<li>安装VSCode插件<a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode"><code>Prettier - Code formatter</code></a></li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">ext install esbenp.prettier-vscode
</code></pre>
<p><img src="https://gitee.com/letwrong/Picture/raw/master/20200925171823.png" alt="image-20200925171718606" /></p>
<ol start="2">
<li>安装Prettier</li>
</ol>
<pre class="line-numbers"><code class="language-shell">npm install -g prettier # 全局安装
npm install -D prettier # 推荐本地安装
</code></pre>
<ol start="3">
<li>在项目中添加配置，Prettier同样支持多种格式的<a href="https://prettier.io/docs/en/configuration.html">配置文件</a>，这里我们使用<code>prettier.config.js</code></li>
</ol>
<pre class="line-numbers"><code class="language-js">module.exports = {
  printWidth: 80, // 每行代码长度（默认80）
  tabWidth: 2, // 每个tab使用多少空格（默认2）
  useTabs: false, // 使用tab进行缩进（默认false）
  semi: true, // 结尾使用分号(默认true)
  singleQuote: false, // 使用单引号（默认false）
  trailingComma: 'none', // 使用尾逗号（默认none）
  bracketSpacing: true, // 对象大括号间使用空格（默认true）
  jsxBracketSameLine: false, // 多行JSX中的&gt;放置在最后一行的结尾，而不放在新行（默认false）
  arrowParens: &quot;avoid&quot; // 箭头函数的参数只有一个时是否带括号（默认avoid）
};
</code></pre>
<p><em>提示：关于更多配置项请查看<a href="https://prettier.io/docs/en/options.html">Prettier-Options</a>。</em></p>
<p>这样配置好以后，在VSCode执行格式化时，选择Prettier即可按照我们配置的格式进行格式化了。这样就避免了因为大家编辑器配置不一样而导致格式化后的代码风格不统一的问题。</p>
<p>那这货和ESLint有什么关系呢？他俩为什么会有一腿呢？</p>
<h3><a id="eslint%E5%92%8Cprettier%E7%9A%84%E5%86%B2%E7%AA%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ESLint和Prettier的冲突</h3>
<p>原来他们都会对代码的格式有操作，ESLint会检查并尽可能修复代码格式，Prettier按照配置格式化代码，而他们之间配置是不通用的，有些配置规则是有冲突的。所以就会出现用Prettier格式化后的代码，ESLint觉得是有问题的，而抛出错误提示。</p>
<p>而为了解决这个问题，就需要使用到<code>eslint-plugin-prettier</code>和<code>eslint-config-prettier</code>:</p>
<ul>
<li>
<p>`eslint-plugin-prettier：将Prettier的规则设置到ESLint的规则中。</p>
</li>
<li>
<p><code>eslint-config-prettier</code>：关闭ESLint中与prettier中会发生冲突的规则。</p>
</li>
</ul>
<pre class="line-numbers"><code class="language-shell">npm install -D eslint-plugin-prettier eslint-config-prettier
</code></pre>
<pre class="line-numbers"><code class="language-js">// .eslintrc.js
module.exports = {
    extends: [
        'plugin:prettier/recommended' // 也可以配置extends：[&quot;prettier&quot;],plugins: [&quot;prettier&quot;]
      	// 'prettier/@typescript-eslint' // 如果是TypeScript可以加上这个，解决@typescript-eslint和prettier的冲突
    ],
    rules: {
        &quot;prettier/prettier&quot;: [  // 覆写、自定义prettier规则
          &quot;error&quot;,
          {
            &quot;singleQuote&quot;: true,
            &quot;trailingComma&quot;: &quot;none&quot;,
            &quot;bracketSpacing&quot;: true,
            &quot;jsxBracketSameLine&quot;: true
          }
        ]
    }
}

</code></pre>
<p>现在，ESLint和Prettier就可以幸福的在一起了:tada::tada::tada::tada:。</p>
<h2><a id="%E5%B7%A5%E7%A8%8B%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工程化</h2>
<p>前面我们了解了ESLint和Prettier，这些工具可以很好的规范我们书写的代码，他们都只工作在我们开发的时候，而并不能保证大家提交到仓库的代码都是符合规范的。</p>
<p>比如，部门新来了一个小伙伴，觉得有这些条条框框的限制很麻烦，所以他禁用掉了这些工具，开发完成直接把代码提交到了仓库。所以我们需要做一些限制，不合规范的代码是禁止提交的，来提高库中代码的质量。</p>
<p>这里我们可以使用git hooks来做，借助 <a href="https://github.com/typicode/husky">husky</a> &amp; <a href="https://github.com/okonet/lint-staged">lint-staged</a> 来实现。</p>
<ul>
<li><a href="https://github.com/typicode/husky">husky</a>：可以很方便的在<code>package.json</code>里面定义git钩子</li>
<li><a href="https://github.com/okonet/lint-staged">lint-staged</a>：仅对git<strong>提交的代码</strong>（不是所有）使用一些Linter操作，</li>
</ul>
<pre class="line-numbers"><code class="language-shell"># 安装 husky  lint-staged
npm i -D lint-staged husky
</code></pre>
<pre class="line-numbers"><code class="language-json">// package.json
&quot;lint-staged&quot;: {
  &quot;**/**.{js,json,pcss,md,vue}&quot;: [
    &quot;prettier --write&quot;, // 先执行格式化
    &quot;eslint --fix&quot;,
    &quot;git add&quot;
  ]
},
&quot;husky&quot;: {
  &quot;hooks&quot;: {
    &quot;pre-commit&quot;: &quot;lint-staged&quot;
  }
},
</code></pre>
<p>这样设置以后，在每次提交的时候就会进行代码检查，只有通过检查后才能进行提交。</p>
<p><em>提示：由于这些操作都是在本地，所以还是能通过一定手段跳过检查，有CI/CD的话可以在远端来做，防止跳过检查。</em></p>
<p>参考资料：<a href="https://juejin.im/post/6844903778227847181">eslint+husky+prettier+lint-staged提升前端应用质量</a>、<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODU4MzQ1MA==&amp;mid=2247485956&amp;idx=1&amp;sn=975ff087c4789a551576167fd3549977&amp;chksm=eb558bf1dc2202e7aeb9b5e1a079c2e51439dc924dd05ad76c1ff3e9b2a70aada720178623e3&amp;mpshare=1&amp;scene=1&amp;srcid=0914TwrZwso96G1iRDzmtOY9&amp;sharer_sharetime=1600094024894&amp;sharer_shareid=cc9e69c259001141830ac92e7623bf34&amp;key=1f34014b3f438b54726cdd3c6f13745e618efd2bcbee3ddd9a50cb3aa91bb44a79d0a06c8ea381e597757858bb930f0df32bc7ae5195fde3b46fb604df78395b54c5fc9dd7f5a2bdc1f98afe38bde1a523be766b7561bdb858be28f0e75e64d562d3f63c624e731b6fa1eb5743a799ffe43578f514d07132e4db53d932d9fad7&amp;ascene=1&amp;uin=MTg4NTc2OTc1&amp;devicetype=Windows+10+x64&amp;version=62090538&amp;lang=zh_CN&amp;exportkey=ATaQN2OK0EZnIcJlhsK5M1g%3D&amp;pass_ticket=ptqgjL68BaGfDGVbXHJOC%2BErE%2BsfTo8ofV70c5%2BU80s%3D&amp;wx_header=0">如何制定企业级代码规范与静态检查</a></p>
<h1><a id="%E7%BB%93%E8%AF%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结语</h1>
<p>到这里，ESLint就介绍完了，如果想更加深入了解ESLint可以查看<a href="https://zhuanlan.zhihu.com/p/53680918">ESLint 工作原理探讨</a>。</p>
<p>无论在写代码还是做其他事情，其实都应该用长远的眼光来看，刚刚使用的时候可能会有很多问题，改起来也很费时费力，但是只要坚持下去，代码质量和开发效率都会得到提升，前期的付出都是值得的。</p>
<p>这些工具并不是必须的，没有他们你同样可以可以完成功能开发，但是利用好这些工具，可以写出更高质量的代码。特别是一些刚刚接触的人，可能会觉得麻烦而放弃使用这些工具，失去了一次提升代码的好机会。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】你不一定要逆风翻盘，但请一定向阳而生]]></title>
    <link href="https://www.bwrong.cn/17280330226446.html"/>
    <updated>2024-10-04T17:10:22+08:00</updated>
    <id>https://www.bwrong.cn/17280330226446.html</id>
    <content type="html"><![CDATA[
<p><a href="https://baijiahao.baidu.com/s?id=1672659795893888990&amp;wfr=spider&amp;for=pc">阅读原文</a><br />
黎明之前，总有一段时间特别黑，你要悄悄努力惊艳所有人。你不一定要逆风翻盘，但请一定向阳而生；你知道吗？梦想，就是梦里想做的事，醒来后，努力去实现；所谓的万丈深渊，走下去，也是前程万里。</p>
<p>嘿，朋友。也许这个世界并不美好，但你足够好。你不一定暴富，但请一定向我学习。前途未必光明坦荡，但一定充满无限可能。愿你不负青春，不负自己，做一个潇洒的人。过好自己的生活，该来的都在路上。看似不起波澜的日复一日，会突然在某一天，看到坚持的意义。余生很贵，请努力活成自己想要的样子，加油。</p>
<p>唯有心怀光亮望向远方，才能看见幸福真正的模样。真正地拥抱自己，更好的生活，正在前方等着你。这一天也许会弯道超车，让你刮目相看，让你在背后仰望我的身影，让你为你曾经所做过的事情后悔。但请你记住，你永远是独一无二的那个你，好好努力，相信自己，就算不能逆风翻盘，也请一定向阳而生。</p>
<p>写尽千山，落笔是你；望尽星辰，美丽是你；书尽泛黄，扉页是你；千山万水，归处是你。那一刻我心里有场海啸，可我静静地站着，没有任何人知道。无论你在什么样的逆境里，无论你在什么样的困难里，都能够看到那微弱、那切实存在的希望之光。至暗时刻，向阳而生。</p>
<p>黄帝内经说，心为五脏六腑之大主，主明则下安，主不明则十二官危，所以护肝要先养心，保持良好乐观的心态，利用休息日并选择利于出行的天气，邀约三五个亲朋好友一起去郊外旅游踏青，置身于大自然的环保之中，使心情开朗、神清气爽，万事自然顺遂。你知道吗，人生之所以美好，是因为它不总是晴空万里，也不总是困难重重，路上总会有阴影，但抬头总会有阳光。世界的温柔是晚来的善意和心有阳光努力的你。</p>
<p>近水楼台先得月，向阳花木易为春。机会全靠运气，运气全靠向阳而生的勇气，努力过后机会自然相聚。在不知所措的年纪，仿佛什么都不尽如人意，例如明明早起打了车，却因为堵车还是迟到了，公交晚点选择自行车，抬头一看，公交在前面。宫崎骏说，因为你我想变成更优秀的人，而我的每一次出发，是因为我想遇见，更好的我自己，好好爱自己，从热爱生活开始，哪怕是廉价的合租房，也要装扮成一个精致的小窝。努力健身也不是为了别人，是为了取悦自己，我深知自己的普通，但我的野心很大，所以没资格停下，这个世界也很公平，你不努力，凭什么都想要。无惧命运，奋勇向前。生而无畏，爱而自由。生命在于拼搏，保持乐观。只要精神不倒，谁也奈何不了。我是向阳而生，风吹不跑，雷劈不倒。</p>
<p>那种贫穷与残酷，那种孩子的纯真与潜能，那种爱的救赎，无论生活给我们多大压力，我们也要用弱小的肩膀扛着生活前行。铭记过去，感恩当下。这俗世总叫人阵痛，但我们总会在某一时刻找到人生信仰。美好终会到来，所以你只管善良。人这一生无非是一场和自己和解的旅程，学会放下恩怨和伤害，才能卸下身上沉重的包袱，重新出发，向阳而生。</p>
<p>散落的月光，穿过了云，躲着人群，铺成大海的鳞。愿所有心有羁绊的人，都能拨开这纷扰离乱的世间，一次又一次重逢。愿所有年轻人，以梦为马，不负韶华，心如花木，向阳而生</p>
<p>这个世界是平衡的，每个人都想通过自己的努力，去获得自己想要生活的样子，如果你真的改变不了命运，那就尽可能的改变，其中的体验吧，你不一定逆风翻盘，但你一定要向阳而生。</p>

]]></content>
  </entry>
  
</feed>
