
<!DOCTYPE html>
<html lang="zh-CN">
<head>
 <meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
<meta HTTP-EQUIV="pragma" CONTENT="no-cache">
<meta HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate">
<meta HTTP-EQUIV="expires" CONTENT="0">
<meta name="author" content="bwrong, wang11535041@qq.com"/>
<meta name="keywords" content="【前端工程化】篇四 席卷八荒-Webpack（进阶） | BWrong的小站,前端,krpano,js,vue"/>
<meta name="description" content="天青色等烟雨，而我在等你"/>
<!-- <title>【前端工程化】篇四 席卷八荒-Webpack（进阶） | BWrong的小站</title> -->
<title>网站搭建测试</title>
<link href="https://www.bwrong.cn/media/css/fz.css" rel="stylesheet">
<link rel="stylesheet" href="https://www.bwrong.cn/styles/main.css">
<script type="text/javascript">
function getCSS()
{
        datetoday = new Date();
        timenow=datetoday.getTime();
        datetoday.setTime(timenow);
        thehour = datetoday.getHours();

        if (thehour<5)

            display = "https://www.bwrong.cn/media/css/night.css";

       else if (thehour>20)

            display = "https://www.bwrong.cn/media/css/night.css";

        else if (thehour>5)
     
            display = "https://www.bwrong.cn/media/css/day.css";

        else if (thehour<20)

            display = "https://www.bwrong.cn/media/css/day.css";


var css = '<';
        css+='link rel="stylesheet" href='+display+' \/';
        css+='>';
        document.write(css);
}
</script>
<link href="https://at.alicdn.com/t/font_1306644_ko4c4at97is.css" rel="stylesheet" />
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://www.bwrong.cn/media/css/katex.min.css">
<script type='text/javascript' src='https://www.bwrong.cn/media/scripts/script.js'></script>
<link href="https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet" />
  <script src="https://cdn.bootcss.com/wow/1.1.2/wow.min.js"></script>
  <script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>wow=new WOW({boxClass:'wow',animateClass:'animated',offset:0,mobile:true,live:true});wow.init();</script>

<script type="text/javascript">
window.onload=getCSS();
</script>
<!-- 百度统计 -->
<script>
var _hmt = _hmt || [];
(function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?2c0e9e3f54ae20480b34c178578c4df8";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
})();
</script>


</head>
<body class="post-template-default single single-post postid-70 single-format-standard">
    <div id="wrapper">

	
<header id="header" class="site-header"
		
		style="background-image: linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2)),url(https://gitee.com/letwrong/Picture/raw/master/20201028124953.jpeg)"
		
		>
			<div class="site-branding">
									<h1 class="site-title"><a href="https://www.bwrong.cn" rel="home">BWrong的小站</a></h1>

					<h2 class="site-description">天青色等烟雨，而我在等你</h2>

							</div>
			<nav id="nav-wrapper">
				<div class="container">
					<div class="nav-toggle">
						<div class="bars">
							<div class="bar"></div>
							<div class="bar"></div>
							<div class="bar"></div>
						</div>
					</div>
					<div class="clear"></div>
					<ul id="" class="dove">
		 

<li>

	
		<a href="/">
		  首页
		</a>
	  

    

<li>

	
		<a href="/archives/index.html">
		  归档
		</a>
	  

    

<li>

	
		<a href="/post/about/">
		  关于
		</a>
	  

    

</ul>
</li>

</ul>				</div>
			</nav>
						<div class="jingge">


    

    

<a  href="https://github.com/BWrong" target="_blank" ><i class="iconfont icon-github"></i></a>
 
    

    

    

    

<a  href="https://juejin.cn/user/3421335914820280" target="_blank" ><i class="iconfont icon-telegram"></i></a>
 
    

    

    

    

    

    
        </header>


		<div id="content" class="container">
			<div class="row">
	<div class="col-md-8 site-main">

<article id="post-70" class="post-70 post type-post status-publish format-standard hentry category-5 tag-10 tag-9 tag-11">



		<div class="entry-content">
			<h1 data-wow-delay="0.4s"  class="wow fadeInUp entry-title">【前端工程化】篇四 席卷八荒-Webpack（进阶）</h1>
<div class="entry-meta">
<div class="wow fadeInUp"  data-wow-delay="0.6s">
	<i class="iconfont icon-rili"> <time class="lately-a" datetime="2020-10-28 12:50:23" itemprop="datePublished" pubdate="">2020-10-28</time></i>
	          </div>

</span>

		</div>

			<div class="wow fadeInUp entry-summary song"  data-wow-delay="0.1s">
				<p>字数：12197， 阅读时间：35分钟，点击<a href="https://www.bwrong.cn/post/dev-tools04/">阅读原文</a></p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/letwrong/Picture/raw/master/20201028124953.jpeg" alt="" loading="lazy"></figure>
<blockquote>
<p>石可破也，而不可夺坚；丹可磨也，而不可夺赤         ——《吕氏春秋·诚廉》</p>
</blockquote>
<p>【前端工程化】系列文章链接：</p>
<ul>
<li><a href="https://www.bwrong.cn/post/dev-tools01/">01 扬帆起航-开发环境</a></li>
<li><a href="https://www.bwrong.cn/post/dev-tools02/">02 白璧微瑕-包管理器</a></li>
<li><a href="https://www.bwrong.cn/post/dev-tools03/">03 席卷八荒-Webpack基础篇</a></li>
</ul>
<p><em>示例代码仓库：<a href="https://github.com/BWrong/dev-tools">https://github.com/BWrong/dev-tools</a></em></p>
<p><em>声明：本篇文章基于webpack v4.43.0，如按照文中代码执行报错，请检查依赖模块版本是否和示例代码仓库中一致。</em></p>
<p>*温馨提示：*本篇内容更偏实战，涉及大量代码，如有代码密集恐惧症的老爷，请速速离场。</p>
<p>在上一篇的内容中，介绍了webpack的核心概念以及常用的核心配置，并尝试着配置了一个项目脚手架。那么接下来，就进入飞升环节——性能优化和实现原理。</p>
<h1 id="锦上添花-优化">锦上添花-优化</h1>
<h2 id="使用分析工具">使用分析工具</h2>
<p>优化如果没有数据量化做支撑，而仅仅凭感觉，都是扯淡的，所以在做优化前，有必要先来了解一些构建结果分析工具，用来获取相关的量化指标，为优化工作提供了方向和依据。</p>
<h4 id="stats分析工具">stats分析工具</h4>
<p><a href="http://webpack.github.io/analyse/">stats分析工具</a>是webpack官方提供的在线工具，使用方法如下：</p>
<ol>
<li>生成<code>stat.json</code>文件。</li>
</ol>
<pre><code class="language-shell">webpack --profile --json &gt; stats.json
</code></pre>
<ol start="2">
<li>将<code>stat.json</code>文件上传到<a href="http://webpack.github.io/analyse/">stats分析工具</a>页面中，即可得到分析结果。</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/letwrong/Picture/raw/master/20200601152126.png" alt="" loading="lazy"></figure>
<h4 id="使用webpack-bundle-analyzer">使用<code>webpack-bundle-analyzer</code></h4>
<p>除了官网提供的分析工具，社区还提供了一个更加好用的分析神器<a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a> ，不仅界面美观，而且各个依赖包及其体积大小也更加直观。</p>
<pre><code class="language-shell">npm install webpack-bundle-analyzer -D
</code></pre>
<pre><code class="language-js">// build/webpack.prod.conf.js
const merge = require('webpack-merge');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const baseConfig = require('./webpack.base.conf.js');

 module.exports = merge(baseConfig, {
   	mode: 'production',
    plugins: [
        new BundleAnalyzerPlugin(),
   		// ...
    ],
   // ...
 });
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/letwrong/Picture/raw/master/20200601152927.png" alt="" loading="lazy"></figure>
<p>图里面我们可以查看Gzip和原始的打包结果，也可以看到每个chunk包含哪些包，以及它们的体积大小等信息。</p>
<h4 id="速度分析">速度分析</h4>
<p>上面的两个工具均是侧重于打包结果的分析，重在优化打包品质。而通过 <a href="https://github.com/stephencookdev/speed-measure-webpack-plugin">speed-measure-webpack-plugin</a> 这个插件还可以实现对构建过程分析，从而优化构建效率，提升打包的体验。</p>
<pre><code class="language-shell">npm i -D speed-measure-webpack-plugin
</code></pre>
<pre><code class="language-js">// build/webpack.prod.conf.js
const SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;);
const smp = new SpeedMeasurePlugin();
const webpackConfig = {
    // ...
}
module.exports = smp.wrap(webpackConfig) // 需要包裹原来的配置
</code></pre>
<p>现在就可以看到每个loader和plugin耗费的时间，以便对其进行优化。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/letwrong/Picture/raw/master/20201009111235.png" alt="image-20201009111235625" loading="lazy"></figure>
<h2 id="优化包品质">优化包品质</h2>
<p>webpack4.0在mode设置为production时，其实已经默认做了很多优化手段来提升输出成果品质，不过了解一下还是有助于我们做一些更加深层次的优化。毕竟这些内容是直接关系到用户体验的，非常重要。</p>
<h3 id="tree-shaking">Tree shaking</h3>
<p>Tree shaking 这个术语起源于 <a href="https://github.com/rollup/rollup">rollup</a>，在webpack2.0正式版开始内置，可以检测到未使用的模块，以便将其剔除。它依赖于 ESModule 模块系统（其他模块系统不支持）中的<a href="http://exploringjs.com/es6/ch_modules.html#static-module-structure">静态结构特性</a>，可以移除 JavaScript 上下文中的未引用代码，删掉未使用的代码，能够有效减少 JS 代码文件的大小。</p>
<blockquote>
<p>Tree shaking这个名字非常形象，摇树-摇掉树上多余的东西。</p>
</blockquote>
<pre><code class="language-js">// src/math.js
export function square(x) {
  return x * x;
}

export function cube(x) {
  return x * x * x;
}

// src/index.js
import { cube } from './math.js' // 仅引用了 cube 这个方法

console.log(cube(3))
</code></pre>
<p>上面的代码其实只是使用了cube，一般我们会希望未使用的代码（dead code）最好能够不包含到成果中。在新版的webpack中，在production的mode下，它会自动帮我们移除没有用到的代码，减少输出成果的体积。</p>
<p>在development的mode下，我们可以添加如下配置：</p>
<pre><code class="language-js">// build/webpack.dev.conf.js
module.exports = {
  mode: 'development',
  optimization: {
    usedExports: true, // 不导出模块中未使用的代码
  },
}
</code></pre>
<p>在进行此配置后，webpack会标识未使用的代码，然后在<a href="https://github.com/webpack-contrib/terser-webpack-plugin">TerserPlugin</a>执行压缩的时候移除那部分代码（没有额外的副作用）。</p>
<p>如果开发者需要自己来指定哪些模块没有副作用，可以使用另外一种方式（side effect），它可以配置在<code>package.json</code>的&quot;sideEffects&quot; 属性（主要针对一些库），也可以在 <a href="https://webpack.docschina.org/configuration/module/#module-rules"><code>module.rules</code> 配置选项</a> 中设置 <code>&quot;sideEffects&quot;</code>。大概有如下几种情形：</p>
<ul>
<li>如果所有代码都不包含有side effect的代码，直接将该属性标记为false，来告知 webpack，它可以安全地删除未用到的 export。</li>
</ul>
<pre><code class="language-json">//package.json
{
  &quot;name&quot;: &quot;your-project&quot;,
  &quot;sideEffects&quot;: false
}
</code></pre>
<ul>
<li>如果代码中有部分文件有副作用，需标记</li>
</ul>
<pre><code class="language-json">//package.json
{
  &quot;name&quot;: &quot;your-project&quot;,
  &quot;sideEffects&quot;: [
    &quot;./src/some-side-effectful-file.js&quot;,
    &quot;*.css&quot; // 一般css都是具有副作用的，需要在此声明
  ]
}
</code></pre>
<blockquote>
<p><em>&quot;side effect(副作用)&quot; 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。举例说明，例如 polyfill，它影响全局作用域，并且通常不提供 export。</em></p>
<p>针对css也提供了相应的工具 <a href="https://purgecss.com/plugins/webpack.html#usage">PurgeCSS</a>来去除未使用的代码，和tree shaking有异曲同工之妙。</p>
</blockquote>
<h3 id="代码分割">代码分割</h3>
<p>在单页应用（single-page application 简称为 SPA）当道的时代，我们不可能将所有的代码都打包在一个js文件中，也不可能在应用启动时一次性加载所有的js文件，否则长时间的白屏会让用户抓狂，大大影响用户体验。这时可以将代码进行分割，使其可以并行加载，也可以在不同的阶段（如不同路由）去加载所需的代码，这即是代码分割和按需加载。</p>
<p>webpack内置了非常强大的代码自动分割功能，也是它最引人注目的特性之一，如果合理使用，可以极大的提升应用加载时间。</p>
<p>常用的代码分离：</p>
<ul>
<li>入口chunk分割：使用entry配置多个chunk，手动分离代码。</li>
<li>提取公用代码：<a href="https://webpack.docschina.org/plugins/split-chunks-plugin/"><code>SplitChunksPlugin</code></a> 去重和分离 chunk。</li>
<li>动态导入与按需加载：通过模块中的内联函数调用来分离代码，目前推荐使用<code>import()</code>语法。</li>
</ul>
<h4 id="入口chunk分割">入口chunk分割</h4>
<p>最简单的分离方式就是在入口手动将代码分成不同的chunk。</p>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
  entry: {
    app: '../src/index.js',
   	another: '../src/another-module.js'
  },
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, '../dist')
  }
};
</code></pre>
<p>构建结果：</p>
<pre><code class="language-bash">...
            Asset     Size   Chunks             Chunk Names
another.bundle.js  550 KiB  another  [emitted]  another
  index.bundle.js  550 KiB    index  [emitted]  index
Entrypoint index = index.bundle.js
Entrypoint another = another.bundle.js
...
</code></pre>
<p>这种方式虽然简单，但是存在一些问题：</p>
<ul>
<li>依赖开发者自己手动配置，不够智能。</li>
<li>如果每个入口chunk中均包含有某个模块，不会共享，而是会将该模块打包到各个 bundle 中。</li>
</ul>
<h4 id="模块去重">模块去重</h4>
<p>webpack内置了<a href="https://webpack.docschina.org/plugins/split-chunks-plugin/"><code>SplitChunksPlugin</code></a>，可以很方便的把重复模块的提取成公共依赖，减少文件体积。而且将一些第三方依赖（一般不需要频繁变动）提取成公共依赖，也便于客户端做缓存，每次更新代码的时候，用户不需要重新下载这些没发生变化的模块。</p>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
  // ...
  entry: {
    app: '../src/index.js',
   	another: '../src/another-module.js'
  },
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, '../dist')
  },
  optimization: {
     splitChunks: { // 添加此配置
       chunks: 'all'
     }
   }
};
</code></pre>
<p>现在重新打包，app和another中共用的模块将会抽离到vender中，避免了产生重复的模块。</p>
<pre><code class="language-bash">...
                          Asset      Size                 Chunks             Chunk Names
              another.bundle.js  5.95 KiB                another  [emitted]  another
                index.bundle.js  5.89 KiB                  index  [emitted]  index
vendors~another~index.bundle.js   547 KiB  vendors~another~index  [emitted]  vendors~another~index
Entrypoint index = vendors~another~index.bundle.js index.bundle.js
Entrypoint another = vendors~another~index.bundle.js another.bundle.js
...
</code></pre>
<p>chunk自动拆分是webpack4.0改进最大的功能， 如果同时满足以下条件，chunk 就会被拆分：</p>
<ul>
<li>新的 chunk 被复用，或者来自 node_modules 目录。</li>
<li>新的 chunk 大于 30Kb(min+gzip前）。</li>
<li>按需加载 chunk 的并发请求数量小于等于 5 个。</li>
<li>页面初始加载时的并发请求数量小于等于 3 个。</li>
</ul>
<p><code>splitChunks</code> 官方默认配置如下，可以根据需要进行修改：</p>
<pre><code class="language-js">{
  optimization: {

    splitChunks: {
      chunks: &quot;async&quot;, // 对哪些模块优化，取值有&quot;initial&quot;(初始化值) | &quot;all&quot;(所有，推荐) | &quot;async&quot; (动态导入，默认) | 函数
      minSize: 30000,              // 最小尺寸，小于此值才会分割
      minChunks: 1,                // 最小 chunk ，包被引用几次以上才会分割
      maxAsyncRequests: 5,         // 按需加载的最大并行请求数， 默认5
      maxInitialRequests: 3,       // 最大的初始化加载次数，默认3
      automaticNameDelimiter: '~', // 打包分隔符
      name: true,       // 拆分出来块的名字，默认由块名和 hash 值自动生成，此选项可接收 function
      cacheGroups: {   // 这里开始设置缓存的 chunks ，缓存组
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10,
        },
        default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true,
        }
      }
    }
  }
}
</code></pre>
<h4 id="动态导入与按需加载">动态导入与按需加载</h4>
<p>webpack提供了两种方式进行动态导入代码。</p>
<ul>
<li><a href="https://webpack.docschina.org/api/module-methods#require-ensure"><code>require.ensure</code></a>：早期遗留的方式。</li>
<li><a href="https://webpack.docschina.org/api/module-methods#import-"><code>import()</code> 语法</a>：ES规范中的动态导入模块方法（推荐）。</li>
</ul>
<p><code>import()</code>是<a href="https://github.com/tc39/proposal-dynamic-import">ECMAScript 提案</a>中的一个动态导入模块（异步方式）的方法，webpack在遇到此语法，会以引入的文件为入口单独生成一个chunk，并输出一个单独的bundle。代码执行时，并不会加载全部bundle，而是执行到某个import的文件时，才会去加载该bundle，这即是按需加载的流程。</p>
<p>按需加载也称为“懒加载”，是一种非常好的优化方式，可以大大提升应用的初始加载速度，也可以大大缩小用户加载文件的体积。</p>
<p>比如一个应用，有9个页面是管理员可以访问的，而普通用户只能访问其中的两个页面，如果不采用按需加载，那普通用户虽然只能访问两个页面，但是还是会加载所有页面依赖的文件，这是不合理的。</p>
<p>类似，下面这个页面不需要一开始就加载<code>module.js</code>，而只需在按钮被点击时才加载并执行其中的代码，可在浏览器开发者工具的network选项卡观察加载情况。</p>
<pre><code class="language-js">document.getElementById('my-button').onclick = function() {
    import('./module.js').then(fn =&gt; {
        fn.default &amp;&amp; fn.default();
    });
}
</code></pre>
<p><code>module.js</code>和它内部依赖的文件就会单独生成一个bundle，并且是按需加载的。如果我们想控制输出bundle的名字，也可以指定chunk的名字，需要使用到webpack的魔法注释。</p>
<pre><code class="language-js">document.getElementById('my-button').onclick = function() {
    import(/* webpackChunkName: &quot;moduleA&quot; */ './module.js').then(fn =&gt; { // 指定chunkName为moduleA
        fn.default &amp;&amp; fn.default();
    });
}
</code></pre>
<p><strong>提示：</strong><code>import()</code>会返回一个promise，所以也可以使用<code>async function</code>优化链式写法。</p>
<pre><code class="language-js">document.getElementById('my-button').onclick = async function() {
    const fn = await import(/* webpackChunkName: &quot;moduleA&quot; */ './module.js')
    fn.default &amp;&amp; fn.default();
}
</code></pre>
<p>**扩展：**除了webpackChunkName外，webpack还有另外两种魔法注释用来做模块的prefetch和preload，具体使用方法可以查看<a href="https://webpack.js.org/guides/code-splitting/#prefetchingpreloading-modules">官方文档</a>。</p>
<p>在实际项目中，代码分割也可以参考如下分离原则：</p>
<ul>
<li>业务代码和第三方依赖分离</li>
<li>业务代码、业务公共代码和第三方依赖分离</li>
<li>首次加载和访问后加载的代码分离</li>
</ul>
<h3 id="开启gzip">开启Gzip</h3>
<p>如果部署服务器开启了gzip，那么可利用<a href="https://github.com/webpack-contrib/compression-webpack-plugin"><code>compression-webpack-plugin</code></a>生成gzip包，来减少加载时间。</p>
<pre><code class="language-shell">npm i compression-webpack-plugin -D
</code></pre>
<pre><code class="language-js">// build/webpack.prod.conf.js
const CompressionWebpackPlugin = require('compression-webpack-plugin');
const productionGzipExtensions = ['js', 'css', 'json', 'txt', 'html','ico','svg'];
module.exports = {
	plugins:[
		new CompressionWebpackPlugin({
      // 开启gzip压缩
      algorithm: 'gzip', // 压缩算法
      test: new RegExp('\\.(' + productionGzipExtensions.join('|') + ')$'),
      threshold: 10240, // 仅处理大于此大小的资源（以字节为单位）
      minRatio: 0.8 // 压缩比大于此值才处理
    })
	]
}

</code></pre>
<h3 id="使用cdn">使用CDN</h3>
<p>将一些第三方依赖改用CDN引入，也是常用的优化手段，因为一般第三方模块不会像业务代码一般频繁更新，使用CDN后，客户端会缓存这些资源，提升应用加载速度。不仅如此，这些依赖也不会参与构建过程（不会被打包进输出文件中），也可以提升构建速度。</p>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
    externals: {
        'vue': 'Vue', // 配置需要排除的包名称
        // ...
    }
}
</code></pre>
<p>在js中还是使用<code>import Vue from 'vue'</code>即可，不过别忘了在html做引入。</p>
<pre><code class="language-html">&lt;!-- public/index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;app&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;root&lt;/div&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="提升构建效率">提升构建效率</h2>
<p>随着业务发展，我们的项目规模可能越来越大，代码也会越来越多，就会进入改代码十秒钟，build十分钟的尴尬境地，加班什么的都不在话下。所以为了有更多的时间和女神约会，提升webpack构建效率就势在必行了。</p>
<p>提升webpack的构建效率本质就是让它少干点活，应该尽量避免让它去做一些不必要的事情。围绕这个方向，我们就可以动手搞事情了。</p>
<h3 id="优化resolve解析规则">优化<code>resolve</code>解析规则</h3>
<p>可以通过优化resolve下的解析规则来让webpack更加快速的定位到指定的模块，而不用做更多的匹配查询工作。</p>
<pre><code class="language-js">// build/webpack.base.conf.js
resolve: {
  modules: [
    path.resolve(__dirname, 'node_modules'), // 使用绝对路径明确指定 node_modules
  ],
  // 减少后缀自动补全类型，减少自动匹配工作，缩短文件路径查询的时间，其他类型的文件需要在引入时指定后缀名
  extensions: [&quot;.js&quot;],
  // 避免使用默认文件，而是必须使用完整的路径
  mainFiles: ['index'],
},
</code></pre>
<h3 id="缩小搜索范围">缩小搜索范围</h3>
<p>如，在loader规则配置时，使用一些规则（include，exclude等）来缩小模块的搜索范围，搜索和处理的文件少了，速度自然也就提升了。</p>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        include: path.resolve(__dirname, 'src'), // 仅仅搜索src下的文件，一般node_modules中的文件都已编译好，不需再处理，需要排除掉
        loader: 'babel-loader'
      }
    ]
  }
};
</code></pre>
<h3 id="精简loaderplugin">精简<code>loader/plugin</code></h3>
<p>每个loader/plugin都是需要消耗构建时间的，尽量减少冗余或者不必要的工具和配置，在选择这些工具时也尽量选择一些性能好一点的。</p>
<h3 id="使用dllplugin">使用DLLPlugin</h3>
<p><a href="https://doc.webpack-china.org/plugins/dll-plugin">DLLPlugin</a> 是 webpack 官方提供的一个插件，使用 <code>DllPlugin</code> 为更改不频繁的代码(如vue、react等第三方模块)生成单独编译结果缓存下来，后续构建直接使用这些文件，避免重复构建。这样可以显著提高应用程序的编译速度。</p>
<p>需要先利用webpack内置插件<a href="https://doc.webpack-china.org/plugins/dll-plugin">DLLPlugin</a>生成资源动态链接库，然后再使用<a href="https://webpack.docschina.org/plugins/dll-plugin/#dllreferenceplugin">DLLReferencePlugin</a>将对应资源映射到这些动态链接库就可以了，不过这样配置还是比较复杂的。</p>
<p>我们可以选择 <a href="https://github.com/asfktz/autodll-webpack-plugin">AutoDllPlugin</a>，它整合了上述两个插件的功能，而配置比较简单。</p>
<pre><code class="language-bash">npm install --save-dev autodll-webpack-plugin
</code></pre>
<pre><code class="language-js">// build/webpack.base.conf.js
plugins: [
  //...
  new AutoDllPlugin({
    inject: true,
    filename: '[name].js',
    entry: {
      vendor: [
        'vue'
      ]
    }
  })
]
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/letwrong/Picture/raw/master/20201028091448.png" alt="优化前" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/letwrong/Picture/raw/master/20201028091501.png" alt="优化后" loading="lazy"></figure>
<p>可以看到两次打包时间差别还是挺大的，确实比较有效，目前示例项目模块较少，在大项目效果应该更加显著。</p>
<h3 id="小即是快">小即是快</h3>
<p>使用数量更少/体积更小的 library，如将momentJS换成dayJS，减少编译结果的整体大小，以提高构建性能。尽量保持 chunk 体积小。</p>
<ul>
<li>使用数量更少/体积更小的 library。</li>
<li>在多页面应用程序中使用 <code>SplitChunksPlugin</code>。</li>
<li>在多页面应用程序中使用 <code>SplitChunksPlugin </code>，并开启 <code>async</code> 模式。</li>
<li>移除未引用代码。</li>
<li>只编译你当前正在开发的那些代码。</li>
</ul>
<h3 id="持久化缓存">持久化缓存</h3>
<p>使用 <code>cache-loader</code>为某些耗费性能的loader启用持久化缓存，可以减少重新构建文件的数量，能有效提升构建速度。</p>
<pre><code class="language-shell">npm install cache-loader -D
</code></pre>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
    module: {
        rules: [{
            test: /\.jsx?$/,
            use: ['cache-loader','babel-loader'] // 仅需将cache-loader放在需要缓存的loader前面就行了
        }]
    }
}
</code></pre>
<p>**提示：**某些loader本身是支持配置cache的，可选择使用loader自带的缓存功能。如给<code>babel-loader</code>的cacheDirectory配置缓存路径（true或者不设置路径则使用默认路径<code>node_modules/.cache/babel-loader</code>），即可开启缓存。</p>
<blockquote>
<p>除了使用loader外，一些插件也可以提供缓存功能，如<a href="https://www.npmjs.com/package/hard-source-webpack-plugin">HardSourceWebpackPlugin</a> 。</p>
<p>因为缓存需要将文件写入到磁盘，而文件写入也是有开销的，所以好钢要用在刀刃上，建议仅对比较耗费性能的loader开启。</p>
<p>webpack5.0已经内置了<a href="https://webpack.docschina.org/configuration/other-options/#cache">持久缓存方案</a>，能够有效提升构建速度。</p>
</blockquote>
<h3 id="因地制宜">因地制宜</h3>
<p>针对不同环境选择合适的配置，如设置合适的devtool（source-map），开发环境不进行代码压缩优化等。</p>
<h3 id="开启多进程">开启多进程</h3>
<p><code>thread-loader</code> 可以管理多个进程，可将非常消耗资源的 loader 分配给一个 worker进程，从而减少主进程的性能开销。</p>
<pre><code class="language-shell">npm install thread-loader -D
</code></pre>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
    module: {
        rules: [
            {
                test: /\.jsx?$/,
                use: ['thread-loader', 'babel-loader'] // 仅需在对应的loader前面添加thread-loader即可
            }
        ]
    }
}
</code></pre>
<blockquote>
<p><em>不要使用太多的 worker，因为 Node.js 的 runtime 和 loader 都有启动开销。要最小化 worker 和 main process(主进程) 之间的数据传输，因为进程间通讯(IPC, inter process communication)也是非常消耗资源的。</em></p>
<p>除了<code>thread-loader</code>，HappyPack也可以开启多进程，不过配置更加复杂一点，因为不再维护，固不推荐使用。</p>
<p>现在webpack内置JS压缩使用了TerserWebpackPlugin，本身已开启多进程，固不再需要手动开启。</p>
</blockquote>
<p>除了以上手段，webpack和nodeJS每个版本迭代也会大幅提升性能，及时升级工具也是提升构建效率的有效手段。更多的性能优化手段可以查看<a href="https://webpack.docschina.org/guides/build-performance/">官方文档-构建性能</a>。</p>
<h1 id="修炼内功-原理">修炼内功-原理</h1>
<h2 id="工作原理">工作原理</h2>
<h3 id="运行流程">运行流程</h3>
<p>webpack运行流程是串行方式的，大致如下：</p>
<ol>
<li>初始化参数：从配置文件和 Shell 语句中读取与合并参数配置，得出最终的参数配置；</li>
<li>开始编译：用上一步得到的参数配置初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li>
<li>确定入口：根据配置中的 entry 找出所有的入口文件；</li>
<li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤。直到所有入口依赖的文件都经过了本步骤的处理；</li>
<li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li>
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li>
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li>
</ol>
<p><strong>提示：在以上的过程中，webpack会在特定的时机广播出对应的事件，方便触发插件中监听了这些事件的钩子运行。</strong></p>
<p>看似流程较多，我们可以精简一下：</p>
<ol>
<li>
<p>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。</p>
</li>
<li>
<p>编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。</p>
</li>
<li>
<p>输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/letwrong/Picture/raw/master/20200705214253.png" alt="" loading="lazy"></figure>
</li>
</ol>
<p>参考资料：<a href="%5Bhttp://www.xbhub.com/wiki/webpack/5%E5%8E%9F%E7%90%86/5-1%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%A6%82%E6%8B%AC.html%5D(http://www.xbhub.com/wiki/webpack/5%E5%8E%9F%E7%90%86/5-1%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%A6%82%E6%8B%AC.html)">webpack工作原理概括</a></p>
<h3 id="实现一个简单的webpack">实现一个简单的webpack</h3>
<p>俗话说：读万卷书不如行万里路，讲再多的原理都不如敲敲代码来得实在。下面我们就一步一步实现一个简单的打包器。</p>
<h4 id="准备工作">准备工作</h4>
<p>创建一个项目，包含如下文件及文件夹：</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/letwrong/Picture/raw/master/20200705215338.png" alt="image-20200705215338484" loading="lazy"></figure>
<pre><code class="language-js">// /src/index.js
import a from './a.js';

console.log(a);
</code></pre>
<pre><code class="language-js">// /src/a.js
import b from './b.js';
const a = `b content: ${b}`;
export default a;
</code></pre>
<pre><code class="language-js">// /src/b.js
const b = 'Im B';
export default b;
</code></pre>
<p>现在这样的代码在不支持ESModule的浏览器是不能运行的，需要使用打包器进行转换才行，马上开撸。</p>
<h4 id="实现模块打包">实现模块打包</h4>
<p>在开撸前，我们明确下打包的目标和流程：</p>
<ol>
<li>找到项目入口（即<code>/src/index.js</code>），并读取其内容；</li>
<li>分析入口文件内容，递归寻找其依赖，生成依赖关系图；</li>
<li>根据生成的依赖关系图，编译并生成最终输出代码</li>
</ol>
<p><code>/myBundle.js</code>即为我们的打包器，所有相关的代码也将写在其中，下面开始吧！</p>
<h5 id="1-获取模块内容">1. 获取模块内容</h5>
<p>读取入口文件的内容，这个很简单，我们创建一个方法<code>getModuleInfo</code>，使用<code>fs</code>来读取文件内容：</p>
<pre><code class="language-js">// myBundle.js
const fs = require('fs')
const getModuleInfo = file =&gt; {
    const content = fs.readFileSync(file, 'utf-8')
    console.log(content)
}
getModuleInfo('./src/index.js')
</code></pre>
<p>毫无疑问，这里会输出<code>index.js</code>文件的内容，不过它是一堆字符串，我们如何才能知道它依赖了哪些模块呢？有如下两种方式：</p>
<ul>
<li>正则：通过正则匹配'import'关键字来获取相应的文件路径，不过太麻烦了，还不可靠，万一代码里面有个字符串也有这些内容呢？</li>
<li>babel：可以通过<code>@babel/parser</code>来将代码转换成AST（抽象语法树，Abstract Syntax Tree, 简称AST），再来分析AST查找依赖。看起来这种比较靠谱。</li>
</ul>
<p>毫无疑问，使用第二种方式。</p>
<pre><code class="language-shell">npm i @babel/parser ## 安装 @babel/parser
</code></pre>
<pre><code class="language-js">// myBundle.js
const fs = require('fs')
const parser = require('@babel/parser')
const getModuleInfo = file =&gt; {
    const content = fs.readFileSync(file, 'utf-8')
    const ast = parser.parse(content, {
       sourceType: 'module' // 解析ESModule须配置
    })
    console.log(ast)
    console.log(ast.program.body)
}
getModuleInfo('./src/index.js')
</code></pre>
<p>转换结果如下，可以看到一共两个节点，<code>type</code>属性标识了节点的类型，<code>ImportDeclaration</code>即对应了<code>import</code>语句，而其<code>source.value</code>即是引入模块的相对路径。想要的数据都有，是不是很赞！</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/letwrong/Picture/raw/master/20200705223745.png" alt="image-20200705223745187" loading="lazy"></figure>
<h5 id="2-生成依赖关系表">2. 生成依赖关系表</h5>
<p>有了上一步的数据，我们需要将它们生成一份结构化的依赖表，方便后续对代码处理。</p>
<p>其实就是遍历<code>ast.program.body</code>，将其中的<code>ImportDeclaration</code>类型的节点提取出来，并存入依赖表。</p>
<p>这里也不需要自己手动实现细节，直接使用<code>@babel/traverse</code>即可。</p>
<pre><code class="language-shell">npm i  @babel/traverse ## 安装@babel/traverse
</code></pre>
<p><code>getModuleInfo</code>方法做如下修改：</p>
<pre><code class="language-js">// myBundle.js
const fs = require('fs')
const path = require('path')
const parser = require('@babel/parser')
const traverse = require('@babel/traverse').default
const getModuleInfo = (file) =&gt; {
	const content = fs.readFileSync(file, 'utf-8');
	const ast = parser.parse(content, {
		sourceType: 'module'
	});
  	const dependencies = {}; // 用于存储依赖
    traverse(ast, {
        ImportDeclaration({ node }) { // 只处理ImportDeclaration类型的节点
            const dirname = path.dirname(file);
            const newFile = '.'+ path.sep + path.join(dirname, node.source.value); // 此处将相对路径转化为绝对路径，
            dependencies[node.source.value] = newFile;
        }
  	});
  	console.log(dependencies);
};
getModuleInfo('./src/index.js')
</code></pre>
<p>输出结果如下：</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/letwrong/Picture/raw/master/20200705230404.png" alt="image-20200705230403954" loading="lazy"></figure>
<p>接下来我们就可以返回一个完整的模块信息了。</p>
<p>在这里，我们顺便通过<code>babel</code>的工具（``@babel/core<code>，</code>@babel/preset-env`）将代码转换成ES5的语法。</p>
<pre><code class="language-shell">npm i @babel/core @babel/preset-env ## 安装@babel/core @babel/preset-env
</code></pre>
<pre><code class="language-js">// myBundle.js
const fs = require('fs');
const path = require('path');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const babel = require('@babel/core');

const getModuleInfo = (file) =&gt; {
	const content = fs.readFileSync(file, 'utf-8');
	const ast = parser.parse(content, {
		sourceType: 'module'
  });
  const dependencies = {};
	traverse(ast, {
		ImportDeclaration({ node }) {
			const dirname = path.dirname(file);
			const newFile = '.'+ path.sep + path.join(dirname, node.source.value);
			dependencies[node.source.value] = newFile; // 使用文件相对路径为key，绝对路径为value
		}
  });
  const { code } = babel.transformFromAst(ast, null, {
		presets: ['@babel/preset-env']
  });
  const moduleInfo = { file, dependencies, code };
  console.log(moduleInfo);
	return moduleInfo;
};

getModuleInfo('./src/index.js');
</code></pre>
<p>输出如下：</p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/letwrong/Picture/raw/master/20200705231115.png" alt="image-20200705231114976" loading="lazy"></figure>
<p>现在，模块的代码就已经转换成了一个对象，包含模块的绝对路径、依赖以及被babel转换后的代码，不过上面只处理了<code>index.js</code>的依赖，<code>a.js</code>的依赖并没有进行处理，所以并不是一份完整的依赖表，我们需要进一步处理。</p>
<p>其实也很简单，就是从入口开始，每个模块及其依赖都调用一下<code>getModuleInfo</code>方法进行分析，最终就会返回一个完整的依赖表(也有人叫依赖图，dependency graph)。</p>
<p>我们直接新写一个方法来处理：</p>
<pre><code class="language-js">// myBundle.js
const generDepsGraph = (entry) =&gt; {
	const entryModule = getModuleInfo(entry);
	const graphArray = [ entryModule ];
	for(let i = 0; i &lt; graphArray.length; i++) {
		const item = graphArray[i];
		const { dependencies } = item;
		if(dependencies) {
			for(let j in dependencies) {
				graphArray.push(
					getModuleInfo(dependencies[j])
				);
			}
		}
	}
	const graph = {};
	graphArray.forEach(item =&gt; {
		graph[item.file] = {
			dependencies: item.dependencies,
			code: item.code
		};
	});
	return graph;
};
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/letwrong/Picture/raw/master/20200705232430.png" alt="image-20200705232430595" loading="lazy"></figure>
<p>现在，我们就生成一份完整的依赖表了，接下来，就可以根据这份数据来生成最终的代码了。</p>
<h5 id="3生成输出代码">3.生成输出代码</h5>
<p>在生成代码前，我们先观察一下上面的代码，可以发现里面包含了<code>export</code>和<code>require</code>这样的<code>commonjs</code>的语法，而我们的运行环境（这里是浏览器）是不支持这种语法的，所以还需要自己来实现一下这两个方法。先贴上代码，再慢慢道来：</p>
<p>新建一个build方法，用来生成输出的代码。</p>
<pre><code class="language-js">// myBundle.js
const build = (entry) =&gt; {
	const graph = JSON.stringify(generDepsGraph(entry));
	return `
		(function(graph){
			function require(module) {
				var exports = {};
				return exports;
			};
			require('${entry}')
		})(${graph});
	`;
};

const code = build('./src/index.js');
</code></pre>
<p>说明：</p>
<ul>
<li>第三行<code>JSON.stringify</code>是将数据字符串化，否则在下面的立即执行函数中接收到的将是<code>[object object]</code>，因为下面是在字符串模板中使用，会发生类型转换。</li>
<li>返回的代码包裹在IIFE（立即执行函数）中是防止模块间作用域相互污染。</li>
<li><code>require</code>函数需要定义在输出的内容中，而不是当前的运行环境中，因为它会在生成的代码中执行。</li>
</ul>
<p>接下来，我们需要拿到入口文件的code，并使用<code>eval</code>函数来执行它：</p>
<pre><code class="language-js">// myBundle.js
const build = (entry) =&gt; {
	const graph = JSON.stringify(generDepsGraph(entry));
	return `
		(function(graph){
			function require(module) {
				var exports = {};
				(function(require, exports, code){
					eval(code)
				})(require, exports, graph[module].code);
				return exports;
			};
			require('${entry}')
		})(${graph});
	`;
};

const code = build('./src/index.js');
console.log(code);
</code></pre>
<p>说明：</p>
<ul>
<li>为了防止code中的代码和我们这里（return的字符串中）作用域有冲突，我们还是使用IIFE包裹，并将需要的参数传递进去。</li>
<li><code>graph[module].code</code>可以从上面的依赖表中获取到入口的代码。</li>
</ul>
<p>输出如下：</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/letwrong/Picture/raw/master/20200706091126.png" alt="image-20200706091126005" loading="lazy"></figure>
<p>这就是打包的成果了，不过先不要高兴过头了，这里还有一个大坑。</p>
<p>我们现在生成的代码中引入模块的方式都是基于'index.js'的相对路径，如果在其他模块引入的模块路径和相较于<code>index.js</code>不一致的时候，对应的模块就会找不到(路径不正确)，所以我们还要处理一下模块的路径。好在前面依赖表的<code>dependencies</code>属性里面记录了模块的绝对路径，只需要拿出来使用即可。</p>
<p>添加一个<code>localRequire</code>函数，用来从<code>dependencies</code>中获取模块绝对路径。</p>
<pre><code class="language-js">// myBundle.js
const build = (entry) =&gt; {
	const graph = JSON.stringify(generDepsGraph(entry));
	return `
		(function(graph){
			function require(module) {
				function localRequire(relativePath) {
					return require(graph[module].dependencies[relativePath]);
				}
				var exports = {};
				(function(require, exports, code){
					eval(code)
				})(localRequire, exports, graph[module].code);
				return exports;
			};
			require('${entry}')
		})(${graph});
	`;
};
</code></pre>
<p>接下来，将输出的代码写入到文件就可以了。</p>
<pre><code class="language-js">// myBundle.js
const code = build('./src/index.js')
fs.mkdirSync('./dist')
fs.writeFileSync('./dist/bundle.js', code)
</code></pre>
<p>最后，在html中引入一下，测试一下是否能够正常运行。没有疑问，肯定是可以正常运行的。😄😄</p>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/letwrong/Picture/raw/master/20200706092931.png" alt="image-20200706092931226" loading="lazy"></figure>
<p>最后贴一下完整的代码：     🐮🍻</p>
<pre><code class="language-js">// myBundle.js
const fs = require('fs');
const path = require('path');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const babel = require('@babel/core');

const getModuleInfo = (file) =&gt; {
	const content = fs.readFileSync(file, 'utf-8');
	const ast = parser.parse(content, {
		sourceType: 'module'
  });
  const dependencies = {};
	traverse(ast, {
		ImportDeclaration({ node }) {
			const dirname = path.dirname(file);
			const newFile = '.'+ path.sep + path.join(dirname, node.source.value);
			dependencies[node.source.value] = newFile;
		}
  });
  const { code } = babel.transformFromAst(ast, null, {
		presets: ['@babel/preset-env']
  });
  const moduleInfo = { file, dependencies, code };
	return moduleInfo;
};

const generDepsGraph = (entry) =&gt; {
	const entryModule = getModuleInfo(entry);
	const graphArray = [ entryModule ];
	for(let i = 0; i &lt; graphArray.length; i++) {
		const item = graphArray[i];
		const { dependencies } = item;
		if(dependencies) {
			for(let j in dependencies) {
				graphArray.push(
					getModuleInfo(dependencies[j])
				);
			}
		}
	}
	const graph = {};
	graphArray.forEach(item =&gt; {
		graph[item.file] = {
			dependencies: item.dependencies,
			code: item.code
		};
	});
	return graph;
};
const build = (entry) =&gt; {
	const graph = JSON.stringify(generDepsGraph(entry));
	return `
		(function(graph){
			function require(module) {
				function localRequire(relativePath) {
					return require(graph[module].dependencies[relativePath]);
				}
				var exports = {};
				(function(require, exports, code){
					eval(code)
				})(localRequire, exports, graph[module].code);
				return exports;
			};
			require('${entry}')
		})(${graph});
	`;
};

const code = build('./src/index.js');
fs.mkdirSync('./dist');
fs.writeFileSync('./dist/bundle.js', code);
</code></pre>
<p>在完成这个案例之前，webpack就像一位高贵的美人，让人敬而远之。而通过这个案例，我们撕下了她神秘的外衣，发现里面原来如此美妙，是不是美不胜收。当然实际不能如此简单，要去处理各种边界情况，还要支持loader和plugin，美人还是有点东西的😍。</p>
<h2 id="聊聊模块热替换">聊聊模块热替换</h2>
<p>之所以在这里单独列出了模块热替换（HMR），是因为一直觉得这是一个很酷的功能，犹如黑魔法一般的存在。</p>
<h3 id="优势何在">优势何在</h3>
<p>模块热替换简称为 HMR(Hot Module Replacement)，能大大提升开发体验，是非常实用的一个功能。在这之前，用得比较多的是<code>live-reload</code>，在编辑器和浏览器安装对应的插件后，当编辑器保存的时候，浏览器会进行页面刷新，其实相比手动F5也算比较方便了。不过它只能采用整页刷新，所以存在一些缺陷：</p>
<ul>
<li>效率低，整页刷新意味着所有资源将重新加载，速度可想而知。</li>
<li>如果页面中的状态未采用持久化，刷新后状态将会重置丢失。</li>
</ul>
<p>在gulp流行的时候，用得比较多的是一个叫<a href="https://browsersync.io/"><code>BrowserSync</code></a>的插件，可以同时在多个设备打开多个浏览器，点击和滚动操作在所有浏览器上都会同步，也算是比较好用的一个工具。这里它不是主角，不做介绍。</p>
<p>webpack的HMR是在应用运行时，尽量在重载整个页面的前提下动态替换、添加或删除模块，相比以往的工具，它有以下优势：</p>
<ul>
<li>更新页面内容的时候不会丢失应用的状态（不是绝对的，取决于模块的影响范围）。</li>
<li>只更新有变更的内容，而不是整页重载，快速和高效。</li>
</ul>
<h3 id="运行原理">运行原理</h3>
<p>前面已经介绍了如何使用模块热替换，所以这里不会再赘述用法，仅仅简单了解一下相关概念即可。</p>
<h4 id="manifest"><code>Manifest</code></h4>
<p>首先需要了解一下<code>Manifest</code>，它是webpack维护的一份用于管理构建过程中所有模块及关联关系的数据表，包含了各个模块之间的依赖关系、模块内容等详细信息，是webpack解析和加载模块的重要依据。</p>
<h4 id="更新流程">更新流程</h4>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/letwrong/Picture/raw/master/20200705205925.jpg" alt="img" loading="lazy"></figure>
<p>上图是webpack 配合 webpack-dev-server 进行应用开发的模块热更新流程图，记录了完整的更新流程。</p>
<ul>
<li>上图底部红色框内是服务端，而上面的橙色框是浏览器端。</li>
<li>绿色的方框是 webpack 代码控制的区域。蓝色方框是 webpack-dev-server 代码控制的区域，洋红色的方框是文件系统，文件修改后的变化就发生在这，而青色的方框是应用本身。</li>
</ul>
<p>上图显示了修改代码到模块热更新完成的一个周期（步骤已使用序号标出），流程如下：</p>
<ol>
<li>webpack 对文件系统进行 watch 打包到内存中。在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中（<em>文件写在内存中，速度更快，性能更高，使用<a href="https://link.zhihu.com/?target=https%3A//github.com/webpack/memory-fs">memory-fs</a>工具完成</em>）。</li>
<li>webpack-dev-server 和 webpack 之间的接口交互。而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。</li>
<li>webpack-dev-server 对文件变化的一个监控。这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了<a href="https://link.zhihu.com/?target=https%3A//webpack.js.org/configuration/dev-server/%23devserver-watchcontentbase">devServer.watchContentBase</a> 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。</li>
<li>webpack-dev-server 代码的工作。该步骤主要是通过 <a href="https://link.zhihu.com/?target=https%3A//github.com/sockjs/sockjs-client">sockjs</a>（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。</li>
<li>webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。</li>
<li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</li>
<li>而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</li>
<li>最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</li>
</ol>
<p>如上就是热更新的过程，当然这只是webpack所做的工作，此时业务代码中并不能知道代码是否发生变化，我们必须使用前面提到的<code>accept</code>方法来进行监听，并实现对应的变化相应操作。</p>
<pre><code class="language-js">if(module.hot) { // 先判断是否开启HMR
    module.hot.accept('./xxx.js', function() {
        // do something
    })
}
</code></pre>
<p><strong>提示：<code>accept</code>方法内容一般不用自己实现，很多工具（如vue-loader，style-loader）内部已提供，直接使用即可。</strong></p>
<p>参考资料：<a href="https://zhuanlan.zhihu.com/p/30669007">Webpack HMR 原理解析</a>，<a href="https://juejin.im/post/6844904193136787470">了不起的 Webpack HMR 学习指南</a>。</p>
<h2 id="开发loader">开发loader</h2>
<p>webpack官方和社区已经提供了非常多的loader，正常来说，常用的文件解析都可以找到现成的loader。不过，来了解一下如何开发loader，有助于自己对loader工作原理的理解，而且在有需求的时候，也可以自己撸一个loader。</p>
<h3 id="开发一个简单的loader">开发一个简单的loader</h3>
<p>其实自定义一个loader非常简单，本质上loader即是一个函数，接收参数并对其进行处理，而后返回处理结果（<strong>须为buffer或string</strong>）。</p>
<ul>
<li>新建<code>/loaders/replaceLoader.js</code>，</li>
</ul>
<pre><code class="language-js">// /loaders/replaceLoader.js
module.exports = function (source) {
  source = source.replace(/webpack/gi, 'world'); // 将源文件中的webpack替换成world
  return source;
};
</code></pre>
<ul>
<li>新建<code>/src/index.js</code></li>
</ul>
<pre><code class="language-js">// /src/index.js
console.log('hello webpack');
</code></pre>
<ul>
<li>配置webpack</li>
</ul>
<p>接下来，有必要先了解下如何来配置上面的loader。一般第三方的loader，安装了都在<code>node_modules</code>下面，webpack会从此处去找，但是现在loader在<code>/loaders/testLoader.js</code>，所以需要做些处理，有如下几种方式：</p>
<ol>
<li>直接require对应的loader（适用于单个loader）</li>
</ol>
<pre><code class="language-js">// webpack.config.js
module: {
  rules: [
    {
      test: /\.js$/,
      exclude: /node_modules/,
      loader: path.resolve('./loaders/replaceLoader.js')
    }
  ]
}
</code></pre>
<ol start="2">
<li>使用<code>resolveLoader</code>配置项（适用于多个loader）</li>
</ol>
<pre><code class="language-js">// webpack.config.js
module: {
  rules: [
    {
      test: /\.js$/,
      exclude: /node_modules/,
      use:'replaceLoader'
    }
  ]
},
resolveLoader: {
  modules: ['node_modules', path.resolver(__dirname, 'loaders')] // 查找优先级从左到右
}
</code></pre>
<ol start="3">
<li>如果准备将loader发布到npm，也可以使用 <a href="https://docs.npmjs.com/cli/link">npm-link</a>。</li>
</ol>
<p>这里，采用第二种方式，完整配置如下：</p>
<pre><code class="language-js">// webpack.config.js
const path = require('path');
module.exports = {
  mode:'development',
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  resolveLoader: {
    modules: ['node_modules', path.resolve(__dirname, 'loaders')]
  },
  module: {
    rules: [{
      test: /\.js$/,
      use:'replaceLoader'
    }]
  }
};
</code></pre>
<p>运行一下，打包命令<code>npx webpack</code>，可以看到输出文件中的webpack被替换成了world。</p>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/letwrong/Picture/raw/master/20200614224707.png" alt="image-20200614224707431" loading="lazy"></figure>
<p>一般loader都会提供配置项(options)，方便用户做个性配置，可以通过<code>this.query</code>获取配置内容，不过一般使用官方推荐的<a href="https://github.com/webpack/loader-utils">loader-utils</a> 工具更加便捷。</p>
<pre><code class="language-js">// webpack.config.js
const path = require('path');
module.exports = {
  mode:'development',
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  resolveLoader: {
    modules: ['node_modules', path.resolve(__dirname, 'loaders')]
  },
  module: {
    rules: [{
      test: /\.js$/,
      use: {
        loader:'replaceLoader',
        options: {
          src: /webpack/ig, // 配置要替换的内容
          to: 'world!' // 配置替换的目标内容
        }
      }
    }]
  }
};
</code></pre>
<p>修改一下<code>replaceLoader</code>：</p>
<pre><code class="language-js">// /loaders/replaceLoader.js
const loaderUtils = require('loader-utils');
module.exports = function (source) {
  const options = loaderUtils.getOptions(this);
  source = source.replace(options.src, options.to);
  return source;
};
</code></pre>
<p>**注意：**这里使用了this，this提供了很多有用的信息，所以不能使用箭头函数（会改变this指向）。如果需要对options进行校验，可以使用<a href="https://github.com/webpack/schema-utils">schema-utils</a>。</p>
<h3 id="复杂的情况">复杂的情况</h3>
<p>至此，一个简单的loader就实现了，当然有时候可能会更加复杂。</p>
<p>其实，loader函数会接收三个参数：content、map、meta</p>
<ul>
<li>content：模块内容，可以是字符串或者buffer</li>
<li>map：sourcemap 对象</li>
<li>meta：一些元数据信息</li>
</ul>
<p>如果仅仅是返回处理结果，直接返回content即可。但如果需要生成sourcemap 对象、meta元数据或者抛出异常，需要将return换成<code>this.callback(err, content, map, meta)</code>来传递数据。</p>
<pre><code class="language-js">this.callback(
    // 当无法转换原内容时，给 Webpack 返回一个 Error
    err: Error | null,
    // 原内容转换后的内容
    content: string | Buffer,
    // 用于把转换后的内容得出原内容的 Source Map，方便调试
    sourceMap?: SourceMap,
    // 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回，
    // 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能
    abstractSyntaxTree?: AST
);
</code></pre>
<p>另外，loader也是支持异步任务处理的，可以借助<code>this.async()</code>实现。</p>
<pre><code class="language-js">// /loaders/replaceLoader.js
const loaderUtils = require('loader-utils');
module.exports = function (source) {
  const options = loaderUtils.getOptions(this);
  const asyncfunc = this.async() // 调用异步func
  setTimeout(() =&gt; {
  	source = source.replace(options.src, options.to);
    asyncfunc(null, source) // 传递结果
  }, 200)
};
</code></pre>
<p>关于loader的开发，官方提供了很多api，读者可以查阅 <a href="https://webpack.js.org/api/loaders/">loader interface</a> 了解。</p>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>loader要遵循职责单一原则，一个loader只做一种转换，如果需要对源文件进行多次转换处理，则需要多个loader来实现。</li>
<li>调用多个loader来处理一个文件时，默认情况下loader会从后到前链式顺序执行，最后一个loader将会拿到文件的原始内容，处理后会将结果传递给下一个loader继续处理，直到最前面的loader处理完成返回给webpack。</li>
</ul>
<h2 id="开发plugin">开发plugin</h2>
<p>plugin是webpack中非常重要的部分，它赋予了webpack强大的扩展能力。和loader不同的是loader主要是为了让webpack能够解析更多类型的文件，而plugin则可以参与打包过程中每个阶段。从使用方式我们可以看出plugin其实就是一个类，在调用构造函数的时候传入配置参数。</p>
<p>**注意：**下面使用的是webpack4.0版本，相比3.0的api是不一样的。</p>
<h3 id="开发一个简单的plugin">开发一个简单的plugin</h3>
<p>自定义plugin的引入方式相比loader来说，非常简单：</p>
<pre><code class="language-js">// webpack.config.js
const path = require('path')
const TestWebpackPlugin = require('./test-webpack-plugin')
module.exports = {
    mode: 'development',
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name]_[hash].js'
    },
    plugins: [
        new TestWebpackPlugin({
            // ...options
        })
    ]
}
</code></pre>
<blockquote>
<p>webpack的plugin命名需要遵循<code>插件名字-webpack-plugin</code>的格式。</p>
</blockquote>
<p>而plugin内部的实现也是比较简单的，由以下几部分组成：</p>
<ul>
<li>一个可以通过new调用的类函数</li>
<li>在该函数的<code>prototype</code>上定义一个<code>apply</code>方法，参数为<code>compiler</code></li>
<li>在<code>apply</code>方法中注册要监听的钩子名称、插件名称、回调函数</li>
<li>在回调函数中通过注入的参数，读取或操纵修改 Webpack 内部实例数据</li>
<li>异步类型的事件钩子，插件处理完成需要调用<code>callback</code>或者返回<code>promise</code></li>
</ul>
<pre><code class="language-js">// test-webpack-plugin.js
class TestWebpackPlugin {
    constructor (options) {
        // 在这里获取插件配置
    }
    // Webpack 会调用此 apply 方法并传入 compiler 对象
    apply (compiler) {
     		 // 这里可以在compiler的钩子（hook）上注册一些方法，	当webpack执行到特定的钩子时就会执行该阶段注册的方法
        compiler.hooks.done.tap('TestWebpackPlugin', (stats) =&gt; {
          console.log('Hello TestWebpackPlugin!');
            // ...
        })
      	// 在emit钩子上注册一个处理函数，因为该钩子为异步的，所以需要使用tapAsync
      	// emit钩子执行时机在资源输出到output之前
        compiler.hooks.emit.tapAsync('TestWebpackPlugin', (compilation, cb) =&gt; {
            // 在输出文件中增加一个文件test.js
            compilation.assets['test.js'] = {
              source() { // 文件内容
                return 'console.log(&quot;hello world&quot;)'
              },
              size() { // 文件的长度
                return 27;
              }
            };
            cb();    // 处理完成调用cb
        })
    }
}
module.exports = TestWebpackPlugin
</code></pre>
<h3 id="执行流程">执行流程</h3>
<p>plugin内部核心就是apply，使用插件的时候，webpack会自动调用插件实例的apply方法，并将compiler作为参数传入。在<code>apply</code>内部，我们可以在<code>compiler</code>的hooks中特定的钩子上注册各种监听函数（发布订阅模式），当webpack执行到这些钩子的时候，就会调用对应的监听函数，从而实现对构建流程的处理。</p>
<p>下面我们以前面例子来了解插件具体的执行流程：</p>
<ul>
<li>
<p>通过<code>&lt;instance&gt;.hooks.&lt;hook name&gt;.&lt;tap API&gt;('&lt;plugin name&gt;', callback )</code>方式来进行hooks事件注册。</p>
<ul>
<li><code>instance</code>： <code>compiler</code> 或 <code>compilation</code> 实例</li>
<li><code>hook name</code> ：挂载目标钩子的名称</li>
<li>处理钩子可能是同步，也可能是异步的，需要使用根据不同情况选择使用的<code>tap API</code>，<code>tap API</code> 有三种：</li>
<li><code>tap</code> 用于挂载一个同步回调，适合任何事件钩子类型，使用回调返回结果。
<ul>
<li><code>tapAsync</code> 用于挂载一个异步回调，不能对同步类型钩子使用，回调中会注入 <code>callback</code>参数供插件处理完操作后调用，如果不调用 <code>callback</code> 交回流程控制权，将无法继续进行后续操作。</li>
<li><code>tapPromise</code> 和 <code>tapAsync</code> 的作用和限制类似，不同在于要求返回一个 <code>Promise</code> 实例，并且这个 <code>Promise</code> 一定会被决议（无论 resolve 或 reject ）</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 同步
compiler.hooks.done.tap('MyPlugin', (stats, callback) =&gt; {
  // ...
  callback()
})
// 异步promise
compiler.hooks.emit.tapPromise('MyPlugin', (compilation) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    // ...
  })
})
// 异步async function
compiler.hooks.emit.tapPromise('MyPlugin', async (compilation) =&gt; {
  await new Promise((resolve, reject) =&gt; {
    // ...
  })
})
// 异步回调
compiler.hooks.emit.tapAsync('MyPlugin', (compilation, callback) =&gt; {
	// ...
  callback()
})
</code></pre>
<ul>
<li>
<p>在钩子上注册的函数，接收两个参数，第一个为插件的名字，第二个为回调函数</p>
<ul>
<li>这个回调函数即为处理函数的主要内容，接收的参数由钩子决定，这里的<code>emit</code>钩子接收两个参数（分别是compilation, cb），compilation记录了本次打包的相关内容，cb回调函数在处理完成进行调用交回控制权。</li>
</ul>
</li>
<li>
<p><code>compilation.assets</code>保存了本次打包出来的所有的文件信息，上面的例子即往<code>assets</code>中新增了一个<code>test.js</code>文件（前提是添加之前，assets中没有与该文件同名的文件），source和size分别设置了文件的内容和长度。如果是对文件进行处理，直接对<code>assets</code>中的文件进行操作即可。</p>
</li>
<li>
<p>compilation上也可以注册钩子, 即存在<a href="https://webpack.js.org/api/compiler-hooks/">Compiler Hooks</a>和<a href="https://webpack.js.org/api/compilation-hooks/">Compilation Hooks</a>两种。</p>
</li>
</ul>
<pre><code class="language-js">compiler.hooks.compilation.tap('MyPlugin', (compilation) =&gt; {
  compilation.hooks.optimizeChunkAssets.tapAsync(
      'MyPlugin',
      (chunks, callback) =&gt; {
       	// 处理chunks
        // 结束调用callback方法
        callback();
      }
    );
})
</code></pre>
<h3 id="hooks">hooks</h3>
<p>除了上述的<code>emit</code>钩子，webpack还提供了许多其他的钩子，覆盖到打包的各个阶段。</p>
<h4 id="entryoption"><code>entryOption</code></h4>
<p>在<code>entry</code>配置项处理完成后执行，同步钩子。</p>
<pre><code class="language-js">compiler.hooks.entryOption.tap('MyPlugin', (context, entry) =&gt; {
  // context保存了当前目录信息，entry保存了入口文件信息
});
</code></pre>
<h4 id="afteremit"><code>afterEmit</code></h4>
<p>生成资源到<code>output</code>后执行，异步钩子。</p>
<h4 id="done"><code>done</code></h4>
<p>编译完成执行，同步钩子。</p>
<pre><code class="language-js">compiler.hooks.done.tap('TestWebpackPlugin', (stats) =&gt; {
  // stats保存了生成文件的内容
})
</code></pre>
<p>更多的hooks和用法可以查看<a href="https://webpack.js.org/api/compiler-hooks/#hooks">Plugin-Compiler Hooks</a>。</p>
<p>这些hooks的实现是基于<a href="https://github.com/webpack/tapable/">tapable</a>这个库，这个库提供了大量的钩子。这些钩子大概分为如下几类：</p>
<ul>
<li>并行的：名称带有<code>parallel</code>，该类函数注册后会并行调用。</li>
<li>顺序的：名称带有<code>bail</code>，该类函数注册后会顺序调用。</li>
<li>流式的：名称带有<code>waterfall</code>，该类函数注册后，调用时会流式处理，将上一个函数的返回结果作为下一个函数的参数。</li>
<li>组合的：也存在上述三种规则结合在一起的钩子。</li>
</ul>
<p>通过这些钩子，插件开发者可以干预构建的整个流程，从而实现对构建过程和内容的控制，如依赖查找，文件监听、修改文件内容等，所以编写一个插件的关键就在于使用各种hooks钩子函数。</p>
<p>这里我们仅简单了解了loader和plugin，实际开发中可能要复杂得多，这里也不可能穷尽所有场景和用法，仅做抛砖引玉，在实际开发的时候还需要自行查阅相关文档，作深入了解。</p>
<p>参考文档：<a href="https://webpack.docschina.org/">webpack官网-中文</a>，<a href="http://www.xbhub.com/wiki/webpack/">深入浅出webpack</a>，<a href="https://www.yuque.com/fe9/basic/sdviix">深入了解 Webpack</a></p>
<h1 id="结语">结语</h1>
<p>webpack每个版本都有一个代号，4.0被命为<code>Legato</code>，意为“连奏”，寓意webpack在不断进化。webpack的进化点都是通过贡献者和用户投票来决定的。在3.0的时候，投票最多的用户体验、构建性能等都在weback4.0得到了巨大改善。</p>
<p>在当下，webpack是稳坐前端构建工具界扛把子之位，它确实是一款优秀的构建工具，它不仅拥有强大的扩展能力，还拥有一群优秀的开发者，拥有活跃的社区，给它提供源源不断的生命力，这些都是webpack最核心的竞争力。</p>
<p>在未来，随着ESModule规范的普及，或许我们将不再需要工具来进行模块打包，webpack也有可能被替代，但是我相信构建工具不会退出舞台，而只会做越来越多的事情，因为工程化的理念已深入人心。</p>
<p>但是，学习webpack这类构建工具并不是我们的最终目的，因为归根结底他们只不过是一个工具而已，是工具就会被更新被取代，而如何利用工具来解放生产力才应该是前端工程化的最终目的。前端工程化更重要的是一种思想，而不是特指某个特定的工具，他们仅是手段而已。在工作中要有意识将一些复杂或耗时的工作交给程序来做，并且可以将用到的工具和方法分享给其他人，如此不仅可以提高自己和团队的开发效率，还能提升自己的影响力，升职加薪，迎娶白富美... 想想是不是觉得有点小心机呢？</p>

							</div>
	<div class="wow fadeInUp vt-post-tags">
 
				<a href="https://www.bwrong.cn/tag/webpack/" rel="tag">webpack</a>
				 
					</div>
<nav class="navigation3 post-navigation3" role="navigation">

		<div class="nav-links3">
      
		<div class="wow fadeInUp nav-previous3"><a href="https://www.bwrong.cn/post/dev-tools05/" rel="prev"> 【前端工程化】篇五 未来已来-Babel</a></div>
		 
		 
		<div class="wow fadeInUp nav-next3"><a href="https://www.bwrong.cn/post/dev-tools03/" rel="next"> 【前端工程化】篇三 席卷八荒-Webpack（基础）</a></div>
		
		</div>
	</nav>
	<div class="wow fadeInUp author-info">
	<div class="author-avatar pull-left"><img src="https://www.bwrong.cn/images/avatar.png" ></div>
 
	<div class="author-description"><div class="author-title"><div class="author-link" rel="author">BWrong</div></div>


	<p class="author-bio">愿你走出半生，归来仍是少年</p></div></div>
	
		</div>



</article>

<div id="marlin_lite_about_widget-2" class="wow fadeInUp widget marlin_lite_about_widget" data-wow-delay="0.1s">

        
		<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://www.bwrong.cn/media/scripts/Valine.min.js'></script>

<div class="comment"></div>
<script>
        new Valine({
            av: AV,
            el: '.comment',
            lang: 'zh-cn',
            visitor: false, // 阅读量统计
            
            admin_email:'wang11535041@qq.com',
            
            
            emoticon_url: '/media/alu',
             
      emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
     
      app_id: 'jaz3TfUjRowK9fOMAPb9yw6i-MdYXbMMI',
      
      
      app_key: 'pbltxx4rElIP1RStL3AwujSp',
         
          
      placeholder: '欢迎你留下足迹'
       
        });
    </script>





		</div>

			</div>
			


<div class="tocc col l3 hide-on-med-and-down">

        <div class="toc-widget">

            <div class="toc-title"></div>

            <div id="toc-content">


			</div>
        </div>
    </div>


<script src="https://www.bwrong.cn/media/scripts/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '.entry-summary',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1,h2' //**
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('.entry-summary').children('h1, h2').each(function () {/**/
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget').parent();
        // let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>






			</div>
		</div>


		 <footer id="colophon" class="site-footer">

	<div class="container">

		<div class="copyright"> <br>Theme: <a
				href="https://github.com/alterfang/gridea-theme-pan" target="_blank" title="Pan"><span>Pan</span></a>.
			Powered by <a href="https://gridea.dev/" target="_blank" title="Gridea"><span>Gridea</span></a> . 版权所有：<a href="https://beian.miit.gov.cn/" target="_blank"><span>蜀ICP备2023018303号-1</span></a></div>
	</div>

</footer>
		<!-- loding -->
		<div class="loader">
			<div class="loader-content">
				<div class="songjingge">
					<span></span>
					<span></span>
					<span></span>
					<span></span>
					<span></span>
				</div>
			</div>
		</div>
<script id="rendered-js">
	window.onload = function () {
			var loader = document.getElementsByClassName("loader")[0];
			loader.className = "loader fadeout"; //使用渐隐的方法淡出loading page
			setTimeout(function () {
				loader.style.display = "none";
			}, 0);
	};
</script>


</div>

<script src="https://cdn.bootcss.com/fitvids/1.2.0/jquery.fitvids.min.js"></script>
<script type='text/javascript' src='https://www.bwrong.cn/media/scripts/marlin-scripts.js'></script>
<script src="https://www.bwrong.cn/media/scripts/lately.min.js"></script>
<script>jQuery(document).ready(function () { $.lately({ 'target': '.lately-a,.lately-b,.lately-c' }) });</script>
<style type="text/css">
  a.back_to_top {
    text-decoration: none;
    position: fixed;
    bottom: 40px;
    right: 30px;
    background: #f0f0f0;
    height: 40px;
    width: 40px;
    border-radius: 50%;
    line-height: 36px;
    font-size: 18px;
    text-align: center;
    transition-duration: .5s;
    transition-propety: background-color;
    display: none;
  }

  a.back_to_top span {
    color: #888;
  }

  a.back_to_top:hover {
    cursor: pointer;
    background: #dfdfdf;
  }

  a.back_to_top:hover span {
    color: #555;
  }

  @media print,
  screen and (max-width: 580px) {
    .back_to_top {
      display: none !important;
    }
  }
</style><a id="back_to_top" href="#" class="back_to_top"><span><i class="iconfont icon-xiangshang"></i></span>
</a>

<script>
$(document).ready((function (_this) {
    return function () {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function () {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block');
          } else {
            return bt.css('display', 'none');
          }
        });
        return bt.click(function () {
          $('body,html').animate({
            scrollTop: 0
          }, 800);
          return false;
        });
      }
    };
  })(this));
//   $(window).load(function () {
//     //异步延迟加载样式
//     var link = $('<link />');
//     link.attr('href', 'https://fonts.googleapis.com/css?family=Dancing+Script|Noto+Sans+SC:300|Montserrat&display=swap');
//     link.attr('rel', 'stylesheet');
//     link.appendTo($('head'));
// });
</script>

<!-- 宠物 -->
<canvas id="live2dcanvas" width="200" height="400" class="live2d"></canvas>
<style>
  #live2dcanvas {
    position: fixed;
    right: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -40px;
    width: 200px;
    height: 400px;
  }

  @media (max-width: 768px) {
    #live2dcanvas {
      width: 150px;
      height: 300px;
    }
  }

  @media (max-width: 639px) {
    #live2dcanvas {
      display: none !important;
    }
  }
</style>
<script src="https://www.bwrong.cn/media/scripts/L2Dwidget.min.js"></script>
<script>
  //初始化小人物 需设置属性pluginRootPath: "live2dw/"指明资源跟路径
  L2Dwidget.init({
    pluginRootPath: "media/",//资源root路径
    pluginJsPath: "scripts/",//js相对root的路径
    pluginModelPath: "model/",//模型相对root的路径
    tagMode: !1,
    debug: !1,
    model: {
      scale: 2,
      jsonPath: "/media/model/live2d-widget-model-epsilon/Epsilon2.1.model.json"
    },
    display: {//大小位置什么的自己慢慢调就是了
      position: "right",//定位
      width: 130,//宽度
      height: 210,//高度
      hOffset: -40,//左右
      vOffset: 0//上下
    },
    mobile: {
      show: !1
    },
    log: !1
  });
</script>
<!-- 宠物结束 -->

		<script data-no-instant>
    // (function ($) {
    //     $.extend({
    //         adamsOverload: function () {
    //             $('.navigation:eq(0)').remove();
    //             $("").attr("rel" , "external");
    //             $("a[rel='external'],a[rel='external nofollow']").attr("target","_blank");
    //             $("a.vi").attr("rel" , "");
    //             $.viewImage({
    //                 'target'  : 'img',
    //                 'exclude' : '.vsmile-icons img,.gallery img',
    //                 'delay'   : 300
    //             });
    //             $.lately({
    //                 'target' : '.commentmetadata a,.infos time,.post-list time'
	// 			});
	// 			console.log(prettyPrint)
	// 			if(prettyPrint) prettyPrint();

    //             $('ul.links li a').each(function(){
    //                 if($(this).parent().find('.bg').length==0){
    //                     $(this).parent().append('<!---<div class="bg" style="background-image:url(https://c3.glgoo.top/s2/favicons?domain='+$(this).attr("href")+')"></div>--->')
    //                 }
    //             });
    //         }
    //     });
    // })(jQuery);
	// jQuery.adamsOverload();

    (function ($) {
        $.extend({
            adamsOverload: function () {
                $.viewImage({
                    'target'  : '.song img',
                    'exclude' : '.vsmile-icons img',
                    'delay'   : 300
                });
            }
        });
    })(jQuery);
    jQuery.adamsOverload();
</script>

</body>
</html>
