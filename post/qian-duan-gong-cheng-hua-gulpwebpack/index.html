
<!DOCTYPE html>
<html lang="zh-CN">
<head>
 <meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
<meta HTTP-EQUIV="pragma" CONTENT="no-cache">
<meta HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate">
<meta HTTP-EQUIV="expires" CONTENT="0">
<meta name="author" content="bwrong, wang11535041@qq.com"/>
<meta name="keywords" content="前端工程化（Gulp、Webpack） | BWrong的小站,前端,krpano,js,vue"/>
<meta name="description" content="天青色等烟雨，而我在等你"/>
<!-- <title>前端工程化（Gulp、Webpack） | BWrong的小站</title> -->
<title>网站搭建测试</title>
<link href="https://www.bwrong.cn/media/css/fz.css" rel="stylesheet">
<link rel="stylesheet" href="https://www.bwrong.cn/styles/main.css">
<script type="text/javascript">
function getCSS()
{
        datetoday = new Date();
        timenow=datetoday.getTime();
        datetoday.setTime(timenow);
        thehour = datetoday.getHours();

        if (thehour<5)

            display = "https://www.bwrong.cn/media/css/night.css";

       else if (thehour>20)

            display = "https://www.bwrong.cn/media/css/night.css";

        else if (thehour>5)
     
            display = "https://www.bwrong.cn/media/css/day.css";

        else if (thehour<20)

            display = "https://www.bwrong.cn/media/css/day.css";


var css = '<';
        css+='link rel="stylesheet" href='+display+' \/';
        css+='>';
        document.write(css);
}
</script>
<link href="https://at.alicdn.com/t/font_1306644_ko4c4at97is.css" rel="stylesheet" />
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://www.bwrong.cn/media/css/katex.min.css">
<script type='text/javascript' src='https://www.bwrong.cn/media/scripts/script.js'></script>
<link href="https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet" />
  <script src="https://cdn.bootcss.com/wow/1.1.2/wow.min.js"></script>
  <script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>wow=new WOW({boxClass:'wow',animateClass:'animated',offset:0,mobile:true,live:true});wow.init();</script>

<script type="text/javascript">
window.onload=getCSS();
</script>
<!-- 百度统计 -->
<script>
var _hmt = _hmt || [];
(function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?2c0e9e3f54ae20480b34c178578c4df8";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
})();
</script>


</head>
<body class="post-template-default single single-post postid-70 single-format-standard">
    <div id="wrapper">

	
<header id="header" class="site-header"
		
		style="background-image: linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2)),url(https://www.bwrong.cn/post-images/qian-duan-gong-cheng-hua-gulpwebpack.jpg)"
		
		>
			<div class="site-branding">
									<h1 class="site-title"><a href="https://www.bwrong.cn" rel="home">BWrong的小站</a></h1>

					<h2 class="site-description">天青色等烟雨，而我在等你</h2>

							</div>
			<nav id="nav-wrapper">
				<div class="container">
					<div class="nav-toggle">
						<div class="bars">
							<div class="bar"></div>
							<div class="bar"></div>
							<div class="bar"></div>
						</div>
					</div>
					<div class="clear"></div>
					<ul id="" class="dove">
		 

<li>

	
		<a href="/">
		  首页
		</a>
	  

    

<li>

	
		<a href="/archives/index.html">
		  归档
		</a>
	  

    

<li>

	
		<a href="/post/about/">
		  关于
		</a>
	  

    

</ul>
</li>

</ul>				</div>
			</nav>
						<div class="jingge">


    

    

<a  href="https://github.com/BWrong" target="_blank" ><i class="iconfont icon-github"></i></a>
 
    

    

    

    

<a  href="https://juejin.cn/user/3421335914820280" target="_blank" ><i class="iconfont icon-telegram"></i></a>
 
    

    

    

    

    

    
        </header>


		<div id="content" class="container">
			<div class="row">
	<div class="col-md-8 site-main">

<article id="post-70" class="post-70 post type-post status-publish format-standard hentry category-5 tag-10 tag-9 tag-11">



		<div class="entry-content">
			<h1 data-wow-delay="0.4s"  class="wow fadeInUp entry-title">前端工程化（Gulp、Webpack）</h1>
<div class="entry-meta">
<div class="wow fadeInUp"  data-wow-delay="0.6s">
	<i class="iconfont icon-rili"> <time class="lately-a" datetime="2018-01-26 22:44:42" itemprop="datePublished" pubdate="">2018-01-26</time></i>
	          </div>

</span>

		</div>

			<div class="wow fadeInUp entry-summary song"  data-wow-delay="0.1s">
				<h1 id="前言">前言</h1>
<h2 id="起因">起因</h2>
<p>随着Web开发日渐复杂化和多元化，早已不是以前写几个页面布局加上点样式，再搞几个jQuery插件就能OK的了。前端做的事情越来越多，那么为了解放我们的生产力，提高团队的写作效率，我们就迫切需要一些工具来帮我们完成一些事情：</p>
<h4 id="内因">内因</h4>
<ul>
<li>代码转换：有时我们会采用一些高效的语言，不会直接书写HTML\CSS\JS，但是这些语言浏览器原生不支持，就需要工具将其进行转换；</li>
<li>文件优化：为了减少文件大小、服务器请求，我们需要工具对代码进行压缩、图片合并等；</li>
<li>代码审查：在团队协作中，特别是大项目，为了避免不必要的错误，减少维护成本，我们需要统一我们的代码风格；</li>
<li>模块合并与分割：现在大部分采用模块化的开发，我们需要工具能够分析我们模块的依赖关系，对其进行合理的分割和合并。</li>
<li>愉快的开发环境：在开发的时候，我们希望最大程度的解放我们的双手，把那些重复机械的工作交给工具去做，比如自动刷新、自动打包发布等</li>
</ul>
<h4 id="外因">外因</h4>
<p>得益于nodejs的快速发展，让js有了更大的能力：</p>
<ul>
<li>跳出了浏览器的沙盒，能够在命令行中使用</li>
<li>能够操作本地文件</li>
</ul>
<p>这两点是作为一个构建工具的必要条件。</p>
<h2 id="发展史">发展史</h2>
<ol>
<li>Grunt：前端自动化小工具，基于任务的命令行构建工具；</li>
<li>Gulp：和Grunt一样，也是基于Nodejs的自动任务运行器，但是采用流的方式，利用管道思路，前一节点的输出作为下一节点的输入，最后一步才输出文件到磁盘，大大提高了构建时间和性能。</li>
<li>webpack：模块化管理和打包工具，将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载，和前面的两个有明显的区别。</li>
<li>当然这其中也有其他的一些工具的出现，比如：Rollup（和 Webpack 很类似但专注于 ES6 的模块打包工具，但生态不如webpack），Fis3（来自百度的优秀国产构建工具，功能非常强大，但是官方已经不再维护），yeoman（脚手架自动生成工具，提供了很多项目模板），Bower（包），browserify（打包工具）</li>
<li>最近也有一匹黑马出现-Parcel，利用缓存提升性能与速度，零配置。待生态完善后有可能超越webpack。</li>
</ol>
<h2 id="对比">对比</h2>
<p>这张图很清楚的对比了几种主流的构建工具。<br>
<img src="https://www.bwrong.cn/post-images/1566713072373.jpg" alt="" loading="lazy"><br>
（图片来自网络）</p>
<h1 id="gulp">Gulp</h1>
<h2 id="简介">简介</h2>
<p>用自动化构建工具增强你的工作流程！</p>
<p>官网：<a href="https://gulpjs.com/">地址 </a></p>
<p>中文网：<a href="https://www.gulpjs.com.cn/">地址</a></p>
<p>基于Nodejs的自动任务运行器，采用流的方式，借鉴了Unix操作系统的管道（pipe）思想，仅在最后一步才输出文件到磁盘，快速高效。</p>
<p>官方仅提供5个API（4.0又增加了几个），利用这5个API我们可以完成测试、检查、合并、压缩、格式化、自动刷新、部署、监听等任务。而且因为只有5个API，上手也是特别简单。</p>
<h2 id="官方api">官方API</h2>
<p>如下api均是3.0版本，如需查看4.0版本文档，请移驾<a href="https://www.bwrong.cn/post/gulp4/">Gulp4.0入门指南</a></p>
<h4 id="gulpsrcglobs-options"><code>gulp.src(globs[, options]) </code></h4>
<p>匹配需要处理的源文件</p>
<ul>
<li><code>globs</code>：源文件匹配路径</li>
</ul>
<p>可以使用的模式:</p>
<pre><code>“src/a.js”：//指定具体文件；

“*”：//匹配所有文件    例：src/*.js(包含src下的所有js文件)；

“**”：//匹配0个或多个子文件夹    例：src/**/*.js(包含src的0个或多个子文件夹下的js文件)；

“{}”：//匹配多个属性    例：src/{a,b}.js(包含a.js和b.js文件)  src/*.{jpg,png,gif}(src下的所有jpg/png/gif文件)；

“!”：//排除文件    例：!src/a.js(不包含src下的a.js文件)；
</code></pre>
<pre><code>// 例
gulp.src(['style/**/*.scss','!style/{extend,page}/*.scss'])
</code></pre>
<ul>
<li><code>options[Object]</code>：有3个属性buffer、read、base</li>
</ul>
<pre><code>options.buffer：  类型：Boolean  默认：true 设置为false，将返回file.content的流并且不缓冲文件，处理大文件时非常有用；

options.read：  类型：Boolean  默认：true 设置false，将不执行读取文件操作，返回null；

options.base：  类型：String  设置输出路径以某个路径的某个组成部分为基础向后拼接
</code></pre>
<h4 id="gulpdestpath-options"><code>gulp.dest(path[, options]) </code></h4>
<p>任务完成后文件输出的路径</p>
<ul>
<li>path: 文件将被写入的路径（输出目录）,也可以传入一个函数，在函数中返回相应路径;</li>
<li><code>options[Object]</code>: 有两个属性</li>
</ul>
<pre><code>options.cwd：  类型：String  默认：process.cwd()：输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效；

options.mode：  类型：String  默认：0777 八进制权限字符，用以定义所有在输出目录中所创建的目录的权限；
</code></pre>
<pre><code>// 例
.pipe(gulp.dest('./build/minified_templates'));
</code></pre>
<h4 id="gulptaskname-deps-fn"><code>gulp.task(name[, deps], fn)</code></h4>
<p>定义一个任务</p>
<ul>
<li>name：任务的名字，不能使用空格</li>
<li>deps：前置任务，一个包含任务列表的数组，这些任务会在你当前任务运行之前完成（记得使用正确的异步执行方式：使用cb或者返回stream或promise ）。</li>
</ul>
<pre><code>//callback
// 在 shell 中执行一个命令
var exec = require('child_process').exec;
gulp.task('jekyll', function(cb) {
  // 编译 Jekyll
  exec('jekyll build', function(err) {
    if (err) return cb(err); // 返回 error
    cb(); // 完成 task
  });
});

//返回stream
gulp.task('somename', function() {
  var stream = gulp.src('client/**/*.js')
    .pipe(minify())
    .pipe(gulp.dest('build'));
  return stream;
});

//返回promise
var Q = require('q');

gulp.task('somename', function() {
  var deferred = Q.defer();

  // 执行异步的操作
  setTimeout(function() {
    deferred.resolve();
  }, 1);

  return deferred.promise;
});
</code></pre>
<ul>
<li>fn：定义任务所要执行的一些操作。</li>
</ul>
<h4 id="gulpwatchglob-opts-tasks-或-gulpwatchglob-opts-cb"><code>gulp.watch(glob [, opts], tasks)</code> 或<code> gulp.watch(glob [, opts, cb])</code></h4>
<p>监视文件，并且可以在文件发生改动时候执行指定任务</p>
<ul>
<li>glob：要监听的文件入口，可以是一个也可以是多个（数组表示）</li>
<li>tasks：文件改变要执行的任务的名称数组</li>
<li>cb：文件改变要执行的回调函数</li>
</ul>
<pre><code>gulp.task('watch1', function () {
    gulp.watch('less/**/*.less', ['testLess']);
});

gulp.task('watch2', function () {
    gulp.watch('js/**/*.js', function (event) {
        console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');
    });
});
</code></pre>
<h4 id="gulpstarttaskname1taskname2"><code>gulp.start(taskName1,taskName2,...)</code></h4>
<p>执行指定任务</p>
<ul>
<li>taskName：任务名称</li>
</ul>
<h2 id="开始使用">开始使用</h2>
<h4 id="一-安装">一、安装</h4>
<ul>
<li>全局安装</li>
</ul>
<pre><code>npm install --global gulp
</code></pre>
<ul>
<li>项目依赖安装</li>
</ul>
<pre><code>npm install --save-dev gulp
</code></pre>
<h4 id="二-创建配置文件">二、创建配置文件</h4>
<p>在文件根目录创建一个名为gulpfile.js的文件。</p>
<pre><code class="language-js">var gulp = require('gulp');

gulp.task('default', function() {
  // 将你的默认的任务代码放在这
});
</code></pre>
<h4 id="三-新建任务">三、新建任务</h4>
<p>根据自己需要，安装插件并且配置相应的任务。</p>
<p>以下通过几个案例来学习：</p>
<h6 id="清除文件del">清除文件（del）</h6>
<pre><code class="language-js">var gulp = require('gulp'),
    del = require('del');
gulp.task('clear', function (cb) {
    del(['static/css', 'static/html', 'static/js', 'static/picture', 'static/skin', 'tour.xml'], cb);
});
</code></pre>
<h6 id="less编译及压缩gulp-less-gulp-clean-css">Less编译及压缩（gulp-less、gulp-clean-css）</h6>
<pre><code class="language-js">var gulp = require('gulp'),
    less = require('gulp-less'),
    cleanCSS = require('gulp-clean-css');

gulp.task('runLess', function () {
    gulp.src('src/less/*.less')
        .pipe(less())
        .pipe(cleanCSS({
            compatibility: 'ie8', //兼容
            keepSpecialComments: '*' //是否保留前缀
        }))
        .pipe(gulp.dest('src/css'));
});
</code></pre>
<h6 id="图片压缩gulp-imagemingulp-changed">图片压缩(gulp-imagemin,gulp-changed)</h6>
<pre><code>var gulp = require('gulp'),
    changed = require('gulp-changed'),
    imagemin = require('gulp-imagemin');
gulp.task('picmin', function () {
    return gulp.src('./dev/static/picture/**/*.{jpg,jpeg,png,gif,ico,JPG}')
        .pipe(changed('./static/picture')) //缓存起来，只有图片变动时才压缩，提高效率
        .pipe(imagemin({
            optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）
            progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片
            interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染
        }))
        .pipe(gulp.dest('./static/picture'));
});
</code></pre>
<h6 id="启动本地服务器browsersync">启动本地服务器（browserSync）</h6>
<pre><code>var gulp = require('gulp'),
    browserSync = require('browser-sync').create();
gulp.task('server', function () {
    browserSync.init({
        server: {
            baseDir: './', // 在 dist 目录下启动本地服务器环境，自动启动默认浏览器
            proxy: '10.6.63.234'
        }
    });
});
</code></pre>
<h5 id="默认任务">默认任务</h5>
<p>可以定一个名为default的task，这个task就是默认的任务（直接运行gulp即可），可以在这里运行其他的任务，个人习惯把整套构建流程都放在这里调用。<br>
插件可以在网上搜索或者在npm官网查找，一般以gulp开头，每个插件的配置有所不同，可以在插件介绍页查看，就不一一介绍了。</p>
<h4 id="四-运行任务">四、运行任务</h4>
<p>在命令行中运行任务</p>
<pre><code>gulp taskName //运行指定名字的task
gulp          //运行默认任务
</code></pre>
<p>可以在package.json的scripts中配置常用操作，然后通过npm run 方式调用</p>
<h2 id="常用技巧">常用技巧</h2>
<p>参见：<a href="https://www.gulpjs.com.cn/docs/recipes/">地址</a></p>
<h2 id="配合webpack">配合webpack</h2>
<p>参见：<a href="https://www.jianshu.com/p/9724c47b406">地址</a></p>
<h1 id="webpack">Webpack</h1>
<h2 id="什么是webpack">什么是Webpack</h2>
<p>现代 JavaScript 应用程序的静态模块打包器(module bundler)，它能够根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源；本身只支持javascript，通过loader可以支持其他资源，每个资源即一个模块，在webpack中一切皆模块；通过plugins的扩展，拥有强大的功能。已经成为目前最流行，社区最活跃的打包工具。</p>
<p>官网：<a href="https://doc.webpack-china.org">地址</a><br>
<img src="https://www.bwrong.cn/post-images/1566713326146.png" alt="" loading="lazy"></p>
<h2 id="为什要使用webpack">为什要使用Webpack</h2>
<p>近年来 Web 应用变得更加复杂与庞大，Web 前端技术的应用范围也更加广泛，为了方便维护和管理，需要用模块化的思想来组织代码，产生了一些需求：</p>
<ul>
<li>将依赖树拆分成按需加载的块</li>
<li>初始化加载的耗时尽量少</li>
<li>各种静态资源都可以视作模块</li>
<li>将第三方库整合成模块的能力</li>
<li>可以自定义打包逻辑的能力</li>
<li>适合大项目，无论是单页还是多页的 Web 应用</li>
</ul>
<h2 id="模块化">模块化</h2>
<h5 id="传统方式script">传统方式<code>&lt;script&gt;</code></h5>
<p>缺点很明显：</p>
<ul>
<li>全局作用域下容易造成变量冲突，如jq和zepto</li>
<li>文件只能按照 <code>&lt;script&gt;</code> 的书写顺序进行加载</li>
<li>开发人员必须主观解决模块和代码库的依赖关系</li>
<li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪</li>
</ul>
<h5 id="amd">AMD</h5>
<p>与 CommonJS 最大的不同在于它采用异步的方式去加载依赖的模块。 AMD 规范主要是为了解决针对浏览器环境的模块化问题，最具代表性的实现是 requirejs。</p>
<p>缺点在于JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。</p>
<h5 id="cmd">CMD</h5>
<p>规范和 AMD 很相似，推崇就近依赖，只有在用到某个模块的时候再去require，国产，代表SeaJS</p>
<p>缺点依赖 SPM 打包，模块的加载逻辑偏重</p>
<h5 id="commonjs">CommonJS</h5>
<p>一种使用广泛的 JavaScript 模块化规范，核心思想是通过 require 方法来同步地加载依赖的其他模块，通过 module.exports 导出需要暴露的接口。 CommonJS 规范的流行得益于 Node.js 采用了这种方式，后来这种方式被引入到了网页开发中。</p>
<p>缺点在于这样的代码无法直接运行在浏览器环境下，必须通过工具转换成标准的 ES5。</p>
<h5 id="es6-模块化">ES6 模块化</h5>
<p>国际标准化组织 ECMA 提出的 JavaScript 模块化规范，它在语言的层面上实现了模块化。浏览器厂商和 Node.js 都宣布要原生支持该规范。它将逐渐取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>缺点在于目前无法直接运行在大部分 JavaScript 运行环境下，必须通过工具转换成标准的 ES5 后才能正常运行。</p>
<h2 id="一-安装-2">一、安装</h2>
<p>全局安装：</p>
<pre><code>npm install webpack -g
</code></pre>
<p>项目依赖安装：</p>
<pre><code>npm install webpack --save-d
</code></pre>
<h2 id="在命令行使用">在命令行使用</h2>
<pre><code>webpack &lt;entry&gt; [&lt;entry&gt;] &lt;output&gt;
</code></pre>
<ul>
<li>entry:入口文件，可以是多个</li>
<li>output：输出文件的路径及名字</li>
</ul>
<hr>
<p>更多命令行用法：<a href="https://doc.webpack-china.org/api/cli">地址</a></p>
<h2 id="指定配置文件">指定配置文件</h2>
<p>默认为根目录的webpack.config.js，也可以手动指定</p>
<pre><code>webpack [--config webpack.config.js]  //在命令行中手动指定配置文件
</code></pre>
<p>完整的配置文件模板：<a href="https://doc.webpack-china.org/configuration/">地址</a></p>
<h2 id="核心配置">核心配置</h2>
<h4 id="context">Context</h4>
<p><code>string</code></p>
<p>基础目录（上下文），绝对路径，用于从配置中解析入口起点(entry point)和 loader，<br>
默认为执行启动 Webpack 时所在的当前工作目录。可以通过以下方式改变：</p>
<pre><code class="language-js">module.exports = {
  context: path.resolve(__dirname, 'app')
}
</code></pre>
<h4 id="entry">Entry</h4>
<p><code>string | [string] | object { &lt;key&gt;: string | [string] } | (function: () =&gt; string | [string] | object { &lt;key&gt;: string | [string] })</code></p>
<p>应用程序的起点入口，webpack将从这里开始查找依赖关系</p>
<ul>
<li>字符串或数组：只会生成一个 Chunk，会被命名为 main</li>
<li>对象：每个键(key)生成一个chunk，名称为对应的key，入口则为对应的value</li>
<li>函数：动态生成入口地址</li>
</ul>
<pre><code>entry: {
  home: &quot;./home.js&quot;,
  about: &quot;./about.js&quot;,
  contact: &quot;./contact.js&quot;
}
</code></pre>
<h4 id="output">Output</h4>
<p><code>object</code><br>
最终输出的文件及路径</p>
<ul>
<li>Output.filename: 输出文件名，可以使用占位符</li>
</ul>
<pre><code>id	        Chunk的唯一标识，从0开始
name	    Chunk的名称
hash	    Chunk的唯一标识的 Hash 值
chunkhash	Chunk内容的 Hash 值
query       Chunk的query，文件名?后面的字符串
</code></pre>
<ul>
<li>Output.path: 存放的本地目录，必须是 string 类型的绝对路径</li>
</ul>
<pre><code>output:{
    path: path.resolve(__dirname, 'dist_[hash]')
}
</code></pre>
<ul>
<li>Output.publicPath: 远程资源的URL前缀，默认为空</li>
</ul>
<pre><code>output:{
    path: path.resolve(__dirname, &quot;public/assets&quot;),
    publicPath: &quot;https://cdn.example.com/assets/&quot;
}
</code></pre>
<h4 id="module">Module</h4>
<p>配置如何处理模块。</p>
<h5 id="modulenoparse">module.noParse</h5>
<p><code>RegExp | [RegExp] | function</code></p>
<p>防止 webpack 解析那些与给定正则表达式相匹配的文件</p>
<pre><code>noParse: function(content) {
  return /jquery|lodash/.test(content);
}
</code></pre>
<h5 id="modulerules">module.rules</h5>
<p><code>array</code></p>
<p>为模块匹配对应的loader，并进行相关设置。值为数组，下位用Rule表示每一个项</p>
<ul>
<li>Rule.test：匹配需要解析的文件</li>
<li>Rule.include：定位包含的文件夹，优先于test</li>
<li>Rule.exclude：排除的文件及文件夹，优先于test、include</li>
<li>Rule.loader：配置解析的loader，可以是String或者Array。</li>
<li>Rule.options：loader配置参数</li>
<li>Rule.use：配置解析的loader，一般用于使用多个loader，数组，每一项即为一个loader，和Rule.loader、Rule.options用法一样</li>
</ul>
<p>常用loader：<a href="https://doc.webpack-china.org/loaders/">地址</a></p>
<pre><code>// css
{
    test: /\.css$/,
    use: [
        {
            loader: &quot;style-loader&quot;
        }, {
            loader: &quot;css-loader&quot;,
            options: {
                modules: true, // 指定启用css modules
                localIdentName: '[name]__[local]--[hash:base64:5]' // 指定css的类名格式
            }
        }
    ]
}
//图片
{
    test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
    loader: 'url-loader',
    options: {
      limit: 10000,
      name: utils.assetsPath('img/[name].[hash:7].[ext]')
    }
}

</code></pre>
<h4 id="resolve">Resolve</h4>
<p><code>object</code></p>
<p>配置模块如何解析。 Webpack 内置 JavaScript 模块化语法解析功能，默认会采用模块化标准里约定好的规则去寻找，但你也可以根据自己的需要修改默认的规则。</p>
<h5 id="resolvealias">resolve.alias</h5>
<p><code>object</code></p>
<p>创建 import 或 require 的别名，来确保模块引入变得更简单。</p>
<pre><code>alias: {
  Utilities: path.resolve(__dirname, 'src/utilities/'),
  Templates: path.resolve(__dirname, 'src/templates/')
}
</code></pre>
<h5 id="resolveextensions">resolve.extensions</h5>
<p><code>array</code></p>
<p>自动解析的文件的扩展名，这些文件在引入时可不带扩展名</p>
<pre><code>//file.json
extensions: [&quot;.js&quot;, &quot;.json&quot;]
import File from '../path/to/file'
</code></pre>
<h5 id="resolvemainfields">resolve.mainFields</h5>
<p><code>array</code></p>
<p>当从 npm 包中导入模块时,此选项将决定在 package.json 中使用哪个字段导入模块。一些第三方模块会针对不同环境提供几分代码，Webpack 会根据 mainFields 的配置去决定优先采用那份代码。</p>
<h5 id="resolvemodules">resolve.modules</h5>
<p><code>array</code></p>
<p>告诉 webpack 配置 Webpack 去哪些目录下寻找第三方模块，默认为node_modules、</p>
<h4 id="plugins">Plugins</h4>
<p><code>array</code></p>
<p>插件配置，接受一个数组，数组里每一项都是一个要使用的 Plugin 的实例，Plugin 需要的参数通过构造函数传入。</p>
<p>在 Webpack 中接入 Plugin并不复杂，复杂在于每个插件自身提供的配置项。</p>
<pre><code>var webpack = require('webpack');
// 导入非 webpack 默认自带插件
var ExtractTextPlugin = require('extract-text-webpack-plugin');

// 在配置中添加插件
plugins: [
  new ExtractTextPlugin({
    filename: 'build.min.css',
    allChunks: true,
  })
]
</code></pre>
<p>常用插件：<a href="https://doc.webpack-china.org/plugins/">地址</a></p>
<h4 id="devserver">DevServer</h4>
<p>启动一个本地服务器，并支持实时预览，热替换，Source Map</p>
<pre><code>devServer: {
  contentBase: path.join(__dirname, &quot;dist&quot;),
  compress: true,
  port: 9000
}
</code></pre>
<h5 id="devserverhot">devServer.hot</h5>
<p>默认：false；是否启用模块热替换功能（局部更新），关闭则为整个页面刷新。</p>
<h5 id="devserverinline">devServer.inline</h5>
<p>默认：true；是否启用内联模式(inline mode)</p>
<ul>
<li>如果开启 inline，DevServer 会在构建完变化后的代码时通过代理客户端控制网页刷新。</li>
<li>如果关闭 inline，DevServer 将无法直接控制要开发的网页。这时它会通过 iframe 的方式去运行要开发的网页，当构建完变化后的代码时通过刷新 iframe 来实现实时预览。</li>
</ul>
<h5 id="devserverhistoryapifallback">devServer.historyApiFallback</h5>
<p><code>boolean|object</code></p>
<p>使用了 HTML5 History API 的单页应用。 要求服务器在针对任何命中的路由时都返回一个对应的 HTML 文件。</p>
<h5 id="devservercontentbase">devServer.contentBase</h5>
<p><code>boolean|string|array</code><br>
配置 DevServer HTTP 服务器的文件根目录。 默认情况下为当前执行目录，通常是项目根目录。</p>
<h5 id="devserverhost">devServer.host</h5>
<p><code>string</code></p>
<p>配置 DevServer 服务监听的地址。</p>
<h5 id="devservernumber">devServer.number</h5>
<p><code>number</code></p>
<p>配置 DevServer 服务监听的端口号。</p>
<h5 id="devservercompress">devServer.compress</h5>
<p><code>boolean</code></p>
<p>是否启用gzip压缩，默认false</p>
<h5 id="devserveropen">devServer.open</h5>
<p><code>boolean</code></p>
<p>首次构建完成是否打开浏览器</p>
<h4 id="devtool">Devtool</h4>
<p><code>string|false</code></p>
<p>配置webpack如何生成Source Map。</p>
<h4 id="target">Target</h4>
<p><code>string | function(compiler)</code></p>
<p>制定构建环境。默认web</p>
<h4 id="watch-和-watchoptions">Watch 和 WatchOptions</h4>
<p>监听模式及配置</p>
<pre><code class="language-js">module.export = {
  // 只有在开启监听模式时，watchOptions 才有意义
  // 默认为 false，也就是不开启
  watch: true,
  // 监听模式运行时的参数
  // 在开启监听模式时，才有意义
  watchOptions: {
    // 不监听的文件或文件夹，支持正则匹配
    // 默认为空
    ignored: /node_modules/,
    // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高
    // 默认为 300ms
    aggregateTimeout: 300,
    // 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的
    // 默认每秒问 1000 次
    poll: 1000
  }
}
</code></pre>
<h2 id="技巧">技巧</h2>
<ul>
<li>
<p>常用操作配置到npm script</p>
</li>
<li>
<p>想让源文件加入到构建流程中去被 Webpack 控制，配置 entry。</p>
</li>
<li>
<p>想自定义输出文件的位置和名称，配置 output。</p>
</li>
<li>
<p>想自定义寻找依赖模块时的策略，配置 resolve。</p>
</li>
<li>
<p>想自定义解析和转换文件的策略，配置 module，通常是配置 module.rules 里的 Loader。</p>
</li>
<li>
<p>其它的大部分需求可能要通过 Plugin 去实现，配置 plugin。</p>
</li>
</ul>
<h2 id="vue-cli简介">vue-cli简介</h2>
<p>由vue官方提供的一套快速生成项目模板的脚手架，内置了几套模板，可以根据自己需要进行拉取。目的是为了让开发者能够快速进行项目开发，而不用把时间花费在项目构建上。</p>
<pre><code>├── README.md                       // 项目说明文档
├── node_modules                    // 项目依赖包文件夹
├── build                           // 编译配置文件，一般不用管
│   ├── build.js
│   ├── check-versions.js
│   ├── dev-client.js
│   ├── dev-server.js
│   ├── utils.js
│   ├── vue-loader.conf.js
│   ├── webpack.base.conf.js
│   ├── webpack.dev.conf.js
│   └── webpack.prod.conf.js
├── config                          // 项目基本设置文件夹
│   ├── dev.env.js              // 开发配置文件
│   ├── index.js                    // 配置主文件
│   └── prod.env.js             // 编译配置文件
├── index.html                      // 项目入口文件
├── package-lock.json           // npm5 新增文件，优化性能
├── package.json                    // 项目依赖包配置文件
├── src                             // 我们的项目的源码编写文件
│   ├── App.vue                 // APP入口文件
│   ├── assets                      // 初始项目资源目录，会被webpack处理
│   │   └── logo.png
│   ├── components              // 组件目录
│   │   └── Hello.vue           // 测试组件，回头删除
│   ├── main.js                 // 主配置文件
│   └── router                      // 路由配置文件夹
│       └── index.js            // 路由配置文件
└── static                          // 资源放置目录,不会被webpack处理
</code></pre>

							</div>
	<div class="wow fadeInUp vt-post-tags">
 
				<a href="https://www.bwrong.cn/tag/A5uIdrrvT/" rel="tag">node</a>
				 
				<a href="https://www.bwrong.cn/tag/webpack/" rel="tag">webpack</a>
				 
				<a href="https://www.bwrong.cn/tag/工程化/" rel="tag">工程化</a>
				 
				<a href="https://www.bwrong.cn/tag/gulp/" rel="tag">gulp</a>
				 
					</div>
<nav class="navigation3 post-navigation3" role="navigation">

		<div class="nav-links3">
      
		<div class="wow fadeInUp nav-previous3"><a href="https://www.bwrong.cn/post/javascript-yi-bu-bian-cheng/" rel="prev"> JavaScript异步编程</a></div>
		 
		 
		<div class="wow fadeInUp nav-next3"><a href="https://www.bwrong.cn/post/es6/" rel="next"> ES6学习笔记</a></div>
		
		</div>
	</nav>
	<div class="wow fadeInUp author-info">
	<div class="author-avatar pull-left"><img src="https://www.bwrong.cn/images/avatar.png" ></div>
 
	<div class="author-description"><div class="author-title"><div class="author-link" rel="author">BWrong</div></div>


	<p class="author-bio">愿你走出半生，归来仍是少年</p></div></div>
	
		</div>



</article>

<div id="marlin_lite_about_widget-2" class="wow fadeInUp widget marlin_lite_about_widget" data-wow-delay="0.1s">

        
		<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://www.bwrong.cn/media/scripts/Valine.min.js'></script>

<div class="comment"></div>
<script>
        new Valine({
            av: AV,
            el: '.comment',
            lang: 'zh-cn',
            visitor: false, // 阅读量统计
            
            admin_email:'wang11535041@qq.com',
            
            
            emoticon_url: '/media/alu',
             
      emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
     
      app_id: 'jaz3TfUjRowK9fOMAPb9yw6i-MdYXbMMI',
      
      
      app_key: 'pbltxx4rElIP1RStL3AwujSp',
         
          
      placeholder: '欢迎你留下足迹'
       
        });
    </script>





		</div>

			</div>
			


<div class="tocc col l3 hide-on-med-and-down">

        <div class="toc-widget">

            <div class="toc-title"></div>

            <div id="toc-content">


			</div>
        </div>
    </div>


<script src="https://www.bwrong.cn/media/scripts/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '.entry-summary',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1,h2' //**
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('.entry-summary').children('h1, h2').each(function () {/**/
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget').parent();
        // let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>






			</div>
		</div>


		 <footer id="colophon" class="site-footer">

	<div class="container">

		<div class="copyright"> <br>Theme: <a
				href="https://github.com/alterfang/gridea-theme-pan" target="_blank" title="Pan"><span>Pan</span></a>.
			Powered by <a href="https://gridea.dev/" target="_blank" title="Gridea"><span>Gridea</span></a> . 版权所有：<a href="https://beian.miit.gov.cn/" target="_blank"><span>蜀ICP备2023018303号-1</span></a></div>
	</div>

</footer>
		<!-- loding -->
		<div class="loader">
			<div class="loader-content">
				<div class="songjingge">
					<span></span>
					<span></span>
					<span></span>
					<span></span>
					<span></span>
				</div>
			</div>
		</div>
<script id="rendered-js">
	window.onload = function () {
			var loader = document.getElementsByClassName("loader")[0];
			loader.className = "loader fadeout"; //使用渐隐的方法淡出loading page
			setTimeout(function () {
				loader.style.display = "none";
			}, 0);
	};
</script>


</div>

<script src="https://cdn.bootcss.com/fitvids/1.2.0/jquery.fitvids.min.js"></script>
<script type='text/javascript' src='https://www.bwrong.cn/media/scripts/marlin-scripts.js'></script>
<script src="https://www.bwrong.cn/media/scripts/lately.min.js"></script>
<script>jQuery(document).ready(function () { $.lately({ 'target': '.lately-a,.lately-b,.lately-c' }) });</script>
<style type="text/css">
  a.back_to_top {
    text-decoration: none;
    position: fixed;
    bottom: 40px;
    right: 30px;
    background: #f0f0f0;
    height: 40px;
    width: 40px;
    border-radius: 50%;
    line-height: 36px;
    font-size: 18px;
    text-align: center;
    transition-duration: .5s;
    transition-propety: background-color;
    display: none;
  }

  a.back_to_top span {
    color: #888;
  }

  a.back_to_top:hover {
    cursor: pointer;
    background: #dfdfdf;
  }

  a.back_to_top:hover span {
    color: #555;
  }

  @media print,
  screen and (max-width: 580px) {
    .back_to_top {
      display: none !important;
    }
  }
</style><a id="back_to_top" href="#" class="back_to_top"><span><i class="iconfont icon-xiangshang"></i></span>
</a>

<script>
$(document).ready((function (_this) {
    return function () {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function () {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block');
          } else {
            return bt.css('display', 'none');
          }
        });
        return bt.click(function () {
          $('body,html').animate({
            scrollTop: 0
          }, 800);
          return false;
        });
      }
    };
  })(this));
//   $(window).load(function () {
//     //异步延迟加载样式
//     var link = $('<link />');
//     link.attr('href', 'https://fonts.googleapis.com/css?family=Dancing+Script|Noto+Sans+SC:300|Montserrat&display=swap');
//     link.attr('rel', 'stylesheet');
//     link.appendTo($('head'));
// });
</script>

<!-- 宠物 -->
<canvas id="live2dcanvas" width="200" height="400" class="live2d"></canvas>
<style>
  #live2dcanvas {
    position: fixed;
    right: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -40px;
    width: 200px;
    height: 400px;
  }

  @media (max-width: 768px) {
    #live2dcanvas {
      width: 150px;
      height: 300px;
    }
  }

  @media (max-width: 639px) {
    #live2dcanvas {
      display: none !important;
    }
  }
</style>
<script src="https://www.bwrong.cn/media/scripts/L2Dwidget.min.js"></script>
<script>
  //初始化小人物 需设置属性pluginRootPath: "live2dw/"指明资源跟路径
  L2Dwidget.init({
    pluginRootPath: "media/",//资源root路径
    pluginJsPath: "scripts/",//js相对root的路径
    pluginModelPath: "model/",//模型相对root的路径
    tagMode: !1,
    debug: !1,
    model: {
      scale: 2,
      jsonPath: "/media/model/live2d-widget-model-epsilon/Epsilon2.1.model.json"
    },
    display: {//大小位置什么的自己慢慢调就是了
      position: "right",//定位
      width: 130,//宽度
      height: 210,//高度
      hOffset: -40,//左右
      vOffset: 0//上下
    },
    mobile: {
      show: !1
    },
    log: !1
  });
</script>
<!-- 宠物结束 -->

		<script data-no-instant>
    // (function ($) {
    //     $.extend({
    //         adamsOverload: function () {
    //             $('.navigation:eq(0)').remove();
    //             $("").attr("rel" , "external");
    //             $("a[rel='external'],a[rel='external nofollow']").attr("target","_blank");
    //             $("a.vi").attr("rel" , "");
    //             $.viewImage({
    //                 'target'  : 'img',
    //                 'exclude' : '.vsmile-icons img,.gallery img',
    //                 'delay'   : 300
    //             });
    //             $.lately({
    //                 'target' : '.commentmetadata a,.infos time,.post-list time'
	// 			});
	// 			console.log(prettyPrint)
	// 			if(prettyPrint) prettyPrint();

    //             $('ul.links li a').each(function(){
    //                 if($(this).parent().find('.bg').length==0){
    //                     $(this).parent().append('<!---<div class="bg" style="background-image:url(https://c3.glgoo.top/s2/favicons?domain='+$(this).attr("href")+')"></div>--->')
    //                 }
    //             });
    //         }
    //     });
    // })(jQuery);
	// jQuery.adamsOverload();

    (function ($) {
        $.extend({
            adamsOverload: function () {
                $.viewImage({
                    'target'  : '.song img',
                    'exclude' : '.vsmile-icons img',
                    'delay'   : 300
                });
            }
        });
    })(jQuery);
    jQuery.adamsOverload();
</script>

</body>
</html>
