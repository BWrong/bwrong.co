
<!DOCTYPE html>
<html lang="zh-CN">
<head>
 <meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
<meta HTTP-EQUIV="pragma" CONTENT="no-cache">
<meta HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate">
<meta HTTP-EQUIV="expires" CONTENT="0">
<meta name="author" content="bwrong, wang11535041@qq.com"/>
<meta name="keywords" content="【前端工程化】篇三 席卷八荒-Webpack（基础） | BWrong的小站,前端,krpano,js,vue"/>
<meta name="description" content="天青色等烟雨，而我在等你"/>
<!-- <title>【前端工程化】篇三 席卷八荒-Webpack（基础） | BWrong的小站</title> -->
<title>网站搭建测试</title>
<link href="https://www.bwrong.cn/media/css/fz.css" rel="stylesheet">
<link rel="stylesheet" href="https://www.bwrong.cn/styles/main.css">
<script type="text/javascript">
function getCSS()
{
        datetoday = new Date();
        timenow=datetoday.getTime();
        datetoday.setTime(timenow);
        thehour = datetoday.getHours();

        if (thehour<5)

            display = "https://www.bwrong.cn/media/css/night.css";

       else if (thehour>20)

            display = "https://www.bwrong.cn/media/css/night.css";

        else if (thehour>5)
     
            display = "https://www.bwrong.cn/media/css/day.css";

        else if (thehour<20)

            display = "https://www.bwrong.cn/media/css/day.css";


var css = '<';
        css+='link rel="stylesheet" href='+display+' \/';
        css+='>';
        document.write(css);
}
</script>
<link href="https://at.alicdn.com/t/font_1306644_ko4c4at97is.css" rel="stylesheet" />
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://www.bwrong.cn/media/css/katex.min.css">
<script type='text/javascript' src='https://www.bwrong.cn/media/scripts/script.js'></script>
<link href="https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet" />
  <script src="https://cdn.bootcss.com/wow/1.1.2/wow.min.js"></script>
  <script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>wow=new WOW({boxClass:'wow',animateClass:'animated',offset:0,mobile:true,live:true});wow.init();</script>

<script type="text/javascript">
window.onload=getCSS();
</script>
<!-- 百度统计 -->
<script>
var _hmt = _hmt || [];
(function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?2c0e9e3f54ae20480b34c178578c4df8";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
})();
</script>


</head>
<body class="post-template-default single single-post postid-70 single-format-standard">
    <div id="wrapper">

	
<header id="header" class="site-header"
		
		style="background-image: linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2)),url(https://www.bwrong.cn/post-images/dev-tools03.jpg)"
		
		>
			<div class="site-branding">
									<h1 class="site-title"><a href="https://www.bwrong.cn" rel="home">BWrong的小站</a></h1>

					<h2 class="site-description">天青色等烟雨，而我在等你</h2>

							</div>
			<nav id="nav-wrapper">
				<div class="container">
					<div class="nav-toggle">
						<div class="bars">
							<div class="bar"></div>
							<div class="bar"></div>
							<div class="bar"></div>
						</div>
					</div>
					<div class="clear"></div>
					<ul id="" class="dove">
		 

<li>

	
		<a href="/">
		  首页
		</a>
	  

    

<li>

	
		<a href="/archives/index.html">
		  归档
		</a>
	  

    

<li>

	
		<a href="/post/about/">
		  关于
		</a>
	  

    

</ul>
</li>

</ul>				</div>
			</nav>
						<div class="jingge">


    

    

<a  href="https://github.com/BWrong" target="_blank" ><i class="iconfont icon-github"></i></a>
 
    

    

    

    

<a  href="https://juejin.cn/user/3421335914820280" target="_blank" ><i class="iconfont icon-telegram"></i></a>
 
    

    

    

    

    

    
        </header>


		<div id="content" class="container">
			<div class="row">
	<div class="col-md-8 site-main">

<article id="post-70" class="post-70 post type-post status-publish format-standard hentry category-5 tag-10 tag-9 tag-11">



		<div class="entry-content">
			<h1 data-wow-delay="0.4s"  class="wow fadeInUp entry-title">【前端工程化】篇三 席卷八荒-Webpack（基础）</h1>
<div class="entry-meta">
<div class="wow fadeInUp"  data-wow-delay="0.6s">
	<i class="iconfont icon-rili"> <time class="lately-a" datetime="2020-10-19 12:59:42" itemprop="datePublished" pubdate="">2020-10-19</time></i>
	          </div>

</span>

		</div>

			<div class="wow fadeInUp entry-summary song"  data-wow-delay="0.1s">
				<p>字数：8960， 阅读时间：28分钟，点击<a href="https://www.bwrong.cn/post/dev-tools03/">阅读原文</a></p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/letwrong/Picture/raw/master/20201019124627.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>尽前行者地步窄，向后看者眼界宽。      ——《格言联璧·持躬类》</p>
</blockquote>
<p>【前端工程化】系列文章链接：</p>
<ul>
<li><a href="https://www.bwrong.cn/post/dev-tools01/">01 扬帆起航-开发环境</a></li>
<li><a href="https://www.bwrong.cn/post/dev-tools02/">02 白璧微瑕-包管理器</a></li>
</ul>
<p><em>示例代码仓库：<a href="https://github.com/BWrong/dev-tools">https://github.com/BWrong/dev-tools</a></em></p>
<p><em>声明：本篇文章基于webpack v4.43.0，如按照文中代码执行报错，请先检查依赖版本是否和示例代码仓库中一致。</em></p>
<h1 id="前言">前言</h1>
<p>自Web2.0以来，前端技术日益蓬勃发展，前端仔们不再满足于切切页面、写写动画，而是能够做更多&quot;高大上&quot;的事情了。但随着项目规模和复杂度的提升，代码的依赖维护、代码压缩、代码风格审查等与业务无关但又不得不做的事情占据了开发人员越来越多的时间。那时，这些操作均只能依靠开发人员手动来进行处理，耗时耗力，完全是一个刀耕火种的时代（从前车马很慢，一生只够爱一个人😂）。</p>
<p>后来，NodeJS出现了，作为一门服务端语言，它拥有更加强大的能力，尤其是处理文件的能力，运行也不再受限于浏览器沙盒，可以直接在终端命令行运行。这些特性正是开发前端工程化的核心需求，所以有人开始借助NodeJS来做那些耗时耗力的工作，属于前端自己的工程化时代初见端倪。</p>
<p>当然，这里我们的重点是Webpack，所以不会花大量篇幅去讲述前端工程化的发展史，仅仅列出一些比较有代表性的工具，以致敬这些前浪们</p>
<ul>
<li><a href="https://gruntjs.com/">Grunt</a>：基于任务的命令行构建工具，构建工具的先驱。</li>
<li><a href="https://gulpjs.com/">Gulp</a>：管道，流式处理，构建性能比grunt高，配置也比较简单。</li>
<li><a href="http://browserify.org/">Browserify</a>：把Commonjs打包成浏览器支持的包。</li>
<li><a href="https://webpack.js.org/">Webpack</a>：模块打包器，通过loader支持众多文件类型，支持插件，支持按需加载，提取公用代码等，生态完善，目前最流行的打包工具。</li>
<li><a href="http://rollupjs.org/guide/en/">Rollup</a>：侧重于打包库、SDK，输出成果体积较小。</li>
<li><a href="https://en.parceljs.org/">Parcel</a>：打包速度快，入口支持html，打包时会自动安装需要的插件，人家的口号是技术零配置。</li>
<li><a href="https://www.snowpack.dev/">snowpack</a>：打包速度快，无需打包工具。</li>
</ul>
<p>在Webpack刚刚出来的时候，那个时候Gulp和Grunt还风华正茂，在网上经常有人拿它们来做对比，其实他们是不同类型的构建工具，不是太具有可比性。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/letwrong/Picture/raw/master/20200526124825.jpg" alt="" loading="lazy"></figure>
<p>如上图所示，虽说它们都是构建工具，但是Gulp、Grunt更加偏向任务式，所有的操作均需以任务的方式来构建；而Webpack则是模块化的编译方案，它通过依赖分析，进行模块打包，与它对比的应该是Browserify，Rollup之流。</p>
<p>目前来说，grunt和gulp，已经功成身退了，当下webpack无疑是最热门、最强大的打包工具。这都得益于维护团队海纳百川有容乃大的态度，Rollup的tree shaking、Parcel的零配置这些亮点都被webpack吸收了。也许有的人觉得是抄袭，但是咱们读书人的世界何来抄袭呢。更何况不是这样的话，不是得学更多的工具了，又何来我这一头乌黑靓丽的秀发呢？😜😜</p>
<p>好了，啰嗦了半天，该进入主题了，接下来，看看webpack官方的定义：</p>
<p>At its core, <strong>webpack</strong> is a <em>static module bundler</em> for modern JavaScript applications. When webpack processes your application, it internally builds a <a href="https://webpack.js.org/concepts/dependency-graph/">dependency graph</a> which maps every module your project needs and generates one or more <em>bundles</em>.</p>
<p>译：Webpack 是一个现代 JavaScript 应用程序的<em>静态模块打包器</em>（<em>module bundler</em>），当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p>
<p>这里多次提到了模块，模块在前端开发中一般指JavaScript的模块化产物，相关的介绍网上也有很多，实在找不到也可以看看鄙人之前的文章<a href="https://www.bwrong.cn/post/javascript-module/">再谈JavaScript模块化</a>，这里我们不再赘述。但是这里Webpack所指的模块不仅仅是JavaScript中的模块，通过Loader，它可以处理任意类型的资源。广义上来说，在Webpack看来，任意资源都是模块。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/letwrong/Picture/raw/master/20200526223715.png" alt="" loading="lazy"></figure>
<h1 id="安装与配置">安装与配置</h1>
<p>现在Webpack最新的版本是4.43.0（注意现在5.0已发布，默认安装会是5.0），可以安装在全局，也可以安装到项目，这里推荐在项目本地安装。</p>
<pre><code class="language-shell">npm init -y  # 初始化npm配置文件
npm install --save-dev webpack # 安装核心库
npm install --save-dev webpack-cli # 安装命令行工具
</code></pre>
<p><strong>备注：</strong> webpack4.0后，将核心和cli部分拆分开了，所以两个都需要安装，拆分开的好处就是核心部分可以在nodejs的项目中使用，不再受限于命令行环境，更加符合职责单一原则。</p>
<p>受Parcel的“刺激”，Webpack从4.0开始支持零配置，开箱即用，默认会使用<code>/src/index.js</code>作为entry，<code>/dist/main.js</code>作为输出成果。</p>
<p>建立如下文件：</p>
<pre><code>- src
  |- index.js
</code></pre>
<pre><code class="language-js">// index.js
console.log('hello webpack');
</code></pre>
<p>然后执行<code>npx webpack</code>，就可以看到打包结果：</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/letwrong/Picture/raw/master/20200526231221.png" alt="image-20200526231221659" loading="lazy"></figure>
<p>在输出信息中，显示了本次打包的hash值、webpack版本、耗时等，还列出了打包的每个模块信息，包含资源名称、大小、chunk（后面会详解）等信息，另外在src同级目录会生成一个dist目录，下面会有一个<code>main.js</code>，即是打包成果，在<code>index.html</code>中直接引入该文件就可以了。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/letwrong/Picture/raw/master/20200526232924.png" alt="" loading="lazy"></figure>
<p>上面，其实我们已经成功完成了一个文件的打包，是不是很简单。不过仔细看看命令行输出的信息中，后面是有一大段警告的，作为一个有追求的程序猿，怎么可能让这种事情发生呢！究其原因，其实在<code>webpack4.0</code>中，建议在打包的时候传入mode，来告知其打包的目标环境是开发环境还是生产环境（不设置默认为production），以便它内部来做相应的优化，可以通过<code>--mode</code>参数来指定模式，如<code>npx webpack --mode=production</code>，这样就不会有警告了。</p>
<p>我们可以试试将mode设置为development后再打包一次，看看成果有什么不同（答案：development下代码未进行压缩）。</p>
<p>当然，也可以在命令行中配置参数来改变Webpack的打包设置，具体的用法可以查看<a href="https://webpack.js.org/api/cli/">Command Line Interface</a>，常用的配置都可以通过命令行来配置，例如默认webpack会查找项目根目录下的<code>webpack.config.js</code>，我们可以通过<code>webpack --config ./build/webpack.config.js</code>来指定配置文件，在日常的开发中，一般都是通过配置文件来使用的，可以实现更加复杂的设置，而且更加方便。</p>
<h1 id="核心概念">核心概念</h1>
<p>在开始前，有必要了解几个核心概念：</p>
<ul>
<li>chunk：指代码块，一个 chunk 可能由多个模块组合而成，也用于代码合并与分割。</li>
<li>bundle：资源经过Webpack 流程解析编译后最终结输出的成果文件。</li>
<li>entry：顾名思义，就是入口起点，用来告诉webpack用哪个文件作为构建依赖图的起点。webpack会根据entry递归的去寻找依赖，每个依赖都将被它处理，最后输出到打包成果中。</li>
<li>output：output配置描述了webpack打包的输出配置，包含输出文件的命名、位置等信息。</li>
<li>loader：默认情况下，webpack仅支持<code>.js</code>文件，通过loader，可以让它解析其他类型的文件，充当翻译官的角色。理论上只要有相应的loader，就可以处理任何类型的文件。</li>
<li>plugin：loader主要的职责是让webpack认识更多的文件类型，而plugin的职责则是让其可以控制构建流程，从而执行一些特殊的任务。插件的功能非常强大，可以完成各种各样的任务。</li>
<li>mode：4.0开始，webpack支持零配置，旨在为开发人员减少上手难度，同时加入了mode的概念，用于指定打包的目标环境，以便在打包的过程中启用webpack针对不同的环境下内置的优化。</li>
</ul>
<p>webpack的配置较多，接下来，仅对常用配置做一些了解，完整的配置可以查阅<a href="https://webpack.js.org/configuration/#options">webpack-options</a>。</p>
<p>**说明：**接下来的内容，使用的命令均使用前面一篇介绍的<code>npm script</code>来定义，而不必再每次都输入npx。</p>
<h1 id="核心配置">核心配置</h1>
<h2 id="mode">mode</h2>
<p>指定打包的模式和环境，取值为<code>development</code>, <code>production</code> 或 <code>none</code> 之中的一个，可以启用 webpack 内置在相应环境下的优化。其默认值为 <code>production</code>。</p>
<pre><code class="language-js">module.exports = {
  mode: 'production'
};
</code></pre>
<p>或者通过命令行配置：</p>
<pre><code class="language-shell">webpack --mode=production
</code></pre>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>development</td>
<td>会将 <code>DefinePlugin</code> 中 <code>process.env.NODE_ENV</code> 的值设置为 <code>development</code>。启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code>。</td>
</tr>
<tr>
<td>production</td>
<td>会将 <code>DefinePlugin</code> 中 <code>process.env.NODE_ENV</code> 的值设置为 <code>production</code>。启用 <code>FlagDependencyUsagePlugin</code>（添加依赖标识）, <code>FlagIncludedChunksPlugin</code>（给chunk添加id）, <code>ModuleConcatenationPlugin</code>（处理模块作用域）, <code>NoEmitOnErrorsPlugin</code>（避免生成异常的代码）, <code>OccurrenceOrderPlugin</code>（按次数进行模块排序）, <code>SideEffectsFlagPlugin</code>（处理<code>Side Effects</code>模块标识） 和 <code>TerserPlugin</code>（js压缩）。</td>
</tr>
<tr>
<td>none</td>
<td>不使用任何默认优化选项</td>
</tr>
</tbody>
</table>
<p>**提示：**关于各选项webpack内部默认的具体配置，可以查看<a href="https://webpack.js.org/configuration/mode/#mode-development">该文档</a>。</p>
<h2 id="context">context</h2>
<p>用于指定基础目录，用于从配置中解析入口起点和loader，须为绝对路径，默认为启动webpack的工作目录。</p>
<pre><code class="language-js">module.exports = {
  context: path.resolve(__dirname, 'app')
};
</code></pre>
<h2 id="entry">entry</h2>
<p>打包的入口文件，一般为应用的入口，方便webpack查找并构建依赖图。</p>
<pre><code class="language-json">module.exports = {
    entry: &quot;./app/entry&quot;, // 如果仅有一个入口，可以简写为此方式，为entry:{main:&quot;./app/entry&quot;}的简写
    entry: [&quot;./app/entry1&quot;, &quot;./app/entry2&quot;], // 为entry:{main:[&quot;./app/entry1&quot;, &quot;./app/entry2&quot;]}的简写
    entry: { // 多入口的方式，每项即为一个chunk，key为chunkName
        a: &quot;./app/entry-a&quot;,
        b: [&quot;./app/entry-b1&quot;, &quot;./app/entry-b2&quot;]
    }
}
</code></pre>
<h2 id="output">output</h2>
<p>描述了webpack如何输出，值为一组选项，包含了输出文件名字、位置等信息。</p>
<pre><code class="language-js">module.exports = {
  output: {
    filename: '[name]_[chunkhash:8].bundle.js',
   	path: path.resolve(__dirname, 'dist')
  }
};
</code></pre>
<ul>
<li><code>output.filename</code>：配置输出文件的名字，对于单入口的情况，需要设定为一个指定的名称，对于多入口的情况，可以使用占位符模板来指定。</li>
</ul>
<table>
<thead>
<tr>
<th>模板</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[hash]</td>
<td>模块标识符(module identifier)的 hash</td>
</tr>
<tr>
<td>[chunkhash]</td>
<td>chunk 内容的 hash</td>
</tr>
<tr>
<td>[name]</td>
<td>模块名称</td>
</tr>
<tr>
<td>[id]</td>
<td>模块标识符(module identifier)</td>
</tr>
<tr>
<td>[query]</td>
<td>模块的 query，例如，文件名 <code>?</code> 后面的字符串</td>
</tr>
<tr>
<td>[function]</td>
<td>可以使用函数动态返回filename</td>
</tr>
</tbody>
</table>
<p><code>[hash]</code> 和 <code>[chunkhash]</code> 的长度可以使用 <code>[hash:16]</code>（默认为20）来指定。或者，通过指定<a href="https://webpack.docschina.org/configuration/output/#output-hashdigestlength"><code>output.hashDigestLength</code></a> 在全局配置长度。</p>
<ul>
<li><code>output.path</code>：配置输出目录，值为绝对路径。</li>
<li><code>output.publicPath</code>：如果需要引用外部资源，可以通过此配置设置资源的地址，例如部署要将资源上传到CDN服务器，就需要填上CDN的地址。</li>
</ul>
<p>如果打包一个类库或者sdk，可能还需要设置<code>library</code>、<code>libraryExport</code>、<code>libraryTarget</code>、<code>umdNamedDefine</code>等选项来配置类库暴露的名字及兼容的模块规范等，可查看<a href="https://webpack.js.org/guides/author-libraries/">官方指南</a>。</p>
<h2 id="loader">loader</h2>
<p>loader 用于对模块的源代码进行转换，在 <code>import</code> 或&quot;加载&quot;模块时解析文件，通过添加loader可以让webpack处理多种类型的文件。</p>
<pre><code class="language-js">module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
       	use: [
          { loader: 'style-loader' },
          {
            loader: 'css-loader',
            include: './src/assets', // 指定查找的目录，resource.include的简写
            // exclude:'', // 指定排除的目录，resource.exclude的简写
            options: {
              modules: true
            }
          }
        ]
      },
      { test: /\.ts$/, use: 'ts-loader' }
    ]
  }
};
</code></pre>
<p>loader可以在配置文件的<code>module.rules</code>属性中设置，可以配置多个规则，每个规则通过test属性设置匹配的文件类型，在use属性中指定对应的loader及其对应的配置(options)。</p>
<p>对于匹配条件，webpack提供了多种配置形式：</p>
<blockquote>
<ul>
<li><code>{ test: ... }</code> 匹配特定条件</li>
<li><code>{ include: ... }</code> 匹配特定路径</li>
<li><code>{ exclude: ... }</code> 排除特定路径</li>
<li><code>{ and: [...] }</code>必须匹配数组中所有条件</li>
<li><code>{ or: [...] }</code> 匹配数组中任意一个条件</li>
<li><code>{ not: [...] }</code> 排除匹配数组中所有条件</li>
</ul>
</blockquote>
<p>**注意：**同一个规则可以指定多个loader，<strong>从右到左</strong>链式传递，依次对文件进行处理，当然可以通过<code>enforce</code>（可取值为<code>pre</code> | <code>post</code>，分别为前置和后置）强制改变执行顺序。</p>
<p>通过loader我们可以在js文件中导入css、img等文件，理论上可以实现解析各类文件，常用的loader可以在<a href="https://webpack.js.org/loaders/">官网-Loaders</a>中查询。</p>
<h2 id="plugin">plugin</h2>
<p>插件的目的在于解决 <a href="https://webpack.docschina.org/concepts/loaders">loader</a> 无法实现的其他事。插件的本质其实是一个具有<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>apply</code></a> 方法的 JavaScript 对象，该方法会被<code>webpack compiler</code> 调用，并且 compiler 对象可在<strong>整个</strong>编译生命周期访问，用于自定义构建过程。</p>
<p>在配置文件的plugins属性中传入插件实例来使用插件：</p>
<pre><code class="language-js">plugins: [
    new webpack.DefinePlugin({ // 内置的插件(DefinePlugin 允许创建可在编译时配置的全局常量)
      // Definitions...
    })
    new HtmlWebpackPlugin({template: './src/index.html'}) // 第三方插件，需要安装
]
</code></pre>
<p>使用 Plugin 的难点在于掌握 Plugin 本身提供的配置项，而不是在 Webpack 中使用 Plugin。webpack拥有相当多的插件，常用的插件都可以在<a href="https://webpack.js.org/plugins/">官方文档-plugins</a>上查找到，文档中也有相关配置的说明和案例，也算比较友好了。</p>
<h1 id="其他常用配置">其他常用配置</h1>
<h2 id="resolve">resolve</h2>
<p>resolve用于配置模块解析规则，可以通过此配置更改webpack默认的解析规则。</p>
<p>webpack的模块路径解析规则和<a href="http://www.infoq.com/cn/articles/nodejs-module-mechanism">Node.js 的模块机制</a>一样。</p>
<blockquote>
<ul>
<li>如果是相对路径
<ol>
<li>查找当前模块的目录下是否有对应文件/夹</li>
<li>如果是文件则直接加载</li>
<li>如果是文件夹，则继续查找文件夹下的 package.json 文件</li>
<li>如果有 package.json 文件，则按照其中 <code>main</code> 属性声明得到的文件名来查找文件</li>
<li>如果无 package.json 或者无 <code>main</code> 属性，则查找 <code>index.js</code> 文件</li>
</ol>
</li>
<li>如果直接是模块名<br>
会依次查找当前目录下、父目录、父父目录、... 一直到根目录，直到找到目录下的 <code>node_modules</code> 文件夹，查找是否有对应的模块</li>
<li>如果是绝对路径<br>
直接查找此路径对应的文件</li>
</ul>
</blockquote>
<ul>
<li><code>resolve.alias</code>：用于定义一些路径简写占位符，也有人称之为路径别名映射，目的是简化模块导入时的路径。</li>
</ul>
<pre><code class="language-js">module.exports = {
  resolve: {
    alias: {
      @: path.resolve(__dirname, 'src/') //这里就将@映射到了/src/目录了，在使用时用@就行
    }
  }
};
</code></pre>
<ul>
<li><code>resolve.extensions</code>：解析文件时，缺省文件扩展名时，尝试自动补全的扩展名集，尝试的顺序从前到后，一般将高频使用的扩展名放在前面，优先匹配。</li>
</ul>
<pre><code class="language-js">module.exports = {
  resolve: {
    extensions: ['.wasm', '.mjs', '.js', '.json']
  }
};
</code></pre>
<ul>
<li><code>resolve.enforceExtension</code>：如果是 <code>true</code>，将不允许加载无扩展名(extension-less)文件，也即是不会自动进行扩展名补全。</li>
<li><code>resolve.modules</code>：webpack 解析模块时应该搜索的目录，默认为<code>node_modules</code>，如果项目中某个文件夹频繁使用，就可以添加进此配置，引入文件时路径就可以省略该目录。</li>
</ul>
<pre><code class="language-js">module.exports = {
  resolve: {
    modules: ['node_modules']
  }
};
</code></pre>
<h2 id="optimization">optimization</h2>
<p>webpack4.0将一些优化的配置都放在了该属性下，根据mode来进行不同的优化，也可以进行手动配置和重写。</p>
<ul>
<li><code>optimization.minimize</code>：是否使用 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/">TerserPlugin</a> 压缩代码，<code>production</code> 模式下，默认是 <code>true</code>。</li>
</ul>
<pre><code class="language-js">module.exports = {
  optimization: {
    minimize: false
  }
};
</code></pre>
<ul>
<li><code>optimization.minimizer</code>：允许通过提供一个或多个定制过的 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/">TerserPlugin</a> 实例，覆盖默认压缩工具(minimizer)。</li>
</ul>
<pre><code class="language-js">module.exports = {
  optimization: {
    minimizer: [
      new TerserPlugin({
        cache: true,
        parallel: true,
        sourceMap: true, // Must be set to true if using source-maps in production
        terserOptions: {
          // https://github.com/webpack-contrib/terser-webpack-plugin#terseroptions
          compress:{
            drop_console: true, // 去除consle
            drop_debugger: true  // 去除debugger
          }
        }
      }),
    ],
  }
};
</code></pre>
<h2 id="devserver">devServer</h2>
<p>在项目开发时，如果不能实时看到开发的预览效果，是不是心里没底？所以我们需要一个工具，来启动一个server，让我们在开发的时候可以实时预览，<code>webpack-dev-server</code>就是这样一个工具，它会基于<code>express</code>启动一个server，提供一些好用的功能：</p>
<blockquote>
<ul>
<li>自动打开浏览器</li>
<li>文件监听</li>
<li>自动刷新与模块热替换</li>
<li>跨域代理</li>
</ul>
</blockquote>
<p>这是一个非常实用的工具，用了就会上瘾系列。<code>webpack-dev-server</code>并没有被webpack内置，需要我们自行安装(<code>npm i -D webpack-dev-server</code>)，它所有的配置都在配置文件的devServer属性中。</p>
<ul>
<li>
<p><code>devServer.before</code>,<code>devServer.after</code>：其实相当于devServer的中间件，提供执行自定义处理程序的功能，本质是一个函数，接收devServer实例作为参数。</p>
<p>例如，可以在before中我们可以来启动一个server用来做数据mock。</p>
</li>
</ul>
<pre><code class="language-javascript">// webpack.config.js
module.exports = {
  devServer: {
    before: function(app, server) {
      app.get('/some/path', function(req, res) {
        res.json({ custom: 'response' });
      });
    }
  }
};
</code></pre>
<ul>
<li><code>devServer.host</code>，<code>devServer.port</code>：分别用来配置启动server的主机地址和端口。</li>
</ul>
<pre><code class="language-javascript">module.exports = {
  //...
  devServer: {
    host: '0.0.0.0',
    port: 8080
  }
};
</code></pre>
<ul>
<li><code>devServer.hot</code>：开启模块热替换HMR（Hot Module Replacement）功能，开启后它会尽量采取不刷新整个页面的方式来局部热更新页面。</li>
</ul>
<p>**注意：**必须有 <a href="https://webpack.docschina.org/plugins/hot-module-replacement-plugin/"><code>webpack.HotModuleReplacementPlugin</code></a> 才能完全启用 HMR。如果<code>webpack-dev-server</code> 是通过 <code>webpack-dev-server --hot</code>选项启动的，那么这个插件会被自动添加，否则需要把它手动添加到 <code>webpack.config.js</code>的plugins 中。</p>
<pre><code class="language-js">module.exports = {
    //...
    devServer: {
        hot: true, // 开启模块热替换
        // ...
    },
    plugins: [
        new webpack.HotModuleReplacementPlugin() // 需要添加模块热替换插件，如果启动带上了--hot参数则不需要手动添加此插件
    ]
}
</code></pre>
<p>开启热替换后，需要编写控制代码来响应更新时的操作：</p>
<pre><code class="language-js">if (module.hot) { // 先判断是否开启热替换
  module.hot.accept('./library.js', function() { // library.js更新将会触发此处的回调函数
    // 使用更新过的 library 模块执行某些操作...
  });
}
</code></pre>
<p>看起来，自己来写这些控制代码还是比较麻烦，不过幸运的是，很多loader（如style-loader、vue-loader）内部都实现了热替换，而不用我们自己编写。</p>
<ul>
<li>
<p><code>devServer.inline</code>：推荐设置为true，实时预览重载的脚本将以内联模式插入到包中，设置为false将使用iframe模式，采用轮询的方式执行实时重载。</p>
</li>
<li>
<p><code>devServer.open</code>：配置是否自动打开浏览器。</p>
</li>
<li>
<p><code>devServer.overlay</code>：当出现编译器错误或警告时，在浏览器中显示覆盖层提示，默认false。</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/letwrong/Picture/raw/master/20200529105704.png" alt="image-20200529105657275" loading="lazy"></figure>
</li>
<li>
<p><code>devServer.proxy</code>：在前后端接口联调的过程中，跨域是一个非常常见的问题，要是后端大哥装大爷的话，那工作就很难做下去了。跨域究其原因是受浏览器的同源策略限制，而服务端则不会有此限制。所以我们可以通过<code>nodeServer</code>将后端的接口服务代理到本地，在请求的时候直接访问本地<code>nodeServer</code>地址，然后<code>nodeServer</code>再将请求转发到目标服务端，拿到结果后返回给本地的请求。</p>
</li>
</ul>
<p>proxy就是用来做这个事情的，它是基于强大的<a href="https://github.com/chimurai/http-proxy-middleware">http-proxy-middleware</a>来实现的，配置也是相同的。</p>
<pre><code class="language-js">module.exports = {
  //...
  devServer: {
    proxy: {
      '/api': {
        target: 'http://your-host.com', // 代理的目标地址，/api的请求都会被代理到http://your-host.com/api
        secure: false, // 如果使用了HTTPS，需要关闭此配置
        pathRewrite: {
          '^/api': '' // 重写,目标地址中是否包含/api, 如此设置/api的请求都会被代理到http://your-host.com
        },
        bypass: function(req, res, proxyOptions) { // 如果想自己控制代理，可以使用此配置来绕过代理
          if (req.headers.accept.indexOf('html') !== -1) {
            console.log('Skipping proxy for browser request.');
            return '/index.html';
          }
        }
      }
    }
  }
};

</code></pre>
<ul>
<li><code>devServer.publicPath</code>：资源的访问路径。</li>
</ul>
<pre><code class="language-js">module.exports = {
  //...
  devServer: {
    publicPath: '/assets/' // 可以通过http://localhost:8080/assets/*访问到assets目录下的资源
  }
};
</code></pre>
<h2 id="devtool">devtool</h2>
<p>此选项控制是否生成以及如何生成 source map，不同的值会明显影响到构建(build)和重新构建(rebuild)的速度。</p>
<table>
<thead>
<tr>
<th>devtool</th>
<th>构建速度</th>
<th>重新构建速度</th>
<th>生产环境</th>
<th>品质(quality)</th>
</tr>
</thead>
<tbody>
<tr>
<td>(none)</td>
<td>+++</td>
<td>+++</td>
<td>yes</td>
<td>打包后的代码</td>
</tr>
<tr>
<td>eval</td>
<td>+++</td>
<td>+++</td>
<td>no</td>
<td>生成后的代码</td>
</tr>
<tr>
<td>cheap-eval-source-map</td>
<td>+</td>
<td>++</td>
<td>no</td>
<td>转换过的代码（仅限行）</td>
</tr>
<tr>
<td>cheap-module-eval-source-map</td>
<td>o</td>
<td>++</td>
<td>no</td>
<td>原始源代码（仅限行）</td>
</tr>
<tr>
<td>eval-source-map</td>
<td>--</td>
<td>+</td>
<td>no</td>
<td>原始源代码</td>
</tr>
<tr>
<td>cheap-source-map</td>
<td>+</td>
<td>o</td>
<td>yes</td>
<td>转换过的代码（仅限行）</td>
</tr>
<tr>
<td>cheap-module-source-map</td>
<td>o</td>
<td>-</td>
<td>yes</td>
<td>原始源代码（仅限行）</td>
</tr>
<tr>
<td>inline-cheap-source-map</td>
<td>+</td>
<td>o</td>
<td>no</td>
<td>转换过的代码（仅限行）</td>
</tr>
<tr>
<td>inline-cheap-module-source-map</td>
<td>o</td>
<td>-</td>
<td>no</td>
<td>原始源代码（仅限行）</td>
</tr>
<tr>
<td>source-map</td>
<td>--</td>
<td>--</td>
<td>yes</td>
<td>原始源代码</td>
</tr>
<tr>
<td>inline-source-map</td>
<td>--</td>
<td>--</td>
<td>no</td>
<td>原始源代码</td>
</tr>
<tr>
<td>hidden-source-map</td>
<td>--</td>
<td>--</td>
<td>yes</td>
<td>原始源代码</td>
</tr>
<tr>
<td>nosources-source-map</td>
<td>--</td>
<td>--</td>
<td>yes</td>
<td>无源代码内容</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>+++</code> 非常快速, <code>++</code> 快速, <code>+</code> 比较快, <code>o</code> 中等, <code>-</code> 比较慢, <code>--</code> 慢</p>
</blockquote>
<p>一般在<strong>生产环境推荐使用<code>none</code>（不生成）或者<code>source-map</code>（生成单独的一个文件）选项</strong>，而在开发环境可以从<code>eval</code>、<code>eval-source-map</code>、<code>cheap-eval-source-map</code>、<code>cheap-module-eval-source-map</code>中选择一个。</p>
<p><em>webpack 仓库中包含一个</em> <a href="https://github.com/webpack/webpack/tree/master/examples/source-map">显示所有 <code>devtool</code> 变体效果的示例</a>*。这些例子或许会有助于你理解这些差异之处。*看似值比较多，只要在对应的环境中根据需求（平衡构建速度和打包成果品质）配置合适的值就好。</p>
<h2 id="externals">externals</h2>
<p>用来排除特定的依赖，排除的依赖将不会打包进成果中，而是在程序运行时再去外部获取。</p>
<p>例如，在开发一个<strong>library</strong> 的时候，如果有依赖其他的库，在打包库的时候就需要排除依赖的库，而不应该把依赖的库打包到我们的<strong>library</strong>里面。</p>
<p>另外，在日常的开发中，也可以利用此配置来实现资源以CDN方式引入：</p>
<pre><code class="language-html">&lt;!-- index.html --&gt;
&lt;script
  src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;
  integrity=&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;
  crossorigin=&quot;anonymous&quot;&gt;
&lt;/script&gt;
</code></pre>
<pre><code class="language-javascript">// webpack.config.js
module.exports = {
  //...
  externals: {
    jquery: 'jQuery'
  }
};
</code></pre>
<pre><code class="language-javascript">// src/index.js
import $ from 'jquery'; // 此处的导入可以正常运行，但是打包的时候不会包含，运行的时候会去检索jquery全局变量
$('.my-element').animate(/* ... */);
</code></pre>
<h2 id="cache">cache</h2>
<p>配置是否缓存生成的 webpack 模块和 chunk，可以用来改善构建速度。</p>
<p>上面就是一些常用的配置，掌握了这些，就可以在项目中自己来配置一套打包流程了。</p>
<h1 id="实践一下">实践一下</h1>
<h2 id="1-目录规划">1. 目录规划</h2>
<p>整个项目的目录结构，我们做如下规划：</p>
<pre><code class="language-js">- build                           // webpack配置文件目录
   |- webpack.base.conf.js
   |- webpack.dev.conf.js
   |- webpack.prod.conf.js
- dist							// 打包输出目录
- public						// 放置不需要处理的静态文件和HTML模板
   |- js
   |- index.html
- src							// 项目核心代码，与业务相关的都可以放在此处
   |- assets
   |- index.js					// 入口entry
   |- ...

</code></pre>
<p>用过vuecli2.0的同学应该会很熟悉这个结构。</p>
<h2 id="2-基础配置">2. 基础配置</h2>
<p>虽然，webpack默认提供了两种Mode及内置了相应的优化，能够满足一些简单项目，但是一些复杂的项目远远不止这两套环境（还有测试、预发布等环境），每个环境中的配置也有着巨大差异，遵循逻辑分离原则，此时可以根据环境将配置文件拆分为独立的文件。</p>
<p>下面以只考虑两种环境为例：</p>
<table>
<thead>
<tr>
<th>实现功能</th>
<th>开发环境（速度优先）</th>
<th>生成环境（性能优先）</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码压缩</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>图片压缩</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>css文件抽离</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>模块热替换</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>devserver、proxy</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>source-map</td>
<td><code>eval-cheap-source-map</code></td>
<td>none或者source-map</td>
</tr>
</tbody>
</table>
<p>除了上述罗列内容，实际情况可能还有更多的差异性，总的来看，一般就是开发环境更加侧重构建速度，生产环境更加侧重代码的执行性能。</p>
<p>我们可以将配置拆分成三个文件：</p>
<ul>
<li><code>webpack.base.conf.js</code>：开发环境和生产环境公用的配置，最终使用 <a href="https://github.com/survivejs/webpack-merge"><code>webpack-merge</code></a>合并到dev和prod两个配置中。</li>
</ul>
<pre><code class="language-js">// build/webpack.base.conf.js
const path = require('path');
const {CleanWebpackPlugin} = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
   entry: '../src/index.js',
   output: {
     filename: '[name].[hash:8].js',
     path: path.resolve(__dirname, '../dist')
   },
   plugins: [
     new CleanWebpackPlugin(), //打包前清空输出目录
     new HtmlWebpackPlugin({
       	title: 'webpack',
      	template: './public/index.html',
      	filename: 'index.html'
     })
   ]
};
</code></pre>
<ul>
<li><code>webpack.dev.conf.js</code>：开发环境特有的配置，一些辅助开发的配置都放到此文件。</li>
</ul>
<pre><code class="language-js">// build/webpack.dev.conf.js
const {merge} = require('webpack-merge');
const baseConfig = require('./webpack.base.conf.js');

module.exports = merge(baseConfig, {
   mode: 'development',
   devtool: 'inline-source-map',
   devServer: {
    contentBase: '../dist',
    hot: true,
    // ...
   },
   // ..
});
</code></pre>
<ul>
<li><code>webpack.prod.conf.js</code>：生产环境特有的配置，一些针对输出文件体积质量优化的都放到此文件。</li>
</ul>
<pre><code class="language-js">// build/webpack.prod.conf.js
const {merge} = require('webpack-merge');
const baseConfig = require('./webpack.base.conf.js');

 module.exports = merge(baseConfig, {
   mode: 'production',
   // ...
 });
</code></pre>
<p>然后在<code>npm script</code>中配置对应的命令，来指定不同的配置文件：</p>
<pre><code class="language-json">// package.json
&quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack-dev-server --config ./build/webpack.dev.conf.js&quot;,
    &quot;build&quot;: &quot;webpack --config ./build/webpack.prod.conf.js&quot;
 }
</code></pre>
<h2 id="3-功能完善">3. 功能完善</h2>
<h3 id="使用html模板">使用HTML模板</h3>
<p>前端项目一般都会有一个入口（index.html），需要在此文件中引入打包后的资源，但是每次打包后手动将资源引入太费事，特别是输出文件的名字使用了占位符时（每次打包输出文件的名称都会不一样），简直就是搞事情嘛。此时，我们就可以通过 <a href="https://doc.webpack-china.org/plugins/html-webpack-plugin/">html-webpack-plugin</a>来自动引入打包后的资源。</p>
<pre><code class="language-shell">npm install html-webpack-plugin -D
</code></pre>
<pre><code class="language-js">// build/webpack.base.conf.js
const HtmlWebpackPlugin = require('html-webpack-plugin')
module.exports = {
  // ...
  plugins: [
    new HtmlWebpackPlugin({
        title:'应用名称',
    		template: './public/index.html', // 配置使用的文件模板，如果不配置，将会使用默认的内置模板
        ... // 其他配置按需食用
    }),
  ],
}
</code></pre>
<p>**注意：**如果需要打包多页应用，仅需实例化多个<code>html-webpack-plugin</code>，在每个实例中配置相应的chunk即可。</p>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
    entry:{
      app1:'../src/app1.js',
      app2:'../src/app2.js'
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './public/app1.html', // 模板
            filename: 'app1.html', // 打包输出文件名
            chunks: ['app1'] // 对应的chunk，和entry中定义的chunk对应
        }),
        new HtmlWebpackPlugin({
            template: './public/app2.html', // 模板
            filename: 'app2.html', // 打包输出文件名
            chunks: ['app2'] // 对应的chunk，和entry中定义的chunk对应
        }),
    ]
}
</code></pre>
<h3 id="自动清理输出文件">自动清理输出文件</h3>
<p>由于使用了占位符，每次输出的文件可能不一样，那么就需要在每次打包前清除一下上次输出的文件，<a href="https://github.com/johnagan/clean-webpack-plugin">clean-webpack-plugin</a>就可以帮我们自动完成这件事。</p>
<pre><code class="language-shell">npm install clean-webpack-plugin -D
</code></pre>
<pre><code class="language-js">// build/webpack.base.conf.js
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
module.exports = {
    plugins: [
        new CleanWebpackPlugin() // 会自动清除输出文件夹
    ]
}
</code></pre>
<h3 id="静态资源拷贝">静态资源拷贝</h3>
<p>有些资源是不需要webpack来进行编译的，如VueCli4.0中public中的资源文件，只需要将其拷贝到目标文件就可以了。<a href="https://webpack.js.org/plugins/copy-webpack-plugin/">CopyWebpackPlugin</a>可以把指定文件或目录拷贝到构建的输出目录中。</p>
<pre><code class="language-shell">npm install copy-webpack-plugin -D
</code></pre>
<pre><code class="language-js">// build/webpack.base.conf.js
const CopyWebpackPlugin = require('copy-webpack-plugin');

module.exports = {
    plugins: [
        new CopyWebpackPlugin({
          patterns: [
            // 将public/static/下的所有文件拷贝到dist/static目录中
            {
              from: './public/static/*',
              to: 'static',
              flatten: true  // 拷贝是否不带路径，为true只会拷贝文件，而不会携带文件路径
            },
            // ... 多个需要拷贝的文件/夹在此继续添加
          ]
        })
    ]
}
</code></pre>
<h3 id="使用es-next语法">使用ES Next语法</h3>
<p>ES规范越来越完善，ES6给我们带来了很多实用的新特性，能够大大提升开发体验，但浏览器的支持总是那么不尽人意。而Babel的出现，让我们可以在开发环境使用更时髦的语法（jsx也是可以的），然后生产环境将代码转换成浏览器支持的语法。关于Babel的具体介绍会放在后续内容中，这里不再赘述。</p>
<pre><code class="language-shell">npm install babel-loader -D
npm install @babel/core @babel/preset-env @babel/plugin-transform-runtime -D
npm install @babel/runtime @babel/runtime-corejs3
</code></pre>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
    module: {
        rules: [
            {
                test: /\.jsx?$/,
                use: ['babel-loader'],
                exclude: /node_modules/ //排除 node_modules 目录
            }
        ]
    }
}
</code></pre>
<p>在根目录创建一个babel配置文件<code>babel.config.js</code>。</p>
<pre><code class="language-json"> // babel.config.js
module.exports = {
    &quot;presets&quot;: [&quot;@babel/preset-env&quot;],
    &quot;plugins&quot;: [
        [
            &quot;@babel/plugin-transform-runtime&quot;,
            {
                &quot;corejs&quot;: 3
            }
        ]
    ]
}
</code></pre>
<h3 id="注入全局变量">注入全局变量</h3>
<p>在使用一些框架的时候，需要在很多文件都引入一下，比如在使用React的时候，需要在每个文件都引入一下，否则会报错。这时，如果想偷个懒，利用ProvidePlugin来自动注入也是可以的。</p>
<pre><code class="language-js">// build/webpack.base.conf.js
const webpack = require('webpack');

module.exports = {
    plugins: [
        new webpack.ProvidePlugin({
            React: 'react',
            Component: ['react', 'Component']
        })
    ]
}
</code></pre>
<p>如此，在写React组件时，就不再需要<code>import</code> <code>react</code>和<code>component</code>了。</p>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li>这玩意虽好，可千万不要贪杯哟，过多的全局变量会出事的。</li>
<li>在开启ESLint时，还需要在<code>global</code>中做对应配置，否则会报错提示对应模块未定义。</li>
</ul>
</blockquote>
<h3 id="样式类文件处理">样式类文件处理</h3>
<p>样式类文件处理主要包含样式文件引入、浏览器兼容性语法的自动补全及预处理器编译三部分内容。</p>
<h4 id="css解析和引入">css解析和引入</h4>
<p>如果仅使用css来做为样式文件的话，配置相对比较简单，只需要借助<code>css-loader</code>让webpack可以解析css文件即可。</p>
<pre><code class="language-shell">npm install css-loader -D
</code></pre>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
    //...
    module: {
        rules: [
            {
                test: /\.css$/,
                use: 'css-loader',
                exclude: /node_modules/
            }
        ]
    }
}
</code></pre>
<p>现在，webpack可以打包css文件了，但是样式并不会生效，因为它们根本没有插入到页面中，需要借助<code>style-loader</code>来做样式引入，它会在head中动态创建 <code>style</code> 标签，并将 <code>css</code> 插入到其中。</p>
<pre><code class="language-shell">npm install style-loader -D
</code></pre>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
    //...
    module: {
        rules: [
            {
                test: /\.css$/,
                use: ['style-loader', 'css-loader'], // 注意顺序，从后到前
                exclude: /node_modules/
            }
        ]
    }
}
</code></pre>
<h4 id="自动补全兼容性前缀">自动补全兼容性前缀</h4>
<p>由于现在浏览器对某些css特性支持还不够完善，在使用这些新特性的时候，往往需要加上一些浏览器特定的前缀，也是一个比较麻烦的事情，这时候就轮到postcss上场了。</p>
<pre><code class="language-shell">npm install postcss-loader postcss autoprefixer -D
</code></pre>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
    //...
    module: {
        rules: [
            {
                test: /\.css$/,
                use: ['style-loader', 'css-loader', {
                    loader: 'postcss-loader',
                    options: {
                        plugins: function () {
                            return [
                                require('autoprefixer')({
                                    &quot;overrideBrowserslist&quot;: [
                                        &quot;&gt;0.25%&quot;,
                                        &quot;not dead&quot;
                                    ]
                                })
                            ]
                        }
                    }
                }],
                exclude: /node_modules/
            }
        ]
    }
}
</code></pre>
<p>看到这个丑陋冗长的配置，总感觉怪怪的，一般会将它们抽离到<code>postcss</code>和<code>browserslist</code>的配置文件中。</p>
<p>在项目根目录创建postcss配置文件<code>postcss.config.js</code>。</p>
<pre><code class="language-js">// postcss.config.js
module.exports = {
  plugins: {
    'autoprefixer': {}
  }
};
</code></pre>
<p>另外再创建一个<code>browserslist</code>配置文件<code>.browserslistrc</code>，用来指定要兼容的浏览器。</p>
<pre><code class="language-js">&gt; 1%
last 2 versions
not ie &lt;= 8
</code></pre>
<p>现在配置文件看起就要舒服多了。</p>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
    //...
    module: {
        rules: [
            {
                test: /\.css$/,
                use: ['style-loader', 'css-loader', 'postcss-loader'],
                exclude: /node_modules/
            }
        ]
    }
}
</code></pre>
<h4 id="使用预处理器">使用预处理器</h4>
<p>目前前端比较流行的三种css预处理器都有相应的工具进行处理，使用方法也是类似的，安装相应的loader和核心处理程序就可以了。</p>
<table>
<thead>
<tr>
<th>预处理器</th>
<th>loader</th>
<th>核心处理程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>less</td>
<td>less-loader</td>
<td>less</td>
</tr>
<tr>
<td>sass</td>
<td>sass-loader</td>
<td>node-sass或dart-sass</td>
</tr>
<tr>
<td>stylus</td>
<td>stylus-loader</td>
<td>stylus</td>
</tr>
</tbody>
</table>
<p>以less为例：</p>
<pre><code class="language-shell">npm install less-loader less -D
</code></pre>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
    //...
    module: {
        rules: [
            {
                test: /\.less$/,
                use: ['style-loader', 'css-loader','postcss-loader','less-loader'],
                exclude: /node_modules/
            }
        ]
    }
}
</code></pre>
<h4 id="样式文件分离">样式文件分离</h4>
<p>经过如上几个loader处理，css最终是打包在js中的，运行时会动态插入head中，但是我们一般在生产环境会把css文件分离出来（有利于用户端缓存、并行加载及减小js包的大小），这时候就用到 <a href="https://github.com/webpack-contrib/mini-css-extract-plugin">mini-css-extract-plugin</a> 插件。</p>
<pre><code class="language-shell">npm i -D mini-css-extract-plugin
</code></pre>
<pre><code class="language-js">// build/webpack.base.conf.js
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/,
        use: [
          // 插件需要参与模块解析，须在此设置此项，不再需要style-loader
          {
             loader: MiniCssExtractPlugin.loader,
             options: {
                hmr: true, // 模块热替换，仅需在开发环境开启
                // reloadAll: true,
                // ... 其他配置
             }
          },
           'css-loader',
           'postcss-loader',
           'less-loader'
        ],
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].css', // 输出文件的名字
      // ... 其他配置
    }),
  ]
};
</code></pre>
<h3 id="图片字体文件处理">图片/字体文件处理</h3>
<p><code>url-loader</code> 和 <code>file-loader</code> 都可以用来处理本地的资源文件，如图片、字体、音视频等。功能也是类似的， 不过<code>url-loader</code> 可以指定在文件大小小于指定的限制时，返回 <code>DataURL</code>，不会输出真实的文件，可以减少昂贵的网络请求。</p>
<pre><code class="language-shell">npm install url-loader file-loader -D
</code></pre>
<pre><code class="language-js">// build/webpack.base.conf.js
module.exports = {
    modules: {
        rules: [
            {
                test: /\.(png|jpg|gif|jpeg|webp|svg|eot|ttf|woff|woff2)$/,
                use: [
                    {
                        loader: 'url-loader', // 仅配置url-loader即可，内部会自动调用file-loader
                        options: {
                            limit: 10240, //小于此值的文件会被转换成DataURL
                            name: '[name]_[hash:6].[ext]', // 设置输出文件的名字
                            outputPath: 'assets', // 设置资源输出的目录
                            esModule: false
                        }
                    }
                ],
                exclude: /node_modules/
            }
        ]
    }
}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>limit的设置要设置合理，太大会导致JS文件加载变慢，需要兼顾加载速度和网络请求次数。</p>
<p>如果需要使用图片压缩功能，可以使用 <a href="https://github.com/tcoopman/image-webpack-loader">image-webpack-loader</a> 。</p>
</blockquote>
<h3 id="实时预览及模块热替换">实时预览及模块热替换</h3>
<p>在开发环境，可以借助<code>webpack-dev-server</code>启动一个server来实时预览应用程序。由于<code>webpack-dev-server</code>并不包含在核心库中，所以需要额外安装。</p>
<pre><code class="language-shell">npm install webpack-dev-server -D
</code></pre>
<pre><code class="language-js">// build/webpack.dev.conf.js
module.exports = {
    //...
    devServer: {
        port: '8080', //默认是8080
        hot: true, // 开启模块热替换
        publicPath:'/', // 构建好的静态文件访问路径，可以和output.publicPath保持一致
        inline: true, //默认开启 inline 模式，如果设置为false,开启 iframe 模式
        stats: &quot;errors-only&quot;, //终端仅打印 error
        overlay: true, //启用浮层提示
        clientLogLevel: &quot;silent&quot;, //日志等级
        compress: false, //是否启用 gzip 压缩
        contentBase: path.join(__dirname, &quot;../public&quot;) , // 配置额外的静态文件内容的访问路径
        proxy: { // 请求代理,解决开发环境跨域问题
            // 根据情况配置
        }
    },
    plugins: [
        new webpack.HotModuleReplacementPlugin() //需要添加模块热替换插件
    ]
}
</code></pre>
<h3 id="优化调试功能">优化调试功能</h3>
<p>为代码生成source-map有助于调试排错，一般在开发环境，由于是本地加载，我们优先考虑map文件的生成速度，可以不用额外单独生成map文件，而在生产环境，则需要不生成或者单独生成文件，优先考虑加载速度。</p>
<pre><code class="language-js">// build/webpack.dev.conf.js
module.exports = {
    devtool: 'cheap-module-eval-source-map' // 开发环境下使用内联方式，忽略列信息
}
</code></pre>
<pre><code class="language-js">// build/webpack.prod.conf.js
module.exports = {
    devtool: 'none' // 也可以使用'source-map'
}
</code></pre>
<p>除了上述配置项，我们一般在开发环境还会开启ESLint，由于后面有一篇专门的内容来叙述，所以此处不赘述。</p>
<p>到此，我们就能够自己进行打包配置了，日常开发应该是可以满足了。</p>
<h1 id="结语">结语</h1>
<p>其实webpack配置很多，相信没有一个人能够记住如此之多的api，这也是困扰初学者的一个问题。这里和大家分享一下我的学习方法：</p>
<ol>
<li>
<p>首先，了解webpack是解决什么问题及有哪些能力，而不是一开始就去记忆那些枯燥的配置，成为所谓的webpack配置工程师。</p>
</li>
<li>
<p>其次，按照功能和用途将api分类，方便记忆和后续的查阅。特别是loader和plugin，数量众多，每个的配置也不一样，我们只需要了解处理特定类型的文件和操作该用哪个就行，不必记住每个的配置。</p>
</li>
<li>
<p>最后，在需要用到某个功能的时候，根据上一步的分类，再去查阅对应的文档。官网也提供了<a href="https://webpack.js.org/configuration">完整的配置</a>，可以很方便的查找对应的配置文档。</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/letwrong/Picture/raw/master/20200530214725.jpg" alt="" loading="lazy"></figure>
<center>早期的文档</center>
</li>
</ol>
<p>相比早期的文档，目前官方网站上的文档质量已比较完善和友好了，自行修炼完全没有问题了（找个妹子双修效果更好哦）。</p>
<p>好了，关于webpack的基础部分就告一段落了，在接下来我们将会着重介绍一些性能优化及原理方面的东西，下篇再见吧！</p>
<p>参考文档：<a href="https://webpack.docschina.org/">webpack官网-中文</a>，<a href="http://www.xbhub.com/wiki/webpack/">深入浅出webpack</a></p>

							</div>
	<div class="wow fadeInUp vt-post-tags">
 
				<a href="https://www.bwrong.cn/tag/webpack/" rel="tag">webpack</a>
				 
					</div>
<nav class="navigation3 post-navigation3" role="navigation">

		<div class="nav-links3">
      
		<div class="wow fadeInUp nav-previous3"><a href="https://www.bwrong.cn/post/dev-tools04/" rel="prev"> 【前端工程化】篇四 席卷八荒-Webpack（进阶）</a></div>
		 
		 
		<div class="wow fadeInUp nav-next3"><a href="https://www.bwrong.cn/post/dev-tools02/" rel="next"> 【前端工程化】篇二 白璧微瑕-包管理器</a></div>
		
		</div>
	</nav>
	<div class="wow fadeInUp author-info">
	<div class="author-avatar pull-left"><img src="https://www.bwrong.cn/images/avatar.png" ></div>
 
	<div class="author-description"><div class="author-title"><div class="author-link" rel="author">BWrong</div></div>


	<p class="author-bio">愿你走出半生，归来仍是少年</p></div></div>
	
		</div>



</article>

<div id="marlin_lite_about_widget-2" class="wow fadeInUp widget marlin_lite_about_widget" data-wow-delay="0.1s">

        
		<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://www.bwrong.cn/media/scripts/Valine.min.js'></script>

<div class="comment"></div>
<script>
        new Valine({
            av: AV,
            el: '.comment',
            lang: 'zh-cn',
            visitor: false, // 阅读量统计
            
            admin_email:'wang11535041@qq.com',
            
            
            emoticon_url: '/media/alu',
             
      emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
     
      app_id: 'jaz3TfUjRowK9fOMAPb9yw6i-MdYXbMMI',
      
      
      app_key: 'pbltxx4rElIP1RStL3AwujSp',
         
          
      placeholder: '欢迎你留下足迹'
       
        });
    </script>





		</div>

			</div>
			


<div class="tocc col l3 hide-on-med-and-down">

        <div class="toc-widget">

            <div class="toc-title"></div>

            <div id="toc-content">


			</div>
        </div>
    </div>


<script src="https://www.bwrong.cn/media/scripts/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '.entry-summary',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1,h2' //**
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('.entry-summary').children('h1, h2').each(function () {/**/
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget').parent();
        // let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>






			</div>
		</div>


		 <footer id="colophon" class="site-footer">

	<div class="container">

		<div class="copyright"> <br>Theme: <a
				href="https://github.com/alterfang/gridea-theme-pan" target="_blank" title="Pan"><span>Pan</span></a>.
			Powered by <a href="https://gridea.dev/" target="_blank" title="Gridea"><span>Gridea</span></a> . 版权所有：<a href="https://beian.miit.gov.cn/" target="_blank"><span>蜀ICP备2023018303号-1</span></a></div>
	</div>

</footer>
		<!-- loding -->
		<div class="loader">
			<div class="loader-content">
				<div class="songjingge">
					<span></span>
					<span></span>
					<span></span>
					<span></span>
					<span></span>
				</div>
			</div>
		</div>
<script id="rendered-js">
	window.onload = function () {
			var loader = document.getElementsByClassName("loader")[0];
			loader.className = "loader fadeout"; //使用渐隐的方法淡出loading page
			setTimeout(function () {
				loader.style.display = "none";
			}, 0);
	};
</script>


</div>

<script src="https://cdn.bootcss.com/fitvids/1.2.0/jquery.fitvids.min.js"></script>
<script type='text/javascript' src='https://www.bwrong.cn/media/scripts/marlin-scripts.js'></script>
<script src="https://www.bwrong.cn/media/scripts/lately.min.js"></script>
<script>jQuery(document).ready(function () { $.lately({ 'target': '.lately-a,.lately-b,.lately-c' }) });</script>
<style type="text/css">
  a.back_to_top {
    text-decoration: none;
    position: fixed;
    bottom: 40px;
    right: 30px;
    background: #f0f0f0;
    height: 40px;
    width: 40px;
    border-radius: 50%;
    line-height: 36px;
    font-size: 18px;
    text-align: center;
    transition-duration: .5s;
    transition-propety: background-color;
    display: none;
  }

  a.back_to_top span {
    color: #888;
  }

  a.back_to_top:hover {
    cursor: pointer;
    background: #dfdfdf;
  }

  a.back_to_top:hover span {
    color: #555;
  }

  @media print,
  screen and (max-width: 580px) {
    .back_to_top {
      display: none !important;
    }
  }
</style><a id="back_to_top" href="#" class="back_to_top"><span><i class="iconfont icon-xiangshang"></i></span>
</a>

<script>
$(document).ready((function (_this) {
    return function () {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function () {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block');
          } else {
            return bt.css('display', 'none');
          }
        });
        return bt.click(function () {
          $('body,html').animate({
            scrollTop: 0
          }, 800);
          return false;
        });
      }
    };
  })(this));
//   $(window).load(function () {
//     //异步延迟加载样式
//     var link = $('<link />');
//     link.attr('href', 'https://fonts.googleapis.com/css?family=Dancing+Script|Noto+Sans+SC:300|Montserrat&display=swap');
//     link.attr('rel', 'stylesheet');
//     link.appendTo($('head'));
// });
</script>

<!-- 宠物 -->
<canvas id="live2dcanvas" width="200" height="400" class="live2d"></canvas>
<style>
  #live2dcanvas {
    position: fixed;
    right: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -40px;
    width: 200px;
    height: 400px;
  }

  @media (max-width: 768px) {
    #live2dcanvas {
      width: 150px;
      height: 300px;
    }
  }

  @media (max-width: 639px) {
    #live2dcanvas {
      display: none !important;
    }
  }
</style>
<script src="https://www.bwrong.cn/media/scripts/L2Dwidget.min.js"></script>
<script>
  //初始化小人物 需设置属性pluginRootPath: "live2dw/"指明资源跟路径
  L2Dwidget.init({
    pluginRootPath: "media/",//资源root路径
    pluginJsPath: "scripts/",//js相对root的路径
    pluginModelPath: "model/",//模型相对root的路径
    tagMode: !1,
    debug: !1,
    model: {
      scale: 2,
      jsonPath: "/media/model/live2d-widget-model-epsilon/Epsilon2.1.model.json"
    },
    display: {//大小位置什么的自己慢慢调就是了
      position: "right",//定位
      width: 130,//宽度
      height: 210,//高度
      hOffset: -40,//左右
      vOffset: 0//上下
    },
    mobile: {
      show: !1
    },
    log: !1
  });
</script>
<!-- 宠物结束 -->

		<script data-no-instant>
    // (function ($) {
    //     $.extend({
    //         adamsOverload: function () {
    //             $('.navigation:eq(0)').remove();
    //             $("").attr("rel" , "external");
    //             $("a[rel='external'],a[rel='external nofollow']").attr("target","_blank");
    //             $("a.vi").attr("rel" , "");
    //             $.viewImage({
    //                 'target'  : 'img',
    //                 'exclude' : '.vsmile-icons img,.gallery img',
    //                 'delay'   : 300
    //             });
    //             $.lately({
    //                 'target' : '.commentmetadata a,.infos time,.post-list time'
	// 			});
	// 			console.log(prettyPrint)
	// 			if(prettyPrint) prettyPrint();

    //             $('ul.links li a').each(function(){
    //                 if($(this).parent().find('.bg').length==0){
    //                     $(this).parent().append('<!---<div class="bg" style="background-image:url(https://c3.glgoo.top/s2/favicons?domain='+$(this).attr("href")+')"></div>--->')
    //                 }
    //             });
    //         }
    //     });
    // })(jQuery);
	// jQuery.adamsOverload();

    (function ($) {
        $.extend({
            adamsOverload: function () {
                $.viewImage({
                    'target'  : '.song img',
                    'exclude' : '.vsmile-icons img',
                    'delay'   : 300
                });
            }
        });
    })(jQuery);
    jQuery.adamsOverload();
</script>

</body>
</html>
