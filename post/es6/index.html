
<!DOCTYPE html>
<html lang="zh-CN">
<head>
 <meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
<meta HTTP-EQUIV="pragma" CONTENT="no-cache">
<meta HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate">
<meta HTTP-EQUIV="expires" CONTENT="0">
<meta name="author" content="bwrong, wang11535041@qq.com"/>
<meta name="keywords" content="ES6学习笔记 | BWrong的小站,前端,krpano,js,vue"/>
<meta name="description" content="天青色等烟雨，而我在等你"/>
<!-- <title>ES6学习笔记 | BWrong的小站</title> -->
<title>网站搭建测试</title>
<link href="https://www.bwrong.cn/media/css/fz.css" rel="stylesheet">
<link rel="stylesheet" href="https://www.bwrong.cn/styles/main.css">
<script type="text/javascript">
function getCSS()
{
        datetoday = new Date();
        timenow=datetoday.getTime();
        datetoday.setTime(timenow);
        thehour = datetoday.getHours();

        if (thehour<5)

            display = "https://www.bwrong.cn/media/css/night.css";

       else if (thehour>20)

            display = "https://www.bwrong.cn/media/css/night.css";

        else if (thehour>5)
     
            display = "https://www.bwrong.cn/media/css/day.css";

        else if (thehour<20)

            display = "https://www.bwrong.cn/media/css/day.css";


var css = '<';
        css+='link rel="stylesheet" href='+display+' \/';
        css+='>';
        document.write(css);
}
</script>
<link href="https://at.alicdn.com/t/font_1306644_ko4c4at97is.css" rel="stylesheet" />
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://www.bwrong.cn/media/css/katex.min.css">
<script type='text/javascript' src='https://www.bwrong.cn/media/scripts/script.js'></script>
<link href="https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet" />
  <script src="https://cdn.bootcss.com/wow/1.1.2/wow.min.js"></script>
  <script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>wow=new WOW({boxClass:'wow',animateClass:'animated',offset:0,mobile:true,live:true});wow.init();</script>

<script type="text/javascript">
window.onload=getCSS();
</script>
<!-- 百度统计 -->
<script>
var _hmt = _hmt || [];
(function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?2c0e9e3f54ae20480b34c178578c4df8";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
})();
</script>


</head>
<body class="post-template-default single single-post postid-70 single-format-standard">
    <div id="wrapper">

	
<header id="header" class="site-header"
		
		>
			<div class="site-branding">
									<h1 class="site-title"><a href="https://www.bwrong.cn" rel="home">BWrong的小站</a></h1>

					<h2 class="site-description">天青色等烟雨，而我在等你</h2>

							</div>
			<nav id="nav-wrapper">
				<div class="container">
					<div class="nav-toggle">
						<div class="bars">
							<div class="bar"></div>
							<div class="bar"></div>
							<div class="bar"></div>
						</div>
					</div>
					<div class="clear"></div>
					<ul id="" class="dove">
		 

<li>

	
		<a href="/">
		  首页
		</a>
	  

    

<li>

	
		<a href="/archives/index.html">
		  归档
		</a>
	  

    

<li>

	
		<a href="/post/about/">
		  关于
		</a>
	  

    

</ul>
</li>

</ul>				</div>
			</nav>
						<div class="jingge">


    

    

<a  href="https://github.com/BWrong" target="_blank" ><i class="iconfont icon-github"></i></a>
 
    

    

    

    

<a  href="https://juejin.cn/user/3421335914820280" target="_blank" ><i class="iconfont icon-telegram"></i></a>
 
    

    

    

    

    

    
        </header>


		<div id="content" class="container">
			<div class="row">
	<div class="col-md-8 site-main">

<article id="post-70" class="post-70 post type-post status-publish format-standard hentry category-5 tag-10 tag-9 tag-11">



		<div class="entry-content">
			<h1 data-wow-delay="0.4s"  class="wow fadeInUp entry-title">ES6学习笔记</h1>
<div class="entry-meta">
<div class="wow fadeInUp"  data-wow-delay="0.6s">
	<i class="iconfont icon-rili"> <time class="lately-a" datetime="2018-01-05 11:06:31" itemprop="datePublished" pubdate="">2018-01-05</time></i>
	          </div>

</span>

		</div>

			<div class="wow fadeInUp entry-summary song"  data-wow-delay="0.1s">
				<h1 id="简介">简介</h1>
<ul>
<li>ECMAScript（ECMA或ES） 是规范， JavaScript的是其规范的实现</li>
<li>ECMAScript 2015 = ES2015 ≈ ES6</li>
</ul>
<h3 id="ecmascript-的历史">ECMAScript 的历史</h3>
<table>
<thead>
<tr>
<th>时间</th>
<th>ECMA</th>
<th>JS</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1996.11</strong></td>
<td>ES 1.0</td>
<td>JS稳定</td>
<td>Netscape将JS提交给ECMA组织，ES正式出现</td>
</tr>
<tr>
<td>1998.06</td>
<td>ES 2.0</td>
<td></td>
<td>ES2正式发布</td>
</tr>
<tr>
<td>1999.12</td>
<td>ES 3.0</td>
<td></td>
<td>ES3被广泛支持</td>
</tr>
<tr>
<td>2007.10</td>
<td>ES 4.0</td>
<td></td>
<td>ES4过于激进，被废了</td>
</tr>
<tr>
<td>2008.07</td>
<td>ES 3.1</td>
<td></td>
<td>4.0退化为严重缩水版的3.1<br/>因为吵得太厉害，所以ES 3.1代号为Harmony(和谐)</td>
</tr>
<tr>
<td>2009.12</td>
<td>ES 5.0</td>
<td></td>
<td>ES 5.0正式发布<br/>同时公布了JavaScript.next也就是后来的ES 6.0</td>
</tr>
<tr>
<td>2011.06</td>
<td>ES 5.1</td>
<td></td>
<td>ES 5.1成为了ISO国际标准</td>
</tr>
<tr>
<td>2013.03</td>
<td>ES 6.0</td>
<td></td>
<td>ES 6.0草案定稿</td>
</tr>
<tr>
<td>2013.12</td>
<td>ES 6.0</td>
<td></td>
<td>ES 6.0草案发布</td>
</tr>
<tr>
<td><strong>2015.06</strong></td>
<td>ES 6.0</td>
<td></td>
<td>ES 6.0预计发布正式版<br/>JavaScript.next开始指向ES 7.0</td>
</tr>
</tbody>
</table>
<h3 id="语法提案批准流程">语法提案批准流程</h3>
<pre><code>Stage 0 - Strawman（展示阶段）
Stage 1 - Proposal（征求意见阶段）
Stage 2 - Draft（草案阶段）
Stage 3 - Candidate（候选人阶段）
Stage 4 - Finished（定案阶段）
</code></pre>
<h2 id="由tc39-委员会批准">由TC39 委员会批准</h2>
<h1 id="let-const">Let、const</h1>
<ul>
<li>块级作用域</li>
<li>不存在变量提升<br>
暂时性死区（temporal dead zone，简称 TDZ）：在代码块内，声明变量之前，该变量都是不可用的。</li>
<li>相同作用域内，不允许重复声明</li>
<li>区别：
<ul>
<li>let声明变量</li>
<li>const声明只读常量，常量指向的那个<strong>内存地址</strong>不得改动，且一旦声明变量，就必须立即初始化。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="解构赋值">解构赋值</h1>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。<br>
适用于数组（这里泛指具有Iterator接口的数据结构）、对象、字符串、数值和布尔值，可设置默认值。</p>
<pre><code class="language-js">//数组
let [x, y = 'b', z='c'] = ['a', undefined, null];// x='a', y='b' z=null
//对象
let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };//foo = &quot;aaa&quot;; bar = &quot;bbb&quot;
//字符串，先转为数组
const [a, b, length : len] = 'ho';//a=&quot;h&quot;;b= &quot;o&quot;;len = 2
//数值与布尔值,先转为对象
let {toString: s} = 123;//s = Number.prototype.toString
let {toString: s} = true;//s = Boolean.prototype.toString
</code></pre>
<ul>
<li>如果解构不成功，变量的值就等于undefined</li>
<li>只有当成员严格等于undefined，默认值才会生效</li>
<li>两边的结构要一致</li>
<li>结构完立即赋值，结构和赋值不能分开进行</li>
<li>使用于对象时，键对键，值对值；且大括号不能在行首（会理解成语法块），可用小括号包裹</li>
<li>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象</li>
</ul>
<hr>
<h1 id="字符串扩展">字符串扩展</h1>
<h3 id="查找">查找</h3>
<ul>
<li><code>includes(String)</code>：是否找到参数字符串。</li>
<li><code>startsWith(String)</code>：是否以参数字符串开头。</li>
<li><code>endsWith(String)</code>：是否以参数字符串结尾。</li>
</ul>
<pre><code class="language-js">let s = 'Hello world!';
s.includes('o') // true
//均可接受第二个位置参数
</code></pre>
<h3 id="重复">重复</h3>
<ul>
<li><code>repeat(Number)</code></li>
</ul>
<pre><code>'x'.repeat(3) // &quot;xxx&quot;
</code></pre>
<h3 id="模板字符串">模板字符串</h3>
<ul>
<li>支持变量、表达式、函数调用，允许嵌套</li>
<li>反引号需使用反斜杠转义</li>
<li>trim消除空格和换行</li>
</ul>
<pre><code class="language-js">$('#result').append(`
  There are &lt;b&gt;${basket.count}&lt;/b&gt; items
   in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt;
  are on sale!
`);
//trim
$('#list').html(`
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
`.trim());
</code></pre>
<hr>
<h1 id="数值的扩展">数值的扩展</h1>
<ul>
<li><code>Number.isFinite()</code>-只对数值返回true</li>
<li><code>Number.isNaN()</code>-只对NaN返回true</li>
<li><code>Number.isInteger()</code>-只对整数返回true</li>
<li><code>Number.isSafeInteger()</code>-只对安全整数（-2<sup>53到2</sup>53，不含端点）返回true</li>
<li><code>Number.MAX_SAFE_INTEGER</code>,<code>Number.MIN_SAFE_INTEGER</code>安全整数的上下限常量</li>
</ul>
<pre><code>Number.isInteger(25) // true
Number.isInteger(25.0) // true
Number.isInteger(25.1) // false
</code></pre>
<p>Math对象扩展：http://es6.ruanyifeng.com/#docs/number#Math-对象的扩展</p>
<hr>
<h1 id="函数的扩展">函数的扩展</h1>
<ul>
<li>参数默认值，建议用于尾参数，不可在函数内再次声明</li>
</ul>
<pre><code class="language-js">function log(x, y = 'World') {}
</code></pre>
<ul>
<li>length：从第一个参数到首个指定默认值参数间参数的个数</li>
</ul>
<pre><code class="language-js">(function (a, b = 1, c) {}).length // 1
</code></pre>
<ul>
<li>rest：获取函数的多余参数，须用于尾参数</li>
</ul>
<pre><code class="language-js">function add(...values) {}
add(2, 5, 3)
</code></pre>
<ul>
<li>name：函数的名字</li>
</ul>
<pre><code class="language-js">function f() {}
//或者
var f = function () {};
f.name // &quot;f&quot;
</code></pre>
<h3 id="箭头函数">箭头函数</h3>
<ul>
<li>只有一个参数，可省略参数的小括号，无参数时不可省略</li>
<li>如果只有一条语句且无return，可以省略语句块的大括号</li>
<li>如果只有一条语句且有return，可以省略大括号和return，仅有return（即return后无参数）时不可省略</li>
<li>直接返回对象，须使用小括号包裹</li>
</ul>
<pre><code class="language-js">let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });
</code></pre>
<ul>
<li>可以使用解构赋值，可以嵌套</li>
</ul>
<pre><code>const full = ({ first, last }) =&gt; first + ' ' + last;
const pipeline = (...funcs) =&gt;
  val =&gt; funcs.reduce((a, b) =&gt; b(a), val);
</code></pre>
<ul>
<li>注意：
<ul>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="数组的扩展">数组的扩展</h1>
<h3 id="扩展运算符">扩展运算符</h3>
<p>用于数组赋值须放在参数的最后一位。</p>
<pre><code class="language-js">console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5
//复制数组
const a1 = [1, 2];
const a2 = [...a1];// 写法一
const [...a2] = a1;// 写法二
//合并数组
const a2 = [3, 4];
[...a1, ...a2] //[1,2,3,4]
//配合解构赋值
const [first, ...rest] = [1, 2, 3, 4, 5];// first= 1;rest= [2, 3, 4, 5]
//字符串
[...'hello'] // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre>
<h3 id="新增方法">新增方法</h3>
<ul>
<li><code>Array.from()</code>：将数组对象（有length属性）或可遍历的对象（包括 ES6 新增的数据结构 Set 和 Map）转为真正的数组，接受第二个参数（对每个元素进行处理，处理值返回数组）。</li>
</ul>
<pre><code class="language-js">let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
</code></pre>
<ul>
<li><code>Array.of()</code>：将一组值转换为数组。</li>
</ul>
<pre><code class="language-js">Array.of(3, 11, 8) // [3,11,8]
</code></pre>
<ul>
<li><code>copyWithin（target[必需，替换开始位置，负值为倒数], start = 0[可选，读取开始位置，负值为倒数], end = this.length[可选，读取结束位置，负值为倒数]）</code>：在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。</li>
</ul>
<pre><code class="language-js">[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5]
</code></pre>
<ul>
<li><code>find(fn)</code> 和 <code>findIndex(fn)</code>：找出第一个符合条件的数组成员。如果无符合条件的成员，返回undefined。</li>
</ul>
<pre><code class="language-js">//find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组
[1, 5, 10, 15].find(function(value, index, arr) {
  return value &gt; 9;
}) // 10
</code></pre>
<ul>
<li><code>fill(text[必需，填充内容],start = 0[可选，开始位置，负值为倒数], end = this.length[可选，结束位置，负值为倒数])</code>: 使用给定值，填充一个数组。</li>
</ul>
<pre><code>['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c']
</code></pre>
<ul>
<li><code>includes(text[必需，内容],start = 0[可选，搜索开始位置，负值为倒数], end = this.length[可选，搜索结束位置，负值为倒数])</code>：搜索数组是否包含给定的值。</li>
</ul>
<pre><code class="language-js">[1, 2, 3].includes(3, -1); // true
</code></pre>
<hr>
<h1 id="对象的扩展">对象的扩展</h1>
<ul>
<li>简洁表示：对象的key和value一样时，可以省略key，方法可省略function</li>
</ul>
<pre><code class="language-js">const foo = 'bar';
const baz = {
	foo,
   method() {
    return &quot;Hello!&quot;;
  }
}
</code></pre>
<ul>
<li>属性名表达式: 不能使用简洁表示</li>
</ul>
<pre><code class="language-js">let propKey = 'foo';

let obj = {
  [propKey]: true,
  ['a' + 'bc']: 123
}
</code></pre>
<ul>
<li><code>Object.is()</code>: 判断两值是否相等</li>
</ul>
<pre><code class="language-js">//和===的区别
+0 === -0 //true
NaN === NaN // false
Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre>
<ul>
<li><code>Object.assign(target[目标对象], source1, source2，...)</code>: 将源对象所有可枚举属性复制合并到目标对象。</li>
</ul>
<pre><code class="language-js">const target = { a: 1, b: 1 };
const source1 = { b: 2, c: 2 };
const source2 = { c: 3 };
Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre>
<ul>
<li>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</li>
<li>遇到同名属性，Object.assign的处理方法是后面替换前面的。</li>
<li>Object.assign可以用来处理数组，但是会把数组视为对象。</li>
<li>Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</li>
</ul>
<hr>
<h1 id="set和map数据结构">Set和Map数据结构</h1>
<h3 id="set集合">Set（集合）</h3>
<p>集合：集合是由一组无序且唯一(即不能重复)的项组成的，可以想象成集合是一个既没有重复元素，也没有顺序概念的数组</p>
<h4 id="基本用法">基本用法</h4>
<p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>
Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
<pre><code>const s = new Set();

[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));

for (let i of s) {
  console.log(i);
}
// 2 3 5 4
// 去除数组的重复成员
const set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]
</code></pre>
<p>向 Set 加入值的时候，不会发生类型转换。</p>
<h4 id="属性和方法">属性和方法</h4>
<p>Set 结构的实例有以下属性。</p>
<ul>
<li>size：返回Set实例的成员总数。</li>
</ul>
<h6 id="实例操作方法用于操作数据">实例操作方法（用于操作数据）</h6>
<ul>
<li>add(value)：添加某个值，返回 Set 结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
<pre><code>s.add(1).add(2).add(2);
// 注意2被加入了两次

s.size // 2

s.has(1) // true
s.has(2) // true
s.has(3) // false

s.delete(2);
s.has(2) // false
</code></pre>
<h6 id="遍历方法用于遍历成员">遍历方法（用于遍历成员）</h6>
<p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<p>需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>
<pre><code>let set = new Set(['red', 'green', 'blue']);

for (let item of set.keys()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.values()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.entries()) {
  console.log(item);
}
// [&quot;red&quot;, &quot;red&quot;]
// [&quot;green&quot;, &quot;green&quot;]
// [&quot;blue&quot;, &quot;blue&quot;]
</code></pre>
<h3 id="weakset">WeakSet</h3>
<p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值;</p>
<p>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存。</p>
<h4 id="语法">语法</h4>
<p>WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。</p>
<pre><code>const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);
// WeakSet {[1, 2], [3, 4]}
</code></pre>
<h4 id="方法">方法</h4>
<p>WeakSet 结构有以下三个方法。</p>
<ul>
<li>add(value)：向 WeakSet 实例添加一个新成员。</li>
<li>delete(value)：清除 WeakSet 实例的指定成员。</li>
<li>has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>
</ul>
<h3 id="map字典">Map（字典）</h3>
<p>类似对象，唯一的区别是key的范围不限于字符串，各种类型的值（包括对象）都可以当作键。主要用于数据存储</p>
<pre><code>const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);

map.size // 2
map.has('name') // true
map.get('name') // &quot;张三&quot;
map.has('title') // true
map.get('title') // &quot;Author&quot;
</code></pre>
<h4 id="属性和方法-2">属性和方法</h4>
<ul>
<li>size：属性返回 Map 结构的成员总数。</li>
<li>set(key, value)：<br>
set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li>
</ul>
<pre><code>const m = new Map();

m.set('edition', 6)        // 键是字符串
m.set(262, 'standard')     // 键是数值
m.set(undefined, 'nah')    // 键是 undefined
//或者
let map = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c');
</code></pre>
<ul>
<li>get(key)：<br>
get方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>has(key)：<br>
has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</li>
<li>delete(key)：<br>
delete方法删除某个键，返回true。如果删除失败，返回false。</li>
<li>clear()：<br>
clear方法清除所有成员，没有返回值。</li>
</ul>
<h4 id="遍历">遍历：</h4>
<p>提供三个遍历器生成函数和一个遍历方法。Map 的遍历顺序就是插入顺序</p>
<ul>
<li>keys()：返回键名的遍历器。</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回所有成员的遍历器。</li>
<li>forEach()：遍历 Map 的所有成员。</li>
</ul>
<h4 id="数据结构转换">数据结构转换</h4>
<ul>
<li>Map 转为数组</li>
</ul>
<pre><code>const myMap = new Map()
  .set(true, 7)
  .set({foo: 3}, ['abc']);
[...myMap]
// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]
</code></pre>
<ul>
<li>数组 转为 Map</li>
</ul>
<pre><code>new Map([
  [true, 7],
  [{foo: 3}, ['abc']]
])
// Map {
//   true =&gt; 7,
//   Object {foo: 3} =&gt; ['abc']
// }
</code></pre>
<ul>
<li>Map 转为对象</li>
</ul>
<pre><code>function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k,v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

const myMap = new Map()
  .set('yes', true)
  .set('no', false);
strMapToObj(myMap)
// { yes: true, no: false }
</code></pre>
<ul>
<li>对象转为 Map</li>
</ul>
<pre><code>function objToStrMap(obj) {
  let strMap = new Map();
  for (let k of Object.keys(obj)) {
    strMap.set(k, obj[k]);
  }
  return strMap;
}

objToStrMap({yes: true, no: false})
// Map {&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false}
</code></pre>
<ul>
<li>Map 转为 JSON</li>
</ul>
<p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p>
<pre><code>function strMapToJson(strMap) {
  return JSON.stringify(strMapToObj(strMap));
}

let myMap = new Map().set('yes', true).set('no', false);
strMapToJson(myMap)
// '{&quot;yes&quot;:true,&quot;no&quot;:false}'
</code></pre>
<p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p>
<pre><code>function mapToArrayJson(map) {
  return JSON.stringify([...map]);
}

let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
mapToArrayJson(myMap)
// '[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]'
</code></pre>
<ul>
<li>JSON 转为 Map</li>
</ul>
<p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p>
<pre><code>function jsonToStrMap(jsonStr) {
  return objToStrMap(JSON.parse(jsonStr));
}

jsonToStrMap('{&quot;yes&quot;: true, &quot;no&quot;: false}')
// Map {'yes' =&gt; true, 'no' =&gt; false}
</code></pre>
<p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是数组转为 JSON 的逆操作。</p>
<pre><code>function jsonToMap(jsonStr) {
  return new Map(JSON.parse(jsonStr));
}

jsonToMap('[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]')
// Map {true =&gt; 7, Object {foo: 3} =&gt; ['abc']}
</code></pre>
<h3 id="weakmap">WeakMap</h3>
<p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。<br>
区别：</p>
<ul>
<li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>
<li>WeakMap的键名所指向的对象，不计入垃圾回收机制。</li>
</ul>
<h3 id="区别">区别</h3>
<p>集合又和字典有什么区别呢：</p>
<ul>
<li>共同点：集合、字典可以存储不重复的值</li>
<li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li>
</ul>
<hr>
<h1 id="promise对象">Promise对象</h1>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件），更合理和更强大。</p>
<ul>
<li>特点：
<ul>
<li>对象的状态[pending（进行中）、fulfilled（已成功）和rejected（已失败）]不受外界影响</li>
<li>一旦状态改变，就不会再变，任何时候得到的都是这个结果</li>
</ul>
</li>
</ul>
<pre><code class="language-js">const promise = new Promise(function(resolve, reject) {
  // ... some code
  if (/* 异步操作成功 */){
    resolve(value); //将Promise对象的状态从“未完成”变为“成功”,并将异步操作的结果，作为参数传递出去
  } else {
    reject(error); //将Promise对象的状态从“未完成”变为“失败”,并将异步操作报出的错误，作为参数传递出去
  }
});
//调用
promise.then(value=&gt; {
  // success
}, error=&gt; { //可选
  // failure
});
//或者
promise.then(value =&gt; {
  // success
}).catch(error =&gt; {
  // failure
});
</code></pre>
<ul>
<li><code>Promise.all([p1, p2, ...])</code>: 将多个 Promise 包装成一个新的 Promise ，状态和值取决于里面的实例（fulfilled：需均成功，返回包含每个实例返回值的数组；rejected：至少一个失败，返回第一个失败的实例返回值）</li>
<li><code>Promise.race([p1, p2, ...])</code>: 将多个 Promise 包装成一个新的 Promise，状态和参数均由里面第一个改变的状态的实例决定</li>
<li><code>Promise.resolve()</code>：简写，将现有对象转为 状态为fulfilled的Promise 对象。</li>
</ul>
<pre><code class="language-js">Promise.resolve('foo')
// 等价于
new Promise(resolve =&gt; resolve('foo'))
</code></pre>
<ul>
<li><code>Promise.reject()</code>：简写，将现有对象转为 状态为rejected的Promise 对象。</li>
</ul>
<pre><code class="language-js">const p = Promise.reject('出错了');
// 等同于
const p = new Promise((resolve, reject) =&gt; reject('出错了'))
</code></pre>
<hr>
<h1 id="iterator遍历器">Iterator（遍历器）</h1>
<h3 id="概念">概念</h3>
<p>数据集合：主要是Array，Object，Map，Set。<br>
遍历器（Iterator）为上述数据集合提供了<strong>统一</strong>的访问机制。</p>
<h6 id="iterator-的作用有三个">Iterator 的作用有三个：</h6>
<ul>
<li>一是为各种数据结构，提供一个统一的、简便的访问接口；</li>
<li>二是使得数据结构的成员能够按某种次序排列；</li>
<li>三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。</li>
</ul>
<h3 id="forof-循环">for...of 循环</h3>
<pre><code>const arr = ['red', 'green', 'blue'];

for(let v of arr) {
  console.log(v); // red green blue
}
</code></pre>
<h6 id="区别-2">区别：</h6>
<ul>
<li>for...in遍历键名，for...of遍历键值</li>
</ul>
<pre><code>var arr = ['a', 'b', 'c', 'd'];

for (let a in arr) {
  console.log(a); // 0 1 2 3
}

for (let a of arr) {
  console.log(a); // a b c d
}
</code></pre>
<ul>
<li>for...of可以配合break、continue和return使用</li>
</ul>
<pre><code>for (var n of fibonacci) {
  if (n &gt; 1000)
    break;
  console.log(n);
}
</code></pre>
<h1 id="generator">Generator</h1>
<h3 id="概念-2">概念</h3>
<p>Generator 函数是 ES6 提供的一种异步编程解决方案。<br>
Generator 函数是一个状态机，封装了多个内部状态。</p>
<pre><code class="language-js">function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

var hw = helloWorldGenerator();
hw.next()
// { value: 'hello', done: false }
hw.next()
// { value: 'world', done: false }

hw.next()
// { value: 'ending', done: true }
</code></pre>
<p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，必须调用next()才会执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象（yield）。</p>
<h3 id="yield-表达式">yield 表达式</h3>
<p>遍历器对象的next方法的运行逻辑如下。</p>
<ul>
<li>（1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li>
<li>（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</li>
<li>（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li>
<li>（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。</li>
<li>yield其實是兩個動作的合體：丟東西出去-&gt;等東西進來；<br>
每次next()都會跑到yield丟東西出來的那個步驟</li>
</ul>
<pre><code class="language-js">//输入输出：yield右边为输出（next返回值的value，最后一次由return返回），左边为输入（接受的是next的参数，第一次由函数参数传入），
function * input(){
    let array = [], i = 4;
    while(i) {
        array.push(yield array);
        i --;
    }
}

var gen = input();
console.log(gen.next(&quot;西&quot;)) // { value: [], done: false }
console.log(gen.next(&quot;部&quot;)) // { value: [ '部' ], done: false }
console.log(gen.next(&quot;世&quot;)) // { value: [ '部', '世' ], done: false }
console.log(gen.next(&quot;界&quot;)) // { value: [ '部', '世', '界' ], done: false }
</code></pre>
<h3 id="next-方法的参数">next 方法的参数</h3>
<p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>
<h3 id="forof-循环-2">for...of 循环</h3>
<p>for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。</p>
<pre><code>function* foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of foo()) {
  console.log(v);
}
// 1 2 3 4 5
</code></pre>
<h3 id="next-throw-return-的共同点">next()、throw()、return() 的共同点</h3>
<p>next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。</p>
<ul>
<li>next()是将yield表达式替换成一个值。</li>
</ul>
<pre><code>const g = function* (x, y) {
  let result = yield x + y;
  return result;
};

const gen = g(1, 2);
gen.next(); // Object {value: 3, done: false}

gen.next(1); // Object {value: 1, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = 1;
</code></pre>
<ul>
<li>throw()是将yield表达式替换成一个throw语句。</li>
</ul>
<pre><code>gen.throw(new Error('出错了')); // Uncaught Error: 出错了
// 相当于将 let result = yield x + y
// 替换成 let result = throw(new Error('出错了'));
</code></pre>
<ul>
<li>return()是将yield表达式替换成一个return语句。</li>
</ul>
<pre><code>gen.return(2); // Object {value: 2, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = return 2;
</code></pre>
<h3 id="yield-表达式-2">yield* 表达式</h3>
<p>在 Generator 函数内部，调用另一个 Generator 函数</p>
<pre><code>function* bar() {
  yield 'x';
  yield* foo();
  yield 'y';
}

// 等同于
function* bar() {
  yield 'x';
  yield 'a';
  yield 'b';
  yield 'y';
}

// 等同于
function* bar() {
  yield 'x';
  for (let v of foo()) {
    yield v;
  }
  yield 'y';
}

for (let v of bar()){
  console.log(v);
}
// &quot;x&quot;
// &quot;a&quot;
// &quot;b&quot;
// &quot;y&quot;
</code></pre>
<h3 id="作为对象属性的-generator-函数">作为对象属性的 Generator 函数</h3>
<pre><code>let obj = {
  * myGeneratorMethod() {
    ···
  }
};
//等价于
let obj = {
  myGeneratorMethod: function* () {
    // ···
  }
};
</code></pre>
<h3 id="应用">应用</h3>
<ul>
<li>ajax</li>
</ul>
<pre><code>function* main() {
  var result = yield request(&quot;http://some.url&quot;);
  var resp = JSON.parse(result);
    console.log(resp.value);
}

function request(url) {
  makeAjaxCall(url, function(response){
    it.next(response);
  });
}

var it = main();
it.next();
</code></pre>
<p>更多Generator 函数的异步应用：http://es6.ruanyifeng.com/#docs/generator-async</p>
<p>http://jsfiddle.net/Yoghurts/xnqofbep/4/<br>
<strong>ES7引入 async await，使其更加好用</strong></p>
<h3 id="利用es6中的generator实现并发编程">利用ES6中的Generator实现并发编程</h3>
<h4 id="参考资料">参考资料</h4>
<ul>
<li><a href="http://www.infoq.com/cn/articles/producers-and-consumers-mode">生产者消费者模式</a></li>
<li><a href="http://blog.csdn.net/shishuo365/article/details/37033439">JS实现经典生产者消费者模型</a></li>
<li><a href="http://blog.csdn.net/linsongbin1/article/details/55048058">生产者-消费者模式</a></li>
</ul>
<h4 id="es6实现">ES6实现</h4>
<pre><code>// 暂停
function sleep(numberMillis) {
    var now = new Date();
    var exitTime = now.getTime() + numberMillis;
    while (true) {
        now = new Date();
        if (now.getTime() &gt; exitTime){
            return;
        }
    }
}

// 消费者
function* consumer(name) {
    console.log(`${name}准备吃包子啦！`);
    while (true) {
        var baozi = yield;
        baozi += 1;
        console.log(`第${baozi}个包子来了，被分成了两份，一份被${name}吃了！`);
    }
}

// 生产者
function producer(name) {
    c1 = consumer('A');
    c2 = consumer('B');
    console.log(`${name}：我开始准备做包子了！`);
    c1.next();
    c2.next();
    for (let i = 0; i &lt; 10; i++) {
        sleep(1000);
        c1.next(i);
        c2.next(i);
    }
}

// 小明开始生产包子，A和B同时开始吃包子
producer('小明')
</code></pre>
<h4 id="运行结果">运行结果</h4>
<pre><code>小明：我开始准备做包子了！
A准备吃包子啦！
B准备吃包子啦！
第1个包子来了，被分成了两份，一份被A吃了！
第1个包子来了，被分成了两份，一份被B吃了！
第2个包子来了，被分成了两份，一份被A吃了！
第2个包子来了，被分成了两份，一份被B吃了！
第3个包子来了，被分成了两份，一份被A吃了！
第3个包子来了，被分成了两份，一份被B吃了！
第4个包子来了，被分成了两份，一份被A吃了！
第4个包子来了，被分成了两份，一份被B吃了！
第5个包子来了，被分成了两份，一份被A吃了！
第5个包子来了，被分成了两份，一份被B吃了！
第6个包子来了，被分成了两份，一份被A吃了！
第6个包子来了，被分成了两份，一份被B吃了！
第7个包子来了，被分成了两份，一份被A吃了！
第7个包子来了，被分成了两份，一份被B吃了！
第8个包子来了，被分成了两份，一份被A吃了！
第8个包子来了，被分成了两份，一份被B吃了！
第9个包子来了，被分成了两份，一份被A吃了！
第9个包子来了，被分成了两份，一份被B吃了！
第10个包子来了，被分成了两份，一份被A吃了！
第10个包子来了，被分成了两份，一份被B吃了！
</code></pre>
<h1 id="class">Class</h1>
<h3 id="定义类">定义类</h3>
<pre><code>//以前
function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return '(' + this.x + ', ' + this.y + ')';
};

var p = new Point(1, 2);
</code></pre>
<p>ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<pre><code>//es6
class Point {
//构造方法
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
var p = new Point(1, 2);
</code></pre>
<h3 id="继承类">继承类</h3>
<pre><code>class Point {
}

class ColorPoint extends Point {
}
</code></pre>
<h1 id="module">module</h1>
<h3 id="简介-2">简介</h3>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<h3 id="严格模式">严格模式</h3>
<p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>
<p>严格模式主要有以下限制：</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用with语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li>
<li>eval不会在它的外层作用域引入变量</li>
<li>eval和arguments不能被重新赋值</li>
<li>arguments不会自动反映函数参数的变化</li>
<li>不能使用arguments.callee</li>
<li>不能使用arguments.caller</li>
<li>禁止this指向全局对象</li>
<li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li>
<li>增加了保留字（比如protected、static和interface）</li>
</ul>
<h3 id="export-命令">export 命令</h3>
<p>定义模块的对外接口。<br>
一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。<br>
以下是几种用法：</p>
<pre><code>//------输出变量------
export var firstName = 'Michael';
export var lastName = 'Jackson';
//等价于
var firstName = 'Michael';
export {firstName}; //推荐，能清除知道输出了哪些变量
//------输出函数或类------
export function multiply(x, y) {
  return x * y;
};
//------输出并as重命名------
var v1 = 'Michael';
function v2() { ... }
export {
  v1 as streamV1,
  v2 as streamV2
};
//------输出default------
export default function () { ... }
</code></pre>
<p>注意：<code>export default</code>在一个模块中只能有一个。</p>
<h3 id="import-命令">import 命令</h3>
<p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。<br>
以下是几种用法，必须和上面的export对应：</p>
<pre><code>//------加载变量、函数或类------
import {firstName, lastName} from './profile.js';
//------加载并as重命名------
import { lastName as surname } from './profile.js';
//------加载有default输出的模块------
import v1 from './profile.js';
//------执行所加载的模块------
import 'lodash';
//------加载模块所有输出------
import  * as surname from './profile.js';
</code></pre>
<h3 id="复合写法">复合写法</h3>
<p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p>
<pre><code>export { foo, bar } from 'my_module';

// 等同于
import { foo, bar } from 'my_module';
export { foo, bar };
</code></pre>
<h1 id="symbol">Symbol</h1>
<p>原始数据类型Symbol，表示独一无二的值。</p>
<pre><code>let s = Symbol();

typeof s
// &quot;symbol&quot;
</code></pre>
<p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<pre><code>let s1 = Symbol('foo');
let s2 = Symbol('bar');

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // &quot;Symbol(foo)&quot;
s2.toString() // &quot;Symbol(bar)&quot;
</code></pre>
<h1 id="proxy">Proxy</h1>
<p>代理器（拦截器），Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<pre><code>var proxy = new Proxy(target, handler);
</code></pre>
<ul>
<li>target参数表示所要拦截的目标对象</li>
<li>handler参数也是一个对象，用来定制拦截行为。</li>
</ul>
<pre><code>var obj = new Proxy({}, {
  get: function (target, key, receiver) {
    console.log(`getting ${key}!`);
    return target.key;
  },
  set: function (target, key, value, receiver) {
    console.log(`setting ${key}!`);
    return target.key=value;
  }
});
</code></pre>

							</div>
	<div class="wow fadeInUp vt-post-tags">
 
				<a href="https://www.bwrong.cn/tag/0g11TKOKh/" rel="tag">es6</a>
				 
				<a href="https://www.bwrong.cn/tag/V8evsIMHWn/" rel="tag">javascript</a>
				 
				<a href="https://www.bwrong.cn/tag/XdhD7xn17W/" rel="tag">ecmascript</a>
				 
					</div>
<nav class="navigation3 post-navigation3" role="navigation">

		<div class="nav-links3">
      
		<div class="wow fadeInUp nav-previous3"><a href="https://www.bwrong.cn/post/qian-duan-gong-cheng-hua-gulpwebpack/" rel="prev"> 前端工程化（Gulp、Webpack）</a></div>
		 
		 
		<div class="wow fadeInUp nav-next3"><a href="https://www.bwrong.cn/post/vue-jsx-quan-mian-zhi-nan/" rel="next"> Vue jsx全面指南</a></div>
		
		</div>
	</nav>
	<div class="wow fadeInUp author-info">
	<div class="author-avatar pull-left"><img src="https://www.bwrong.cn/images/avatar.png" ></div>
 
	<div class="author-description"><div class="author-title"><div class="author-link" rel="author">BWrong</div></div>


	<p class="author-bio">愿你走出半生，归来仍是少年</p></div></div>
	
		</div>



</article>

<div id="marlin_lite_about_widget-2" class="wow fadeInUp widget marlin_lite_about_widget" data-wow-delay="0.1s">

        
		<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://www.bwrong.cn/media/scripts/Valine.min.js'></script>

<div class="comment"></div>
<script>
        new Valine({
            av: AV,
            el: '.comment',
            lang: 'zh-cn',
            visitor: false, // 阅读量统计
            
            admin_email:'wang11535041@qq.com',
            
            
            emoticon_url: '/media/alu',
             
      emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
     
      app_id: 'jaz3TfUjRowK9fOMAPb9yw6i-MdYXbMMI',
      
      
      app_key: 'pbltxx4rElIP1RStL3AwujSp',
         
          
      placeholder: '欢迎你留下足迹'
       
        });
    </script>





		</div>

			</div>
			


<div class="tocc col l3 hide-on-med-and-down">

        <div class="toc-widget">

            <div class="toc-title"></div>

            <div id="toc-content">


			</div>
        </div>
    </div>


<script src="https://www.bwrong.cn/media/scripts/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '.entry-summary',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1,h2' //**
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('.entry-summary').children('h1, h2').each(function () {/**/
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget').parent();
        // let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>






			</div>
		</div>


		 <footer id="colophon" class="site-footer">

	<div class="container">

		<div class="copyright"> <br>Theme: <a
				href="https://github.com/alterfang/gridea-theme-pan" target="_blank" title="Pan"><span>Pan</span></a>.
			Powered by <a href="https://gridea.dev/" target="_blank" title="Gridea"><span>Gridea</span></a> . 版权所有：<a href="https://beian.miit.gov.cn/" target="_blank"><span>蜀ICP备2023018303号-1</span></a></div>
	</div>

</footer>
		<!-- loding -->
		<div class="loader">
			<div class="loader-content">
				<div class="songjingge">
					<span></span>
					<span></span>
					<span></span>
					<span></span>
					<span></span>
				</div>
			</div>
		</div>
<script id="rendered-js">
	window.onload = function () {
			var loader = document.getElementsByClassName("loader")[0];
			loader.className = "loader fadeout"; //使用渐隐的方法淡出loading page
			setTimeout(function () {
				loader.style.display = "none";
			}, 0);
	};
</script>


</div>

<script src="https://cdn.bootcss.com/fitvids/1.2.0/jquery.fitvids.min.js"></script>
<script type='text/javascript' src='https://www.bwrong.cn/media/scripts/marlin-scripts.js'></script>
<script src="https://www.bwrong.cn/media/scripts/lately.min.js"></script>
<script>jQuery(document).ready(function () { $.lately({ 'target': '.lately-a,.lately-b,.lately-c' }) });</script>
<style type="text/css">
  a.back_to_top {
    text-decoration: none;
    position: fixed;
    bottom: 40px;
    right: 30px;
    background: #f0f0f0;
    height: 40px;
    width: 40px;
    border-radius: 50%;
    line-height: 36px;
    font-size: 18px;
    text-align: center;
    transition-duration: .5s;
    transition-propety: background-color;
    display: none;
  }

  a.back_to_top span {
    color: #888;
  }

  a.back_to_top:hover {
    cursor: pointer;
    background: #dfdfdf;
  }

  a.back_to_top:hover span {
    color: #555;
  }

  @media print,
  screen and (max-width: 580px) {
    .back_to_top {
      display: none !important;
    }
  }
</style><a id="back_to_top" href="#" class="back_to_top"><span><i class="iconfont icon-xiangshang"></i></span>
</a>

<script>
$(document).ready((function (_this) {
    return function () {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function () {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block');
          } else {
            return bt.css('display', 'none');
          }
        });
        return bt.click(function () {
          $('body,html').animate({
            scrollTop: 0
          }, 800);
          return false;
        });
      }
    };
  })(this));
//   $(window).load(function () {
//     //异步延迟加载样式
//     var link = $('<link />');
//     link.attr('href', 'https://fonts.googleapis.com/css?family=Dancing+Script|Noto+Sans+SC:300|Montserrat&display=swap');
//     link.attr('rel', 'stylesheet');
//     link.appendTo($('head'));
// });
</script>

<!-- 宠物 -->
<canvas id="live2dcanvas" width="200" height="400" class="live2d"></canvas>
<style>
  #live2dcanvas {
    position: fixed;
    right: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -40px;
    width: 200px;
    height: 400px;
  }

  @media (max-width: 768px) {
    #live2dcanvas {
      width: 150px;
      height: 300px;
    }
  }

  @media (max-width: 639px) {
    #live2dcanvas {
      display: none !important;
    }
  }
</style>
<script src="https://www.bwrong.cn/media/scripts/L2Dwidget.min.js"></script>
<script>
  //初始化小人物 需设置属性pluginRootPath: "live2dw/"指明资源跟路径
  L2Dwidget.init({
    pluginRootPath: "media/",//资源root路径
    pluginJsPath: "scripts/",//js相对root的路径
    pluginModelPath: "model/",//模型相对root的路径
    tagMode: !1,
    debug: !1,
    model: {
      scale: 2,
      jsonPath: "/media/model/live2d-widget-model-epsilon/Epsilon2.1.model.json"
    },
    display: {//大小位置什么的自己慢慢调就是了
      position: "right",//定位
      width: 130,//宽度
      height: 210,//高度
      hOffset: -40,//左右
      vOffset: 0//上下
    },
    mobile: {
      show: !1
    },
    log: !1
  });
</script>
<!-- 宠物结束 -->

		<script data-no-instant>
    // (function ($) {
    //     $.extend({
    //         adamsOverload: function () {
    //             $('.navigation:eq(0)').remove();
    //             $("").attr("rel" , "external");
    //             $("a[rel='external'],a[rel='external nofollow']").attr("target","_blank");
    //             $("a.vi").attr("rel" , "");
    //             $.viewImage({
    //                 'target'  : 'img',
    //                 'exclude' : '.vsmile-icons img,.gallery img',
    //                 'delay'   : 300
    //             });
    //             $.lately({
    //                 'target' : '.commentmetadata a,.infos time,.post-list time'
	// 			});
	// 			console.log(prettyPrint)
	// 			if(prettyPrint) prettyPrint();

    //             $('ul.links li a').each(function(){
    //                 if($(this).parent().find('.bg').length==0){
    //                     $(this).parent().append('<!---<div class="bg" style="background-image:url(https://c3.glgoo.top/s2/favicons?domain='+$(this).attr("href")+')"></div>--->')
    //                 }
    //             });
    //         }
    //     });
    // })(jQuery);
	// jQuery.adamsOverload();

    (function ($) {
        $.extend({
            adamsOverload: function () {
                $.viewImage({
                    'target'  : '.song img',
                    'exclude' : '.vsmile-icons img',
                    'delay'   : 300
                });
            }
        });
    })(jQuery);
    jQuery.adamsOverload();
</script>

</body>
</html>
