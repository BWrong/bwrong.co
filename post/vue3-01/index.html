
<!DOCTYPE html>
<html lang="zh-CN">
<head>
 <meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
<meta HTTP-EQUIV="pragma" CONTENT="no-cache">
<meta HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate">
<meta HTTP-EQUIV="expires" CONTENT="0">
<meta name="author" content="bwrong, wang11535041@qq.com"/>
<meta name="keywords" content="【Vue3】基础与入门 | BWrong的小站,前端,krpano,js,vue"/>
<meta name="description" content="天青色等烟雨，而我在等你"/>
<!-- <title>【Vue3】基础与入门 | BWrong的小站</title> -->
<title>网站搭建测试</title>
<link href="https://www.bwrong.cn/media/css/fz.css" rel="stylesheet">
<link rel="stylesheet" href="https://www.bwrong.cn/styles/main.css">
<script type="text/javascript">
function getCSS()
{
        datetoday = new Date();
        timenow=datetoday.getTime();
        datetoday.setTime(timenow);
        thehour = datetoday.getHours();

        if (thehour<5)

            display = "https://www.bwrong.cn/media/css/night.css";

       else if (thehour>20)

            display = "https://www.bwrong.cn/media/css/night.css";

        else if (thehour>5)
     
            display = "https://www.bwrong.cn/media/css/day.css";

        else if (thehour<20)

            display = "https://www.bwrong.cn/media/css/day.css";


var css = '<';
        css+='link rel="stylesheet" href='+display+' \/';
        css+='>';
        document.write(css);
}
</script>
<link href="https://at.alicdn.com/t/font_1306644_ko4c4at97is.css" rel="stylesheet" />
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://www.bwrong.cn/media/css/katex.min.css">
<script type='text/javascript' src='https://www.bwrong.cn/media/scripts/script.js'></script>
<link href="https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet" />
  <script src="https://cdn.bootcss.com/wow/1.1.2/wow.min.js"></script>
  <script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>wow=new WOW({boxClass:'wow',animateClass:'animated',offset:0,mobile:true,live:true});wow.init();</script>

<script type="text/javascript">
window.onload=getCSS();
</script>
<!-- 百度统计 -->
<script>
var _hmt = _hmt || [];
(function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?2c0e9e3f54ae20480b34c178578c4df8";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
})();
</script>


</head>
<body class="post-template-default single single-post postid-70 single-format-standard">
    <div id="wrapper">

	
<header id="header" class="site-header"
		
		style="background-image: linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2)),url(https://www.bwrong.cn/post-images/vue3-01.jpg)"
		
		>
			<div class="site-branding">
									<h1 class="site-title"><a href="https://www.bwrong.cn" rel="home">BWrong的小站</a></h1>

					<h2 class="site-description">天青色等烟雨，而我在等你</h2>

							</div>
			<nav id="nav-wrapper">
				<div class="container">
					<div class="nav-toggle">
						<div class="bars">
							<div class="bar"></div>
							<div class="bar"></div>
							<div class="bar"></div>
						</div>
					</div>
					<div class="clear"></div>
					<ul id="" class="dove">
		 

<li>

	
		<a href="/">
		  首页
		</a>
	  

    

<li>

	
		<a href="/archives/index.html">
		  归档
		</a>
	  

    

<li>

	
		<a href="/post/about/">
		  关于
		</a>
	  

    

</ul>
</li>

</ul>				</div>
			</nav>
						<div class="jingge">


    

    

<a  href="https://github.com/BWrong" target="_blank" ><i class="iconfont icon-github"></i></a>
 
    

    

    

    

<a  href="https://juejin.cn/user/3421335914820280" target="_blank" ><i class="iconfont icon-telegram"></i></a>
 
    

    

    

    

    

    
        </header>


		<div id="content" class="container">
			<div class="row">
	<div class="col-md-8 site-main">

<article id="post-70" class="post-70 post type-post status-publish format-standard hentry category-5 tag-10 tag-9 tag-11">



		<div class="entry-content">
			<h1 data-wow-delay="0.4s"  class="wow fadeInUp entry-title">【Vue3】基础与入门</h1>
<div class="entry-meta">
<div class="wow fadeInUp"  data-wow-delay="0.6s">
	<i class="iconfont icon-rili"> <time class="lately-a" datetime="2021-09-02 15:31:46" itemprop="datePublished" pubdate="">2021-09-02</time></i>
	          </div>

</span>

		</div>

			<div class="wow fadeInUp entry-summary song"  data-wow-delay="0.1s">
				<p>字数：7887， 阅读时间：40分钟，点击<a href="https://www.bwrong.cn/post/vue3-01/">阅读原文</a></p>
<figure data-type="image" tabindex="1"><img src="https://www.bwrong.cn/post-images/javascript-module.jpg" alt="" loading="lazy"></figure>
<p>从2013年12月8日发布第一个版本至今已，Vue已走过了快八个年头，你了解每个版本名字的意义吗？</p>
<table>
<thead>
<tr>
<th>版本号</th>
<th>名字</th>
<th>释义</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>V0.9</td>
<td>Animatrix</td>
<td>黑客帝国动画版</td>
<td>2014.2.25</td>
</tr>
<tr>
<td>V0.10</td>
<td>Blade Runner</td>
<td>银翼杀手</td>
<td>2014.3.23</td>
</tr>
<tr>
<td>V0.11</td>
<td>Cowboy Bebop</td>
<td>星际牛仔</td>
<td>2014.11.7</td>
</tr>
<tr>
<td>V0.12</td>
<td>Dragon Ball</td>
<td>龙珠</td>
<td>2015.6.12</td>
</tr>
<tr>
<td>V1.0</td>
<td>Evangelion</td>
<td>新世纪福音战士</td>
<td>2015.10.27</td>
</tr>
<tr>
<td>V2.0</td>
<td>Ghost in the Shell</td>
<td>攻壳机动队</td>
<td>2016.9.30</td>
</tr>
<tr>
<td>V2.1</td>
<td>Hunter X Hunter</td>
<td>全职猎人</td>
<td>2016.11.22</td>
</tr>
<tr>
<td>V2.2</td>
<td>Initial D</td>
<td>头文字D</td>
<td>2017.2.26</td>
</tr>
<tr>
<td>V2.3</td>
<td>JoJo's Bizarre Adventure</td>
<td>JoJo的奇妙冒险</td>
<td>2017.4.2</td>
</tr>
<tr>
<td>V2.4</td>
<td>Kill la Kill</td>
<td>斩服少女</td>
<td>2017.7.13</td>
</tr>
<tr>
<td><strong>V2.5</strong></td>
<td>Level E</td>
<td>灵异E接触</td>
<td>2017.10.13</td>
</tr>
<tr>
<td><strong>V2.6</strong></td>
<td>Macross</td>
<td>超时空要塞</td>
<td>2019.2.4</td>
</tr>
<tr>
<td>V3.0</td>
<td>One Piece</td>
<td>海贼王</td>
<td>2020.9.18</td>
</tr>
<tr>
<td>V3.1</td>
<td>Pluto</td>
<td>地上最强机器人</td>
<td>2021.6.8</td>
</tr>
<tr>
<td>V3.2</td>
<td>Quintessential Quintuplets</td>
<td>五等分的花嫁</td>
<td>2021.8.10</td>
</tr>
</tbody>
</table>
<p>原来每个版本的名字都是以漫画命名，那么这些动漫，你看过几部呢？</p>
<p>那么接下来我们就重点聊聊Vue3.0。</p>
<h1 id="缘起">缘起</h1>
<p>一个新工具的出现，一定是为了解决已有工具存在的问题。我们常常听说Vue不适合开发大型复杂的项目，一个根本原因是 Vue 现有的 API 迫使我们通过选项组织代码，但是有的时候通过逻辑关系组织代码更有意义。另一个原因是目前缺少一种简洁且低成本的机制来提取和重用多个组件之间的逻辑。</p>
<p>那么接下来我们就来看看2.0的问题，以及Vue3是如何来解决的。</p>
<h2 id="option式组织代码的缺陷">Option式组织代码的缺陷</h2>
<p>options式组织代码，同一个功能分散在各个option中，导致在开发时需要在data、methods、computed等option横跳。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/letwrong/Picture/raw/master/20210821095807.awebp" alt="option" loading="lazy"></figure>
<p>Vue3推出了CompositionApi，目的就是为了解决这个问题，它将分散在各个option中的逻辑组合到一起，下面我们对比看下：</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/letwrong/Picture/raw/master/20210821095754.awebp" alt="" loading="lazy"></figure>
<h2 id="mixin的问题">Mixin的问题</h2>
<p>对于复杂的功能，我们可能会想到使用Mixin来抽离到单独的文件。但是Mixin会有一些使用上的问题，比如命名冲突、属性来源不明确。</p>
<p>Vue3提出了Hooks的方式，可以将每个功能提取到hooks，一个hooks即是一个独立的函数，所以不会再有上述问题。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/letwrong/Picture/raw/master/20210821095749.awebp" alt="" loading="lazy"></figure>
<h2 id="typescript支持的不健全">TypeScript支持的不健全</h2>
<p>现在大型项目都会标配 TypeScript ，Vue 当前的 API 在集成 TypeScript 时遇到了不小的麻烦，其主要原因是 Vue 依靠一个简单的 <code>this</code> 上下文来暴露 property，我们现在使用 <code>this</code> 的方式是比较微妙的。（比如 <code>methods</code> 选项下的函数的 <code>this</code> 是指向组件实例的，而不是这个 <code>methods</code> 对象）。</p>
<p>换句话说，Vue 现有的 API 在设计之初没有照顾到类型推导，这使适配 TypeScript 变得复杂。</p>
<p>当前，大部分使用 TypeScript 的 Vue 开发者都在通过 <code>vue-class-component</code> 这个库将组件撰写为 TypeScript class (借助 decorator)。它必须依赖 decorator——一个在实现细节上存在许多未知数的非常不稳定的 stage 2 提案。基于它是有极大风险的。</p>
<p>Vue3中提出的方案更多地利用了天然对类型友好的普通变量与函数，完美享用类型推导，并且也不用做太多额外的类型标注。</p>
<p>这也同样意味着你写出的 JavaScript 代码几乎就是 TypeScript 的代码。即使是非 TypeScript 开发者也会因此得到更好的 IDE 类型支持而获益。</p>
<h2 id="更好的响应式和性能">更好的响应式和性能</h2>
<p>众所周知，Vue2的响应式是通过<code>Object.defineProperty</code> 是给对象的某个已存在的属性添加对应的 <code>getter</code> 和 <code>setter</code>，所以它只能监听这个属性值的变化，而不能去监听对象属性的新增和删除。在 Vue 2 的实现中，在组件初始化阶段把数据变成响应式时，遇到子属性仍然是对象的情况，会递归执行 <code>Object.defineProperty</code> 定义子对象的响应式，会有一些性能问题。而且还有一个常见的问题就是通过索引修改数组、为对象直接新增属性，并不会触发响应式更新机制。</p>
<p>而在Vue3中则使用了Proxy来实现响应式，其实并不是Proxy的本身的性能优于<code>Object.defineProperty</code>，其实恰恰相反。那么为什么还要选择Proxy呢？</p>
<p>因为 <code>Proxy</code> 本质上是对某个对象的劫持，这样它不仅仅可以监听对象某个属性值的变化，还可以监听对象属性的新增和删除。而且在实现响应式时，采用了延时处理的方式，当嵌套较深的对象时，只有在其属性被访问的时候才会处理属性的响应式，在性能上会有一定的提升。</p>
<h2 id="支持全局api-treeshaking">支持全局API Treeshaking</h2>
<p>Vue3重构了全局和局部的api，均采用ESModule的命名导出访问，支持tree-shaking，只打包使用到的功能，用户只为实际使用的功能买单，同时包体积的减少，也意味着性能的提升。</p>
<pre><code class="language-js">// vue2
import Vue from 'vue'

Vue.nextTick(() =&gt; {
  // 一些和DOM有关的东西
})

</code></pre>
<pre><code class="language-js">// vue3
import { nextTick } from 'vue'

nextTick(() =&gt; {
  // 一些和DOM有关的东西
})
</code></pre>
<p>以上就是Vue主要的变化，那么接下来我们就来看看有哪些新特性。</p>
<h1 id="新特性与变更">新特性与变更</h1>
<p>接下来我们主要看一下一些非兼容的重大变更：</p>
<h2 id="全局api">全局API</h2>
<ul>
<li>
<p>支持多个应用根实例，防止全局配置污染</p>
<pre><code class="language-js">// vue2
// 这会影响两个根实例
Vue.mixin({
  /* ... */
})
const app1 = new Vue({ el: '#app-1' })
const app2 = new Vue({ el: '#app-2' })
</code></pre>
<pre><code class="language-js">// vue3
import { createApp } from 'vue'

const app = createApp({})
app.mixin({
  /* ... */
})
</code></pre>
<p>一些其他全局Api的变更详情请查阅<a href="https://v3.cn.vuejs.org/guide/migration/global-api.html#%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%85%A8%E5%B1%80-api-createapp">全局 API</a>。</p>
</li>
<li>
<p>全局 API重构为可Treeshaking</p>
<pre><code class="language-js">import { nextTick } from 'vue'

nextTick(() =&gt; {
  // 一些和DOM有关的东西
})
// **** 受影响的API
// Vue.nextTick
// Vue.observable (用 Vue.reactive 替换)
// Vue.version
// Vue.compile (仅完整构建版本)
// Vue.set (仅兼容构建版本)
// Vue.delete (仅兼容构建版本)
</code></pre>
</li>
</ul>
<h2 id="模板和指令相关">模板和指令相关</h2>
<ul>
<li>更好用的<code>v-model</code></li>
</ul>
<p>替代原有的<code>v-model</code>和<code>v-bind.sync</code>修饰符，通过参数形式，支持使用多个<code>v-model</code>进行双向绑定。</p>
<pre><code class="language-html">&lt;!-- vue2 --&gt;
&lt;ChildComponent v-model=&quot;pageTitle&quot; :title.sync=&quot;title&quot;/&gt;
&lt;!-- 完整 --&gt;
&lt;ChildComponent :value=&quot;pageTitle&quot; @input=&quot;(title)=&gt; (pageTitle=title)&quot; :title=&quot;title&quot; @update:title=&quot;(title)=&gt; (title=title)&quot;/&gt;
</code></pre>
<pre><code class="language-html">&lt;!-- vue3 --&gt;
&lt;ChildComponent v-model=&quot;pageTitle&quot; v-modle:title=&quot;title&quot;/&gt;
&lt;!-- 完整 --&gt;
&lt;ChildComponent :model-value=&quot;pageTitle&quot; @update:modelValue=&quot;(title)=&gt; (pageTitle=title)&quot; :title=&quot;title&quot; @update:title=&quot;(title)=&gt; (title=title)&quot;/&gt;
</code></pre>
<ul>
<li><code>&lt;template v-for&gt;</code>的变化</li>
</ul>
<pre><code class="language-vue">&lt;!-- vue2 --&gt;
&lt;template v-for=&quot;item in list&quot;&gt;
  &lt;div :key=&quot;'heading-' + item.id&quot;&gt;...&lt;/div&gt;
  &lt;span :key=&quot;'content-' + item.id&quot;&gt;...&lt;/span&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="language-vue">&lt;!-- vue 3 --&gt;
&lt;template v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;
  &lt;div&gt;...&lt;/div&gt;
  &lt;span&gt;...&lt;/span&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li><code>v-bind</code> 合并顺序变化</li>
</ul>
<pre><code class="language-html">&lt;!-- vue2 --&gt;
&lt;div id=&quot;red&quot; v-bind=&quot;{ id: 'blue' }&quot;&gt;&lt;/div&gt;
&lt;!-- result --&gt;
&lt;div id=&quot;red&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-html">&lt;!-- vue3 --&gt;
&lt;div id=&quot;red&quot; v-bind=&quot;{ id: 'blue' }&quot;&gt;&lt;/div&gt;
&lt;!-- result --&gt;
&lt;div id=&quot;blue&quot;&gt;&lt;/div&gt;
</code></pre>
<ul>
<li>
<p>移除<code>v-on.native</code>修饰符</p>
<p>在以前的版本中，要将原生 DOM 监听器添加到子组件的根元素中，可以使用 <code>.native</code> 修饰符。</p>
</li>
</ul>
<pre><code class="language-html">&lt;!-- vue2 --&gt;
&lt;my-component
  v-on:close=&quot;handleComponentEvent&quot;
  v-on:click.native=&quot;handleNativeClickEvent&quot;
/&gt;
</code></pre>
<p>在vue3中，组件中<em>未</em>被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 <code>inheritAttrs: false</code>)</p>
<pre><code class="language-html">&lt;!-- vue3 --&gt;
&lt;my-component
  v-on:close=&quot;handleComponentEvent&quot;
  v-on:click=&quot;handleNativeClickEvent&quot;
/&gt;
&lt;script&gt;
  export default {
    emits: ['close']
  }
&lt;/script&gt;
</code></pre>
<ul>
<li>支持片段（多根节点）</li>
</ul>
<pre><code class="language-vue">&lt;!-- vue2 --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;header&gt;...&lt;/header&gt;
    &lt;main&gt;...&lt;/main&gt;
    &lt;footer&gt;...&lt;/footer&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>在vue2中，组件必须包含在某个元素内部，不支持多个根节点，这有时会给我们写样式带来烦恼，所以vue3中支持了多根节点。</p>
<pre><code class="language-vue">&lt;!-- vue3 --&gt;
&lt;template&gt;
  &lt;header&gt;...&lt;/header&gt;
  &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;
  &lt;footer&gt;...&lt;/footer&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li>新增Teleport传送门</li>
</ul>
<p>vue应用开发的核心就是组件编写，将 UI 和相关行为封装到组件中来构建 UI。但是有时组件模板的一部分逻辑上属于该组件，而从技术角度来看，最好将模板的这一部分移动到 DOM 中 Vue app 之外的其他位置。</p>
<p>比如最常见的模态窗，我们希望模态窗的逻辑存在于组件中，但在UI上，元素最好又挂载到DOM根节点（如body）上，方便我们进行css来定位。</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;div style=&quot;position: relative;&quot;&gt;
    &lt;h3&gt;Tooltips with Vue 3 Teleport&lt;/h3&gt;
    &lt;div&gt;
      &lt;modal-button&gt;&lt;/modal-button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="language-js">const app = Vue.createApp({});

app.component('modal-button', {
  template: `
    &lt;button @click=&quot;modalOpen = true&quot;&gt;
        Open full screen modal!
    &lt;/button&gt;

    &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt;
      &lt;div&gt;
        I'm a modal!
        &lt;button @click=&quot;modalOpen = false&quot;&gt;
          Close
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  `,
  data() {
    return {
      modalOpen: false
    }
  }
})
</code></pre>
<p>在上面的例子中，我们可以看到一个问题——模态框是在深度嵌套的 <code>div</code> 中渲染的，而模态框的 <code>position:absolute</code> 以父级相对定位的 <code>div</code> 作为引用，最终的效果会受父级定位的影响，这可能并不是我们期望的结果。</p>
<p>Teleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。</p>
<pre><code class="language-js">app.component('modal-button', {
  template: `
    &lt;button @click=&quot;modalOpen = true&quot;&gt;
        Open full screen modal! (With teleport!)
    &lt;/button&gt;

    &lt;teleport to=&quot;body&quot;&gt;
      &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt;
        &lt;div&gt;
          I'm a teleported modal!
          (My parent is &quot;body&quot;)
          &lt;button @click=&quot;modalOpen = false&quot;&gt;
            Close
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/teleport&gt;
  `,
  data() {
    return {
      modalOpen: false
    }
  }
})
</code></pre>
<h2 id="组件">组件</h2>
<ul>
<li>函数式组件</li>
</ul>
<p>在vue2中我们可能因为性能和多根节点的需求而使用函数式组件，当在vue3中，针对普通组件性能做了优化，已经和函数组件性能相差无几，而且也支持多根节点，因此函数式组件的使用场景不是很有必要了，所以针对函数式组件进行了一些调整：</p>
<pre><code class="language-vue">&lt;!-- Vue 2 函数式组件示例 --&gt;
&lt;script&gt;
export default {
  functional: true,
  props: ['level'],
  render(h, { props, data, children }) {
    return h(`h${props.level}`, data, children)
  }
}
&lt;/script&gt;

&lt;!-- Vue 2 函数式组件示例使用 &lt;template&gt; --&gt;
&lt;template functional&gt;
  &lt;component
    :is=&quot;`h${props.level}`&quot;
    v-bind=&quot;attrs&quot;
    v-on=&quot;listeners&quot;
  /&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  props: ['level']
}
&lt;/script&gt;
</code></pre>
<p>在vue3中删除了<code>functional option</code>和<code>functional attribute</code>,上面两种方式不能在vue3中使用了。</p>
<p>在vue3中函数式组件即是一个普通函数，接收两个参数：<code>props</code> 和 <code>context</code>。</p>
<pre><code class="language-js">// vue3
import { h } from 'vue'

const DynamicHeading = (props, context) =&gt; {
  return h(`h${props.level}`, context.attrs, context.slots)
}

DynamicHeading.props = ['level']

export default DynamicHeading
</code></pre>
<ul>
<li>创建异步组件</li>
</ul>
<p>以前可以通过返回一个Promise的函数来定义异步组件：</p>
<pre><code class="language-js">// vue2
const asyncModal = () =&gt; import('./Modal.vue');
// 或者带上配置
const asyncModal = {
  component: () =&gt; import('./Modal.vue'),
  delay: 200,
  timeout: 3000,
  error: ErrorComponent,
  loading: LoadingComponent
}
</code></pre>
<p>在vue3中，新增呢一个api（defineAsyncComponent）来显示定义异步组件。</p>
<pre><code class="language-js">// vue3
import { defineAsyncComponent } from 'vue'
import ErrorComponent from './components/ErrorComponent.vue'
import LoadingComponent from './components/LoadingComponent.vue'

// 不带选项的异步组件
const asyncModal = defineAsyncComponent(() =&gt; import('./Modal.vue'))

// 带选项的异步组件
const asyncModalWithOptions = defineAsyncComponent({
  loader: () =&gt; import('./Modal.vue'),
  delay: 200,
  timeout: 3000,
  errorComponent: ErrorComponent,
  loadingComponent: LoadingComponent
})
</code></pre>
<ul>
<li>新增<code>emits</code>选项，定义和验证发出的自定义事件</li>
</ul>
<pre><code class="language-vue">&lt;!-- vue2 --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;{{ text }}&lt;/p&gt;
    &lt;button v-on:click=&quot;$emit('accepted')&quot;&gt;OK&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    props: ['text']
  }
&lt;/script&gt;
</code></pre>
<p>vue3中增加了emits选项来显示定义组件的自定义事件，未声明 <code>emits</code> 的事件监听器都会被算入组件的 <code>$attrs</code> 并绑定在组件的根节点上。</p>
<pre><code class="language-vue">&lt;!-- vue3 --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;{{ text }}&lt;/p&gt;
    &lt;button v-on:click=&quot;$emit('accepted')&quot;&gt;OK&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    props: ['text'],
    emits: ['accepted']
  }
&lt;/script&gt;
</code></pre>
<p>emits还可以支持对自定义事件进行验证，只需要改为对象形式即可。</p>
<pre><code class="language-js">emits: {
    // 没有验证函数
    click: null,

    // 带有验证函数
    submit: payload =&gt; {
      if (payload.email &amp;&amp; payload.password) {
        return true
      } else {
        console.warn(`Invalid submit event payload!`)
        return false
      }
    }
  }
</code></pre>
<p>强烈建议使用 <code>emits</code> 记录每个组件所触发的所有事件，而且记录的事件会有代码提示。</p>
<h2 id="渲染函数">渲染函数</h2>
<ul>
<li>
<p>统一插槽API</p>
<p>以前，在组件中获取插槽是两个不同的api（<code>this.$scopedSlots</code> 和 <code>this.$slots</code>），现在统一使用<code>this.$slots</code>。</p>
</li>
<li>
<p>整合<code>$listeners</code>、class、style到<code>$attrs</code></p>
</li>
</ul>
<p>在vue2时，我们可以通过如下方式访问<code>attribute</code> 和事件监听器：</p>
<pre><code class="language-vue">&lt;!-- vue3 --&gt;
&lt;template&gt;
  &lt;label&gt;
    &lt;input type=&quot;text&quot; v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot; /&gt;
  &lt;/label&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    inheritAttrs: false
  }
&lt;/script&gt;
</code></pre>
<p>在 Vue 3 的虚拟 DOM 中，事件监听器现在只是以 <code>on</code> 为前缀的 attribute，这样就成了 <code>$attrs</code> 对象的一部分，因此 <code>$listeners</code> 被移除了。</p>
<pre><code class="language-vue">&lt;!-- vue3 --&gt;
&lt;template&gt;
  &lt;label&gt;
    &lt;input type=&quot;text&quot; v-bind=&quot;$attrs&quot; /&gt;
  &lt;/label&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  inheritAttrs: false
}
&lt;/script&gt;
</code></pre>
<p>在 Vue 2 的虚拟 DOM 实现中对 <code>class</code> 和 <code>style</code> attribute 有一些特殊处理。因此，它们<em>不</em>包含在 <code>$attrs</code> 中，Vue3中简化了这部分的处理，用<code>$attrs</code> 包含<em>所有的</em> attribute，包括<code>class</code>和<code>style</code>。</p>
<h2 id="自定义元素">自定义元素</h2>
<ul>
<li>只能在<code>&lt;component&gt;</code>元素中使用<code>is</code>prop</li>
</ul>
<p>在vue3中不能在普通组件和元素使用<code>is</code>属性，仅能在<code>component</code>内置组件中使用。</p>
<h2 id="其他">其他</h2>
<ul>
<li>
<p>生命周期变更</p>
<ul>
<li><code>destroyed</code> 生命周期选项被重命名为 <code>unmounted</code></li>
<li><code>beforeDestroy</code> 生命周期选项被重命名为 <code>beforeUnmount</code></li>
</ul>
</li>
<li>
<p>自定义指令生命周期调整，和组件生命周期统一</p>
<ul>
<li>created - 新的！在元素的 attribute 或事件侦听器应用之前调用。</li>
<li>bind → <strong>beforeMount</strong></li>
<li>inserted → <strong>mounted</strong></li>
<li><strong>beforeUpdate</strong>：新的！这是在元素本身更新之前调用的，很像组件生命周期钩子。</li>
<li>update → 移除！有太多的相似之处要更新，所以这是多余的，请改用 <code>updated</code>。</li>
<li>componentUpdated → <strong>updated</strong></li>
<li><strong>beforeUnmount</strong>：新的！与组件生命周期钩子类似，它将在卸载元素之前调用。</li>
<li>unbind -&gt; <strong>unmounted</strong></li>
</ul>
</li>
<li>
<p>Mixin 合并行为变更</p>
</li>
</ul>
<p>当来自组件的 <code>data()</code> 及其 mixin 或 extends 基类被合并时，现在将<em>浅层次</em>执行合并。</p>
<ul>
<li>过渡的class名更改</li>
</ul>
<p>过渡类名 <code>v-enter</code> 修改为 <code>v-enter-from</code>、过渡类名 <code>v-leave</code> 修改为 <code>v-leave-from</code>。</p>
<ul>
<li>
<p>VNode 生命周期事件变更</p>
<pre><code class="language-vue">&lt;!-- vue2 --&gt;
&lt;template&gt;
  &lt;child-component @hook:updated=&quot;onUpdated&quot;&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="language-vue">&lt;!-- vue3 --&gt;
&lt;template&gt;
  &lt;child-component @vnode-updated=&quot;onUpdated&quot;&gt;
&lt;/template&gt;
</code></pre>
</li>
</ul>
<h2 id="废弃的api">废弃的API</h2>
<ul>
<li><code>keyCode</code>作为<code>v-on</code>的修饰符及<code>config.keyCodes</code>配置。</li>
</ul>
<pre><code class="language-vue">&lt;!-- 键码版本（废弃） --&gt;
&lt;input v-on:keyup.13=&quot;submit&quot; /&gt;

&lt;!-- 别名版本 --&gt;
&lt;input v-on:keyup.enter=&quot;submit&quot; /&gt;

&lt;script&gt;
Vue.config.keyCodes = { // 废弃
  f1: 112
}
&lt;/script&gt;

</code></pre>
<ul>
<li><code>$on</code>，<code>$off</code> 和 <code>$once</code> 实例方法已被移除，组件实例不再实现事件触发接口</li>
</ul>
<p>在vue2中我们可以通过EventBus实现组件通信：</p>
<pre><code class="language-js">// eventBus.js
const eventBus = new Vue()
export default eventBus
</code></pre>
<pre><code class="language-js">// ChildComponent.vue
import eventBus from './eventBus'
export default {
  mounted() {
    // 添加 eventBus 监听器
    eventBus.$on('custom-event', () =&gt; {
      console.log('Custom event triggered!')
    })
  },
  beforeDestroy() {
    // 移除 eventBus 监听器
    eventBus.$off('custom-event')
  }
}
</code></pre>
<pre><code class="language-js">// ParentComponent.vue
import eventBus from './eventBus'
export default {
  methods: {
    callGlobalCustomEvent() {
      eventBus.$emit('custom-event') // 当 ChildComponent 被挂载，控制台中将显示一条消息
    }
  }
}
</code></pre>
<p>在vue3中，此方式不再有效，因为完全移除了 <code>$on</code>、<code>$off</code> 和 <code>$once</code> 方法。如果需要，可以使用一些实现了事件触发器接口的外部库，或者使用Provide，复杂的直接上Vuex就对了。</p>
<ul>
<li>不再支持过滤器</li>
</ul>
<pre><code class="language-vue">&lt;!-- vue2 --&gt;
&lt;template&gt;
  &lt;h1&gt;Bank Account Balance&lt;/h1&gt;
  &lt;p&gt;{{ accountBalance | currencyUSD }}&lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    props: {
      accountBalance: {
        type: Number,
        required: true
      }
    },
    filters: {
      currencyUSD(value) {
        return '$' + value
      }
    }
  }
&lt;/script&gt;
</code></pre>
<p>在vue3中可以使用方法或者计算属性替代：</p>
<pre><code class="language-vue">&lt;!-- vue3 --&gt;
&lt;template&gt;
  &lt;h1&gt;Bank Account Balance&lt;/h1&gt;
  &lt;p&gt;{{ accountInUSD }}&lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    props: {
      accountBalance: {
        type: Number,
        required: true
      }
    },
    computed: {
      accountInUSD() {
        return '$' + this.accountBalance
      }
    }
  }
&lt;/script&gt;
</code></pre>
<ul>
<li>
<p>删除<code>$children</code>property</p>
<p><code>$children</code> property 已移除，不再支持。如果你需要访问子组件实例，我们建议使用 <a href="https://v3.cn.vuejs.org/guide/component-template-refs.html#%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8">$refs</a>。</p>
</li>
<li>
<p>全局函数 <code>set</code> 和 <code>delete</code> 以及实例方法 <code>$set</code> 和 <code>$delete</code>。基于代理的变化检测不再需要它们了。</p>
</li>
</ul>
<p>当然，上面的只是开胃菜，接下来的才是我们最值得关注的新特性。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/letwrong/Picture/raw/master/20210823173734.jpg" alt="" loading="lazy"></figure>
<h1 id="组合式api">组合式Api</h1>
<p>为了解决我们前面说的逻辑复用和代码组织的问题，vue3推出了新的代码编写方式，这个vue3最重要的特性，也是未来编写vue的主要趋势。</p>
<p>下面是一个显示某个用户的仓库列表的视图，同时带有搜索和筛选功能，伪代码如下：</p>
<pre><code class="language-js">// src/components/UserRepositories.vue

export default {
  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },
  props: {
    user: {
      type: String,
      required: true
    }
  },
  data () {
    return {
      repositories: [], // 1
      filters: { ... }, // 3
      searchQuery: '' // 2
    }
  },
  computed: {
    filteredRepositories () { ... }, // 3
    repositoriesMatchingSearchQuery () { ... }, // 2
  },
  watch: {
    user: 'getUserRepositories' // 1
  },
  methods: {
    getUserRepositories () {
      // 使用 `this.user` 获取用户仓库
    }, // 1
    updateFilters () { ... }, // 3
  },
  mounted () {
    this.getUserRepositories() // 1
  }
}
</code></pre>
<p>可以看到，按option组织代码，功能逻辑点是碎片化的分散在各个组件选项中，特别是遇到一些内容较多的组件，需要在各个选项中反复跳转，阅读和书写代码将是一件非常痛苦的事情，大大降低了组件的可维护性。</p>
<p>其实，在开发和阅读组件代码的时候，我们更多是关注的功能点，而不是去关注用了那些options，这正是组合式api解决的问题。</p>
<pre><code class="language-js">// src/composables/useUserRepositories.js

import { fetchUserRepositories } from '@/api/repositories'
import { ref, onMounted, watch } from 'vue'

export default function useUserRepositories(user) {
  const repositories = ref([])
  const getUserRepositories = async () =&gt; {
    repositories.value = await fetchUserRepositories(user.value)
  }

  onMounted(getUserRepositories)
  watch(user, getUserRepositories)

  return {
    repositories,
    getUserRepositories
  }
}
</code></pre>
<pre><code class="language-js">// src/composables/useRepositoryNameSearch.js

import { ref, computed } from 'vue'

export default function useRepositoryNameSearch(repositories) {
  const searchQuery = ref('')
  const repositoriesMatchingSearchQuery = computed(() =&gt; {
    return repositories.value.filter(repository =&gt; {
      return repository.name.includes(searchQuery.value)
    })
  })

  return {
    searchQuery,
    repositoriesMatchingSearchQuery
  }
}
</code></pre>
<pre><code class="language-js">// src/components/UserRepositories.vue
import { toRefs } from 'vue'
import useUserRepositories from '@/composables/useUserRepositories'
import useRepositoryNameSearch from '@/composables/useRepositoryNameSearch'
import useRepositoryFilters from '@/composables/useRepositoryFilters'

export default {
  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },
  props: {
    user: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const { user } = toRefs(props)

    const { repositories, getUserRepositories } = useUserRepositories(user)

    const {
      searchQuery,
      repositoriesMatchingSearchQuery
    } = useRepositoryNameSearch(repositories)

    const {
      filters,
      updateFilters,
      filteredRepositories
    } = useRepositoryFilters(repositoriesMatchingSearchQuery)

    return {
      // 因为我们并不关心未经过滤的仓库
      // 我们可以在 `repositories` 名称下暴露过滤后的结果
      repositories: filteredRepositories,
      getUserRepositories,
      searchQuery,
      filters,
      updateFilters
    }
  }
}
</code></pre>
<p>组合式API分离了组件的逻辑关注点，更具组织性，代码的可读性和可维护性也更好。而且可以将可复用的逻辑抽离成Hooks，具有更好的可复用性。</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/letwrong/Picture/raw/master/20210824102437.png" alt="" loading="lazy"></figure>
<p>由于组合式API的特殊性，需要使用新的API，接下来我们就来看看这些API。</p>
<h2 id="setup">setup</h2>
<p>setup是组合式API的入口，所有的内容都需要包含在其中，它仅在组件创建<strong>之前</strong>执行<strong>一次</strong>，所以此时this并不是指向当前组件实例。</p>
<pre><code class="language-js">setup(props,context){
  const { attrs, slots, emit } = context;
	// ...
}
</code></pre>
<h3 id="参数">参数</h3>
<ul>
<li><code>{Data} props</code>：接收到的props数据，是响应式的。</li>
<li><code>{SetupContext} context</code>：一个对象，包含组件需要的上下文信息，包含<code>attrs</code>、<code>slots</code>、<code>emit</code>。</li>
</ul>
<h3 id="返回值">返回值</h3>
<ul>
<li>如果返回一个对象，那么该对象的 property 以及传递给 <code>setup</code> 的 <code>props</code> 参数中的 property 就都可以在模板中访问到。</li>
</ul>
<pre><code class="language-vue">&lt;!-- MyBook.vue --&gt;
&lt;template&gt;
  &lt;div&gt;{{ collectionName }}: {{ readersNumber }} {{ book.title }}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import { ref, reactive } from 'vue'

  export default {
    props: {
      collectionName: String
    },
    setup(props) {
      const readersNumber = ref(0)
      const book = reactive({ title: 'Vue 3 Guide' })

      // 暴露给 template
      return {
        readersNumber,
        book
      }
    }
  }
&lt;/script&gt;
</code></pre>
<ul>
<li>如果返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态。</li>
</ul>
<pre><code class="language-js">// MyBook.vue

import { h, ref, reactive } from 'vue'

export default {
  setup() {
    const readersNumber = ref(0)
    const book = reactive({ title: 'Vue 3 Guide' })
    // 请注意这里我们需要显式调用 ref 的 value
    return () =&gt; h('div', [readersNumber.value, book.title])
  }
}
</code></pre>
<h2 id="生命周期钩子">生命周期钩子</h2>
<p>为了使组合式 API 的功能和选项式 API 一样完整，我们还需要一种在 <code>setup</code> 中注册生命周期钩子的方法。组合式 API 上的生命周期钩子与选项式 API 的名称相同，但前缀为 <code>on</code>：即 <code>mounted</code> 看起来会像 <code>onMounted</code>。</p>
<pre><code class="language-js">import { onMounted, onUpdated, onUnmounted } from 'vue'

const MyComponent = {
  setup() {
    onMounted(() =&gt; {
      console.log('mounted!')
    })
    onUpdated(() =&gt; {
      console.log('updated!')
    })
    onUnmounted(() =&gt; {
      console.log('unmounted!')
    })
  }
}
</code></pre>
<p>setup代替了<code>beforeCreate</code>和<code>created</code>，对比如下：</p>
<table>
<thead>
<tr>
<th>选项式 API</th>
<th>Hook inside <code>setup</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>beforeCreate</code></td>
<td>Not needed*</td>
</tr>
<tr>
<td><code>created</code></td>
<td>Not needed*</td>
</tr>
<tr>
<td><code>beforeMount</code></td>
<td><code>onBeforeMount</code></td>
</tr>
<tr>
<td><code>mounted</code></td>
<td><code>onMounted</code></td>
</tr>
<tr>
<td><code>beforeUpdate</code></td>
<td><code>onBeforeUpdate</code></td>
</tr>
<tr>
<td><code>updated</code></td>
<td><code>onUpdated</code></td>
</tr>
<tr>
<td><code>beforeUnmount</code></td>
<td><code>onBeforeUnmount</code></td>
</tr>
<tr>
<td><code>unmounted</code></td>
<td><code>onUnmounted</code></td>
</tr>
<tr>
<td><code>errorCaptured</code></td>
<td><code>onErrorCaptured</code></td>
</tr>
<tr>
<td><code>renderTracked</code></td>
<td><code>onRenderTracked</code></td>
</tr>
<tr>
<td><code>renderTriggered</code></td>
<td><code>onRenderTriggered</code></td>
</tr>
<tr>
<td><code>activated</code></td>
<td><code>onActivated</code></td>
</tr>
<tr>
<td><code>deactivated</code></td>
<td><code>onDeactivated</code></td>
</tr>
</tbody>
</table>
<h2 id="响应式">响应式</h2>
<p>在vue3中，使用了<code>Proxy</code>代替了<code>Object.defineProperty</code>，使 Vue 3 避免了 Vue 早期版本中存在的一些响应性问题。</p>
<p>当我们从一个组件的 <code>data</code> 函数中返回一个普通的 JavaScript 对象时，Vue 会将该对象包裹在一个带有 <code>get</code> 和 <code>set</code> 处理程序的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> 中。</p>
<p>举个🌰：</p>
<pre><code class="language-js">const dinner = {
  meal: 'tacos'
}

const handler = {
  get(target, property, receiver) { // 捕捉器
    track(target, property)  // 跟踪property读取，收集依赖
    return Reflect.get(...arguments) // Reflect将this绑定到Proxy
  },
  set(target, property, value, receiver) {
    trigger(target, property) // 执行副作用依赖项
    return Reflect.set(...arguments)
  }
}

const proxy = new Proxy(dinner, handler)
console.log(proxy.meal)

// tacos
</code></pre>
<ol>
<li><strong>当一个值被读取时进行追踪</strong>：proxy 的 <code>get</code> 处理函数中 <code>track</code> 函数记录了该 property 和当前副作用。</li>
<li><strong>当某个值改变时进行检测</strong>：在 proxy 上调用 <code>set</code> 处理函数。</li>
<li><strong>重新运行代码来读取原始值</strong>：<code>trigger</code> 函数查找哪些副作用依赖于该 property 并执行它们。</li>
</ol>
<p>该被代理的对象对于用户来说是不可见的，但是在内部，它们使 Vue 能够在 property 的值被访问或修改的情况下进行依赖跟踪和变更通知。</p>
<p>那么组件是如何让渲染响应数据变化的呢？</p>
<p>组件的模板会被编译成一个 <a href="https://v3.cn.vuejs.org/guide/render-function.html"><code>render</code></a> 函数，它用来创建 <a href="https://v3.cn.vuejs.org/guide/render-function.html#%E8%99%9A%E6%8B%9F-dom-%E6%A0%91">VNodes</a>，描述该组件应该如何被渲染。这个render函数被包裹在一个副作用中，允许 Vue 在运行时跟踪被“触达”的 property，当property变化的时候，就会执行对应的副作用，从而执行render重新渲染。当然在渲染并不会整个重新渲染，这里有一些优化手段，网上资料很多，这里不展开讲。</p>
<p>接下来我们看看几个常用的响应式API。</p>
<h3 id="ref">ref</h3>
<pre><code class="language-ts">interface Ref&lt;T&gt; {
  value: T
}
function ref&lt;T&gt;(value: T): Ref&lt;T&gt;
</code></pre>
<p>接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property <code>.value</code>。</p>
<pre><code class="language-js">import { ref } from 'vue'

const counter = ref&lt;number&gt;(0)

console.log(counter) // { value: 0 }
console.log(counter.value) // 0

counter.value++
console.log(counter.value) // 1
</code></pre>
<p>因为在 JavaScript 中，<code>Number</code> 或 <code>String</code> 等基本类型是通过值而非引用传递的，在任何值周围都有一个封装对象，这样我们就可以在整个应用中安全地传递它，而不必担心在某个地方失去它的响应性。</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/letwrong/Picture/raw/master/20210824224551.gif" alt="pass-by-reference-vs-pass-by-value-animation" loading="lazy"></figure>
<p><em>注意：ref嵌套在响应式对象（如reactive、readonly）或者用在模板中，将自动解包</em>。</p>
<h3 id="reactive">reactive</h3>
<pre><code class="language-ts">function reactive&lt;T extends object&gt;(target: T): UnwrapNestedRefs&lt;T&gt;
</code></pre>
<p>返回对象的响应式副本，即一个深层递归转换的proxy对象。</p>
<pre><code class="language-js">import { reactive } from 'vue'
interface IState{
  count:number
}
// state 现在是一个响应式的状态
const state = reactive&lt;IState&gt;({
  count: 0,
})
</code></pre>
<p><strong>ref和reactive</strong>：</p>
<ul>
<li>一般基础数据类型使用ref，对象使用reactive</li>
<li>如果将对象分配为 ref 值，则通过 <a href="https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive">reactive</a> 方法使该对象具有高度的响应式。</li>
</ul>
<h3 id="readonly">readonly</h3>
<p>接受一个对象 (响应式或纯对象) 或 <a href="https://v3.cn.vuejs.org/api/refs-api.html#ref">ref</a> 并返回原始对象的只读代理。只读代理是深层的：任何被访问的嵌套 property 也是只读的。</p>
<pre><code class="language-js">const original = reactive({ count: 0 })

const copy = readonly(original)

watchEffect(() =&gt; {
  // 用于响应性追踪
  console.log(copy.count)
})

// 变更 original 会触发依赖于副本的侦听器
original.count++

// 变更副本将失败并导致警告
copy.count++ // 警告!
</code></pre>
<h3 id="unref">unref</h3>
<p>如果参数是一个 <a href="https://v3.cn.vuejs.org/api/refs-api.html#ref"><code>ref</code></a>，则返回内部值，否则返回参数本身。这是 <code>val = isRef(val) ? val.value : val</code> 的语法糖函数。</p>
<pre><code class="language-ts">function useFoo(x: number | Ref&lt;number&gt;) {
  const unwrapped = unref(x) // unwrapped 现在一定是数字类型
}
</code></pre>
<h3 id="toref">toRef</h3>
<p>可以用来为源响应式对象上的某个 property 新创建一个 <a href="https://v3.cn.vuejs.org/api/refs-api.html#ref"><code>ref</code></a>,它会保持对其源 property 的响应式连接。</p>
<pre><code class="language-js">const state = reactive({
  foo: 1,
  bar: 2
})

const fooRef = toRef(state, 'foo')

fooRef.value++
console.log(state.foo) // 2

state.foo++
console.log(fooRef.value) // 3
</code></pre>
<h3 id="torefs">toRefs</h3>
<p>将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 <a href="https://v3.cn.vuejs.org/api/refs-api.html#ref"><code>ref</code></a>。</p>
<pre><code class="language-js">function useFeatureX() {
  const state = reactive({
    foo: 1,
    bar: 2
  })

  // 操作 state 的逻辑

  // 返回时转换为ref
  return toRefs(state)
}

export default {
  setup() {
    // 可以在不失去响应性的情况下解构
    const { foo, bar } = useFeatureX()

    return {
      foo,
      bar
    }
  }
}
</code></pre>
<p>要识别数据是否使用上述api处理过，可以使用这些api：isRef<code>、</code>isProxy<code>、</code>isReactive<code>、</code>isReadonly`。</p>
<h3 id="computed">computed</h3>
<pre><code class="language-ts">// 只读的
function computed&lt;T&gt;(
  getter: () =&gt; T,
  debuggerOptions?: DebuggerOptions
): Readonly&lt;Ref&lt;Readonly&lt;T&gt;&gt;&gt;

// 可写的
function computed&lt;T&gt;(
  options: {
    get: () =&gt; T
    set: (value: T) =&gt; void
  },
  debuggerOptions?: DebuggerOptions
): Ref&lt;T&gt;
interface DebuggerOptions {
  onTrack?: (event: DebuggerEvent) =&gt; void
  onTrigger?: (event: DebuggerEvent) =&gt; void
}
interface DebuggerEvent {
  effect: ReactiveEffect
  target: any
  type: OperationTypes
  key: string | symbol | undefined
}
</code></pre>
<ul>
<li>接受一个 getter 函数，并根据 getter 的返回值返回一个不可变的响应式 <a href="https://v3.cn.vuejs.org/api/refs-api.html#ref">ref</a> 对象。</li>
</ul>
<pre><code class="language-js">const count = ref(1)
const plusOne = computed(() =&gt; count.value + 1)

console.log(plusOne.value) // 2

plusOne.value++ // 错误
</code></pre>
<ul>
<li>接受一个具有 <code>get</code> 和 <code>set</code> 函数的对象，用来创建可写的 ref 对象。</li>
</ul>
<pre><code class="language-js">const count = ref(1)
const plusOne = computed({
  get: () =&gt; count.value + 1,
  set: val =&gt; {
    count.value = val - 1
  }
})

plusOne.value = 1
console.log(count.value) // 0
</code></pre>
<h3 id="watcheffect">watchEffect</h3>
<pre><code class="language-ts">function watchEffect(
  effect: (onInvalidate: InvalidateCbRegistrator) =&gt; void,
  options?: WatchEffectOptions
): StopHandle

interface WatchEffectOptions {
  flush?: 'pre' | 'post' | 'sync' // 默认：'pre'
  onTrack?: (event: DebuggerEvent) =&gt; void
  onTrigger?: (event: DebuggerEvent) =&gt; void
}

interface DebuggerEvent {
  effect: ReactiveEffect
  target: any
  type: OperationTypes
  key: string | symbol | undefined
}

type InvalidateCbRegistrator = (invalidate: () =&gt; void) =&gt; void

type StopHandle = () =&gt; void
</code></pre>
<p>立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p>
<pre><code class="language-js">const count = ref(0)

watchEffect(() =&gt; console.log(count.value))
// -&gt; logs 0

setTimeout(() =&gt; {
  count.value++
  // -&gt; logs 1
}, 100)
</code></pre>
<ul>
<li>停止侦听</li>
</ul>
<p>当 <code>watchEffect</code> 在组件的 <a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup()</a> 函数或<a href="https://v3.cn.vuejs.org/guide/composition-api-lifecycle-hooks.html">生命周期钩子</a>被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。当然也可以显式调用返回值以停止侦听：</p>
<pre><code class="language-js">const stop = watchEffect(() =&gt; {
  /* ... */
})
// later
stop()
</code></pre>
<ul>
<li>清除副作用</li>
</ul>
<p>有时副作用函数会执行一些异步的副作用，这些响应需要在其失效时清除。所以侦听副作用传入的函数可以接收一个 <code>onInvalidate</code> 函数作入参，用来注册清理失效时的回调。当以下情况发生时，这个失效回调会被触发：</p>
<ol>
<li>
<p>副作用即将重新执行时</p>
</li>
<li>
<p>侦听器被停止 (如果在 <code>setup()</code> 或生命周期钩子函数中使用了 <code>watchEffect</code>，则在组件卸载时)</p>
</li>
</ol>
<pre><code class="language-js">watchEffect(onInvalidate =&gt; {
  const token = performAsyncOperation(id.value)
  onInvalidate(() =&gt; {
    // id has changed or watcher is stopped.
    // invalidate previously pending async operation
    token.cancel()
  })
})
</code></pre>
<p>另外可以使用flush option或者watchPostEffect<code>和</code>watchSyncEffect来调整其刷新时机。</p>
<h3 id="watch">watch</h3>
<pre><code class="language-ts">// 侦听单一源
function watch&lt;T&gt;(
  source: WatcherSource&lt;T&gt;,
  callback: (
    value: T,
    oldValue: T,
    onInvalidate: InvalidateCbRegistrator
  ) =&gt; void,
  options?: WatchOptions
): StopHandle

// 侦听多个源
function watch&lt;T extends WatcherSource&lt;unknown&gt;[]&gt;(
  sources: T
  callback: (
    values: MapSources&lt;T&gt;,
    oldValues: MapSources&lt;T&gt;,
    onInvalidate: InvalidateCbRegistrator
  ) =&gt; void,
  options? : WatchOptions
): StopHandle

type WatcherSource&lt;T&gt; = Ref&lt;T&gt; | (() =&gt; T)

type MapSources&lt;T&gt; = {
  [K in keyof T]: T[K] extends WatcherSource&lt;infer V&gt; ? V : never
}

// 参见 `watchEffect` 共享选项的类型声明
interface WatchOptions extends WatchEffectOptions {
  immediate?: boolean // 默认：false
  deep?: boolean
}
</code></pre>
<p><code>watch</code> 需要侦听特定的数据源，并在单独的回调函数中执行副作用。默认情况下，它也是惰性的——即回调仅在侦听源发生变化时被调用。</p>
<ul>
<li>与 <a href="https://v3.cn.vuejs.org/api/computed-watch-api.html#watcheffect">watchEffect</a> 相比，<code>watch</code> 允许我们：
<ul>
<li>惰性地执行副作用；</li>
<li>更具体地说明应触发侦听器重新运行的状态；</li>
<li>访问被侦听状态的先前值和当前值。</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 侦听一个 getter
const state = reactive({ count: 0 })
watch(
  () =&gt; state.count,
  (count, prevCount) =&gt; {
    /* ... */
  }
)

// 直接侦听一个 ref
const count = ref(0)
watch(count, (count, prevCount) =&gt; {
  /* ... */
})
</code></pre>
<pre><code class="language-js">watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =&gt; {
  /* ... */
})
</code></pre>
<p>当然，前面只是介绍了常用的API，更多的请查看<a href="https://v3.cn.vuejs.org/api/reactivity-api.html">响应式API</a>。</p>
<h2 id="弊端">弊端</h2>
<p>当然组合式API也并不是银弹，至少目前来说不是，还是存在一些问题。</p>
<ul>
<li>Ref 的心智负担</li>
</ul>
<p>读写ref必须带上.value，语法冗余，目前还没有确定的方案来解决此问题。不过尤大给出了refSuger2提案，就看后续社区认可度怎么样了。</p>
<pre><code class="language-js">&lt;script setup&gt;
  // declaring a variable that compiles to a ref
  let count = $ref(1)

  console.log(count) // 1

  function inc() {
    // the variable can be used like a plain value
    count++
  }
&lt;/script&gt;

&lt;template&gt;
  &lt;button @click=&quot;inc&quot;&gt;{{ count }}&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li><s>难看冗长的返回语句</s></li>
</ul>
<p><code>setup()</code> 的返回语句变得冗长，像是重复劳动，而且还是存在代码上下横跳问。</p>
<p>在vue3.2提供了SetupScript语法糖，就没有这个问题了。</p>
<ul>
<li>需要更多的自我克制</li>
</ul>
<p>虽然组合式 API 在代码组织方面提供了更多的灵活性，但它也需要开发人员更多地自我克制来 “正确地完成它”。也有些人担心 API 会让没有经验的人编写出面条代码。换句话说，虽然组合式 API 提高了代码质量的上限，但它也降低了下限。</p>
<p>我们需要更多的考虑如何合理的组织代码，推荐根据逻辑关注点将程序分解成函数和模块来组织它。</p>
<h2 id="setupscript">SetupScript</h2>
<p><code>&lt;script setup&gt;</code> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。相比于普通的 <code>&lt;script&gt;</code> 语法，它具有更多优势：</p>
<ul>
<li>更少的样板内容，更简洁的代码。</li>
<li>能够使用纯 Typescript 声明 props 和发出事件。</li>
<li>更好的运行时性能 (其模板会被编译成与其同一作用域的渲染函数，没有任何的中间代理)。</li>
<li>更好的 IDE 类型推断性能 (减少语言服务器从代码中抽离类型的工作)。</li>
</ul>
<pre><code class="language-vue">&lt;script setup&gt;
// 导入
import { capitalize } from './helpers'
// 组件
import MyComponent from './MyComponent.vue'
// 变量
const msg = 'Hello!'

// 函数
function log() {
  console.log(msg)
}

&lt;/script&gt;

&lt;template&gt;
  &lt;div @click=&quot;log&quot;&gt;{{ msg }}&lt;/div&gt;
  &lt;div&gt;{{ capitalize('hello') }}&lt;/div&gt;
  &lt;MyComponent /&gt;
&lt;/template&gt;
</code></pre>
<p>上面<code>&lt;script setup&gt;</code>中的代码会被编译成组件<code>setup()</code>函数的内容，不同的是<code>&lt;script setup&gt;</code> 中的代码会在每次组件实例被创建的时候执行。而且所有<strong>顶层</strong>的绑定 (包括变量，函数声明，以及 import 引入的内容) 都会暴露给模板，可以直接使用，甚至连组件都无需手动注册。</p>
<p>在继续下面的内容前，我们来看一个词<strong>编译器宏</strong>，他们不需要导入，且会在处理 <code>&lt;script setup&gt;</code> 的时候被编译处理掉。<code>&lt;script setup&gt;</code>提供了如下几个编译器宏：</p>
<pre><code class="language-markdown">- defineProps
- defineEmits
- defineExpose
- withDefaults
</code></pre>
<p>接下来看一下<code>&lt;script setup&gt;</code>独有的API：</p>
<ul>
<li><code>defineProps</code>声明Props，接收<code>props</code>选项相同的值</li>
</ul>
<pre><code class="language-js">const props = defineProps({
  foo: {
    type:String,
    default:''
  }
})
</code></pre>
<p>如果使用了TypeScript，也可以使用纯类型声明来声明Props。</p>
<pre><code class="language-ts">// 普通
const props = defineProps&lt;{
  foo: string
  bar?: number
}&gt;()


// 默认值
interface Props {
  msg?: string
  labels?: string[]
}

const props = withDefaults(defineProps&lt;Props&gt;(), {
  msg: 'hello',
  labels: () =&gt; ['one', 'two']
})
</code></pre>
<ul>
<li><code>defineEmits</code>声明emits，接收 <code>emits</code> 选项相同的值</li>
</ul>
<pre><code class="language-ts">// 普通
const emit = defineEmits(['change', 'delete'])
// TS类型声明
const emit = defineEmits&lt;{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}&gt;()
</code></pre>
<ul>
<li><code>defineExpose</code>声明暴露的绑定</li>
</ul>
<p>使用 <code>&lt;script setup&gt;</code> 的组件是<strong>默认关闭</strong>的，也即通过模板 ref 或者 <code>$parent</code> 链获取到的组件的公开实例，不会暴露任何在 <code>&lt;script setup&gt;</code> 中声明的绑定。需要开发者明确声明暴露的属性。</p>
<pre><code class="language-js">&lt;script setup&gt;
import { ref } from 'vue'

const a = 1
const b = ref(2)

defineExpose({
  a,
  b
})
&lt;/script&gt;
</code></pre>
<ul>
<li><code>useSlots</code> 和 <code>useAttrs</code>分别对应<code>setupContext.slots</code> 和 <code>setupContext.attrs</code>，也可以在普通的组合式 API 中使用。</li>
</ul>
<pre><code class="language-vue">&lt;script setup&gt;
import { useSlots, useAttrs } from 'vue'

const slots = useSlots()
const attrs = useAttrs()
&lt;/script&gt;
</code></pre>
<p>目前还有一些事情是 <code>&lt;script setup&gt;</code>不能做到的，就需要和普通的<code>&lt;script&gt;</code>一起使用:</p>
<pre><code class="language-vue">&lt;script&gt;
// 普通 &lt;script&gt;, 在模块范围下执行(只执行一次)
runSideEffectOnce()

// 声明额外的选项
export default {
  inheritAttrs: false,
  customOptions: {}
}
&lt;/script&gt;

&lt;script setup&gt;
// 在 setup() 作用域中执行 (对每个实例皆如此)
&lt;/script&gt;
</code></pre>
<p>更多内容请查看<a href="https://v3.cn.vuejs.org/api/sfc-script-setup.html">SetupScript</a>。</p>
<h1 id="其他-2">其他</h1>
<ul>
<li>
<p><a href="https://v3.cn.vuejs.org/api/sfc-style.html">Style新特性</a></p>
<ul>
<li>选择器</li>
</ul>
<pre><code class="language-css">/* 深度选择器 */
.a :deep(.b) {
  /* ... */
}

/* 插槽选择器 */
:slotted(div) {
  color: red;
}

/* 全局选择器 */
:global(.red) {
  color: red;
}
</code></pre>
<ul>
<li><code>&lt;style module&gt;</code></li>
</ul>
</li>
</ul>
<pre><code class="language-vue">&lt;template&gt;
  &lt;p :class=&quot;$style.red&quot;&gt;
    This should be red
  &lt;/p&gt;
&lt;/template&gt;

&lt;style module&gt;
.red {
  color: red;
}
&lt;/style&gt;
</code></pre>
<p>也可以自定义注入的名称：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;p :class=&quot;classes.red&quot;&gt;red&lt;/p&gt;
&lt;/template&gt;

&lt;style module=&quot;classes&quot;&gt;
.red {
  color: red;
}
&lt;/style&gt;
</code></pre>
<p>我们可以在组合API中通过<a href="https://v3.cn.vuejs.org/api/global-api.html#usecssmodule"><code>useCssModule</code></a>来使用：</p>
<pre><code class="language-js">// 默认, 返回 &lt;style module&gt; 中的类
useCssModule()

// 命名, 返回 &lt;style module=&quot;classes&quot;&gt; 中的类
useCssModule('classes')
</code></pre>
<p>使用状态驱动的动态 CSS：</p>
<pre><code class="language-vue">&lt;script setup&gt;
const theme = {
  color: 'red'
}
&lt;/script&gt;

&lt;template&gt;
  &lt;p&gt;hello&lt;/p&gt;
&lt;/template&gt;

&lt;style scoped&gt;
p {
  color: v-bind('theme.color');
}
&lt;/style&gt;
</code></pre>
<ul>
<li>关注<a href="https://github.com/vuejs/rfcs">RFCS</a>，回溯历史，洞悉未来</li>
</ul>

							</div>
	<div class="wow fadeInUp vt-post-tags">
 
				<a href="https://www.bwrong.cn/tag/1n1RvVqS8/" rel="tag">vue3</a>
				 
				<a href="https://www.bwrong.cn/tag/vue/" rel="tag">vue</a>
				 
					</div>
<nav class="navigation3 post-navigation3" role="navigation">

		<div class="nav-links3">
      
		<div class="wow fadeInUp nav-previous3"><a href="https://www.bwrong.cn/post/vue3-2/" rel="prev"> 【Vue3】实用指南</a></div>
		 
		 
		<div class="wow fadeInUp nav-next3"><a href="https://www.bwrong.cn/post/dev-tools07/" rel="next"> 【前端工程化】篇七 沧海遗珠-其他工具</a></div>
		
		</div>
	</nav>
	<div class="wow fadeInUp author-info">
	<div class="author-avatar pull-left"><img src="https://www.bwrong.cn/images/avatar.png" ></div>
 
	<div class="author-description"><div class="author-title"><div class="author-link" rel="author">BWrong</div></div>


	<p class="author-bio">愿你走出半生，归来仍是少年</p></div></div>
	
		</div>



</article>

<div id="marlin_lite_about_widget-2" class="wow fadeInUp widget marlin_lite_about_widget" data-wow-delay="0.1s">

        
		<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://www.bwrong.cn/media/scripts/Valine.min.js'></script>

<div class="comment"></div>
<script>
        new Valine({
            av: AV,
            el: '.comment',
            lang: 'zh-cn',
            visitor: false, // 阅读量统计
            
            admin_email:'wang11535041@qq.com',
            
            
            emoticon_url: '/media/alu',
             
      emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
     
      app_id: 'jaz3TfUjRowK9fOMAPb9yw6i-MdYXbMMI',
      
      
      app_key: 'pbltxx4rElIP1RStL3AwujSp',
         
          
      placeholder: '欢迎你留下足迹'
       
        });
    </script>





		</div>

			</div>
			


<div class="tocc col l3 hide-on-med-and-down">

        <div class="toc-widget">

            <div class="toc-title"></div>

            <div id="toc-content">


			</div>
        </div>
    </div>


<script src="https://www.bwrong.cn/media/scripts/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '.entry-summary',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1,h2' //**
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('.entry-summary').children('h1, h2').each(function () {/**/
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget').parent();
        // let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>






			</div>
		</div>


		 <footer id="colophon" class="site-footer">

	<div class="container">

		<div class="copyright"> <br>Theme: <a
				href="https://github.com/alterfang/gridea-theme-pan" target="_blank" title="Pan"><span>Pan</span></a>.
			Powered by <a href="https://gridea.dev/" target="_blank" title="Gridea"><span>Gridea</span></a> . 版权所有：<a href="https://beian.miit.gov.cn/" target="_blank"><span>蜀ICP备2023018303号-1</span></a></div>
	</div>

</footer>
		<!-- loding -->
		<div class="loader">
			<div class="loader-content">
				<div class="songjingge">
					<span></span>
					<span></span>
					<span></span>
					<span></span>
					<span></span>
				</div>
			</div>
		</div>
<script id="rendered-js">
	window.onload = function () {
			var loader = document.getElementsByClassName("loader")[0];
			loader.className = "loader fadeout"; //使用渐隐的方法淡出loading page
			setTimeout(function () {
				loader.style.display = "none";
			}, 0);
	};
</script>


</div>

<script src="https://cdn.bootcss.com/fitvids/1.2.0/jquery.fitvids.min.js"></script>
<script type='text/javascript' src='https://www.bwrong.cn/media/scripts/marlin-scripts.js'></script>
<script src="https://www.bwrong.cn/media/scripts/lately.min.js"></script>
<script>jQuery(document).ready(function () { $.lately({ 'target': '.lately-a,.lately-b,.lately-c' }) });</script>
<style type="text/css">
  a.back_to_top {
    text-decoration: none;
    position: fixed;
    bottom: 40px;
    right: 30px;
    background: #f0f0f0;
    height: 40px;
    width: 40px;
    border-radius: 50%;
    line-height: 36px;
    font-size: 18px;
    text-align: center;
    transition-duration: .5s;
    transition-propety: background-color;
    display: none;
  }

  a.back_to_top span {
    color: #888;
  }

  a.back_to_top:hover {
    cursor: pointer;
    background: #dfdfdf;
  }

  a.back_to_top:hover span {
    color: #555;
  }

  @media print,
  screen and (max-width: 580px) {
    .back_to_top {
      display: none !important;
    }
  }
</style><a id="back_to_top" href="#" class="back_to_top"><span><i class="iconfont icon-xiangshang"></i></span>
</a>

<script>
$(document).ready((function (_this) {
    return function () {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function () {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block');
          } else {
            return bt.css('display', 'none');
          }
        });
        return bt.click(function () {
          $('body,html').animate({
            scrollTop: 0
          }, 800);
          return false;
        });
      }
    };
  })(this));
//   $(window).load(function () {
//     //异步延迟加载样式
//     var link = $('<link />');
//     link.attr('href', 'https://fonts.googleapis.com/css?family=Dancing+Script|Noto+Sans+SC:300|Montserrat&display=swap');
//     link.attr('rel', 'stylesheet');
//     link.appendTo($('head'));
// });
</script>

<!-- 宠物 -->
<canvas id="live2dcanvas" width="200" height="400" class="live2d"></canvas>
<style>
  #live2dcanvas {
    position: fixed;
    right: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -40px;
    width: 200px;
    height: 400px;
  }

  @media (max-width: 768px) {
    #live2dcanvas {
      width: 150px;
      height: 300px;
    }
  }

  @media (max-width: 639px) {
    #live2dcanvas {
      display: none !important;
    }
  }
</style>
<script src="https://www.bwrong.cn/media/scripts/L2Dwidget.min.js"></script>
<script>
  //初始化小人物 需设置属性pluginRootPath: "live2dw/"指明资源跟路径
  L2Dwidget.init({
    pluginRootPath: "media/",//资源root路径
    pluginJsPath: "scripts/",//js相对root的路径
    pluginModelPath: "model/",//模型相对root的路径
    tagMode: !1,
    debug: !1,
    model: {
      scale: 2,
      jsonPath: "/media/model/live2d-widget-model-epsilon/Epsilon2.1.model.json"
    },
    display: {//大小位置什么的自己慢慢调就是了
      position: "right",//定位
      width: 130,//宽度
      height: 210,//高度
      hOffset: -40,//左右
      vOffset: 0//上下
    },
    mobile: {
      show: !1
    },
    log: !1
  });
</script>
<!-- 宠物结束 -->

		<script data-no-instant>
    // (function ($) {
    //     $.extend({
    //         adamsOverload: function () {
    //             $('.navigation:eq(0)').remove();
    //             $("").attr("rel" , "external");
    //             $("a[rel='external'],a[rel='external nofollow']").attr("target","_blank");
    //             $("a.vi").attr("rel" , "");
    //             $.viewImage({
    //                 'target'  : 'img',
    //                 'exclude' : '.vsmile-icons img,.gallery img',
    //                 'delay'   : 300
    //             });
    //             $.lately({
    //                 'target' : '.commentmetadata a,.infos time,.post-list time'
	// 			});
	// 			console.log(prettyPrint)
	// 			if(prettyPrint) prettyPrint();

    //             $('ul.links li a').each(function(){
    //                 if($(this).parent().find('.bg').length==0){
    //                     $(this).parent().append('<!---<div class="bg" style="background-image:url(https://c3.glgoo.top/s2/favicons?domain='+$(this).attr("href")+')"></div>--->')
    //                 }
    //             });
    //         }
    //     });
    // })(jQuery);
	// jQuery.adamsOverload();

    (function ($) {
        $.extend({
            adamsOverload: function () {
                $.viewImage({
                    'target'  : '.song img',
                    'exclude' : '.vsmile-icons img',
                    'delay'   : 300
                });
            }
        });
    })(jQuery);
    jQuery.adamsOverload();
</script>

</body>
</html>
